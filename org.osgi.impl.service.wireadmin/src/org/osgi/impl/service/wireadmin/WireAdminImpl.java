package org.osgi.impl.service.wireadmin;

import java.util.*;
import org.osgi.service.log.LogService;
import org.osgi.util.tracker.ServiceTracker;
import org.osgi.service.wireadmin.*;
import java.io.IOException;
import org.osgi.service.cm.*;
import org.osgi.framework.*;

public class WireAdminImpl implements ServiceListener, WireAdmin,
		ManagedServiceFactory, BundleActivator {
	final static String			FACTORY_PID			= WireAdmin.class.getName();
	private Hashtable			allWires			= null;
	private BundleContext		context;
	private ServiceReference	myReference			= null;
	private Hashtable			producers			= null;
	private Hashtable			consumers			= null;
	private Hashtable			connectedProducers	= null;
	private Hashtable			connectedConsumers	= null;
	private Vector				ptot, vtot;
	private ServiceTracker		listenerTracker		= null;
	private UpdateDispatcher	dispatcher			= null;
	private Vector				justCreated;

	public WireAdminImpl() {
	}

	/**
	 * Create a new <tt>Wire</tt> object that connects a <tt>Producer</tt>
	 * service to a <tt>Consumer</tt> service.
	 * 
	 * The <tt>Producer</tt> service and <tt>Consumer</tt> service do not
	 * have to be registered when the the <tt>Wire</tt> object is created.
	 * 
	 * <p>
	 * The <tt>Wire</tt> configuration data is persistently stored. All
	 * <tt>Wire</tt> connections are reestablished when the <tt>WireAdmin</tt>
	 * service is registered. A <tt>Wire</tt> can be permanently removed by
	 * using the {@link #deleteWire}method.
	 * 
	 * <p>
	 * The <tt>Wire</tt> object's properties must have case insensitive
	 * <tt>String</tt> objects as keys (like the Framework). However, the case
	 * of the key must be preserved. The type of the value of the property must
	 * be one of the following:
	 * 
	 * <pre>
	 * 
	 *  type        = basetype
	 *  | vector | arrays
	 * 
	 *  basetype = String | Integer | Long
	 *  | Float | Double | Byte
	 *  | Short | Character
	 *  | Boolean
	 * 
	 *  primitive   = long | int | short
	 *  | char | byte | double | float
	 * 
	 *  arrays   = primitive '[]' | basetype '[]'
	 * 
	 *  vector   = Vector of basetype
	 *  
	 * </pre>
	 * 
	 * <p>
	 * The <tt>WireAdmin</tt> service must automatically add the following
	 * <tt>Wire</tt> properties:
	 * <ul>
	 * <li>{@link WireConstants#WIREADMIN_PID}set to the value of the wire's
	 * persistent identity (PID). This value is generated by the
	 * <tt>WireAdmin</tt> service when a <tt>Wire</tt> object is created.
	 * </li>
	 * <li>{@link WireConstants#WIREADMIN_PRODUCER_PID}set to the value of
	 * <tt>Producer</tt> service's PID.</li>
	 * <li>{@link WireConstants#WIREADMIN_CONSUMER_PID}set to the value of
	 * <tt>Consumer</tt> service's PID.</li>
	 * </ul>
	 * If the <tt>properties</tt> argument already contains any of these keys,
	 * then the supplied values are replaced with the values assigned by the
	 * <tt>WireAdmin</tt> service.
	 * 
	 * <p>
	 * The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_CREATED}after the new <tt>Wire</tt> object
	 * becomes available from {@link #getWires}.
	 * 
	 * @param producerPID The &quot;service.pid&quot; of the <tt>Producer</tt>
	 *        service to be connected to the <tt>Wire</tt>.
	 * @param consumerPID The &quot;service.pid&quot; of the <tt>Consumer</tt>
	 *        service to be connected to the <tt>Wire</tt>.
	 * @param properties The <tt>Wire</tt> object's properties. This argument
	 *        may be <tt>null</tt> if the caller does not wish to define any
	 *        <tt>Wire</tt> object's properties.
	 * @return The <tt>Wire</tt> object for this connection.
	 * @throws java.lang.IllegalArgumentException If <tt>properties</tt>
	 *         contains case variants of the same key name.
	 */
	public Wire createWire(String producerPID, String consumerPID,
			Dictionary properties) {
		
		// The producerPID must not be null
		if (producerPID == null) 
			throw new NullPointerException("Producer PID must not be null");
		
		// The producerPID must not be null
		if (consumerPID == null) 
			throw new NullPointerException("Consumer PID must not be null");
		
		Hashtable copy = new Hashtable();
		Object pkey;
		if (properties != null) {
			for (Enumeration e = properties.keys(); e.hasMoreElements();) {
				pkey = e.nextElement();
				copy.put(pkey, properties.get(pkey));
			}
		}
		properties = copy;
		if (properties != null) {
			Enumeration en = properties.keys();
			Vector temp = new Vector();
			while (en.hasMoreElements()) {
				Object o = en.nextElement();
				if (!(o instanceof String)) {
					throw new IllegalArgumentException("key must be a string");
				}
				String key = (String) o;
				if (temp.contains(key.toLowerCase())) {
					throw new IllegalArgumentException(
							"property case variant: " + key);
				}
				temp.addElement(key.toLowerCase());
			}
			temp = null;
		}
		WireImpl wire = new WireImpl();
		wire.setParent(this);
		ConfigurationAdmin cm = getCM();
		try {
			Configuration conf = cm.createFactoryConfiguration(FACTORY_PID);
			wire.setPID(conf.getPid());
			wire.setProducerPID(producerPID);
			wire.setConsumerPID(consumerPID);
			if (properties == null) {
				properties = new Hashtable();
			}
			wire.setProperties(properties);
			addWire(wire);
			justCreated.addElement(wire);
			conf.update(wire.getProperties());
			findEndPoints(wire);
			return wire;
		}
		catch (IOException iox) {
			getLogService().log(LogService.LOG_ERROR,
					"unable to persist wires using CM", iox);
			return null;
		}
	}

	/**
	 * Delete a <tt>Wire</tt>.
	 * 
	 * <p>
	 * The <tt>Wire</tt> representing a connection between a <tt>Producer</tt>
	 * service and a <tt>Consumer</tt> service is removed. The persistently
	 * stored configuration data for the <tt>Wire</tt> object is destroyed.
	 * The <tt>Wire</tt> object's method {@link Wire#isValid}will return
	 * <tt>false</tt> after it is deleted.
	 * 
	 * <p>
	 * The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_DELETED}after the <tt>Wire</tt> object
	 * becomes invalid.
	 * 
	 * @param wire The <tt>Wire</tt> object which is to be deleted.
	 */
	public void deleteWire(Wire wire) {
		try {
			getCM().getConfiguration(((WireImpl) wire).getPID()).delete();
		}
		catch (IOException iox) {
			getLogService().log(LogService.LOG_ERROR,
					"unable to delete wire from CM", iox);
		}
	}

	/**
	 * Return the <tt>Wire</tt> objects that match the given <tt>filter</tt>.
	 * 
	 * <p>
	 * The list of available <tt>Wire</tt> objects is matched against the
	 * specified <tt>filter</tt>.<tt>Wire</tt> objects which match the
	 * <tt>filter</tt> are returned. These <tt>Wire</tt> objects are not
	 * necessarily connected. The Wire Admin service should not return invalid
	 * <tt>Wire</tt> objects, but it is possible that a <tt>Wire</tt> object
	 * is deleted after it was placed in the list.
	 * 
	 * <p>
	 * The filter matches against the <tt>Wire</tt> object's properties
	 * including {@link WireConstants#WIREADMIN_PRODUCER_PID},
	 * {@link WireConstants#WIREADMIN_CONSUMER_PID}and
	 * {@link WireConstants#WIREADMIN_PID}.
	 * 
	 * @param filterString Filter string to select <tt>Wire</tt> objects or
	 *        <tt>null</tt> to select all <tt>Wire</tt> objects.
	 * @return An array of <tt>Wire</tt> objects which match the
	 *         <tt>filter</tt> or <tt>null</tt> if no <tt>Wire</tt>
	 *         objects match the <tt>filter</tt>.
	 * @throws org.osgi.framework.InvalidSyntaxException If the specified
	 *         <tt>filter</tt> has an invalid syntax.
	 * @see "org.osgi.framework.Filter"
	 */
	public Wire[] getWires(String filterString) throws InvalidSyntaxException {
		Filter filter = null;
		if (filterString != null) {
			filter = context.createFilter(filterString);
		}
		if (allWires.size() == 0) {
			return null;
		}
		Enumeration e = null;
		Wire[] result = null;
		e = allWires.elements();
		if (filterString != null) {
			Vector tmpResult = new Vector(allWires.size());
			Wire aWire;
			while (e.hasMoreElements()) {
				aWire = (Wire) e.nextElement();
				if (filter.match(aWire.getProperties())) {
					tmpResult.addElement(aWire);
				}
			}
			e = tmpResult.elements();
			if (tmpResult.size() == 0) {
				return null;
			}
			result = new Wire[tmpResult.size()];
		}
		else {
			result = new Wire[allWires.size()];
		}
		for (int x = 0; x < result.length; x++) {
			result[x] = (Wire) e.nextElement();
		}
		return result;
	}

	/**
	 * Update the properties of a <tt>Wire</tt> object.
	 * 
	 * The persistently stored configuration data for the <tt>Wire</tt> object
	 * is updated with the new properties and then the <tt>Consumer</tt> and
	 * <tt>Producer</tt> services will be called at the respective
	 * {@link Consumer#producersConnected}and
	 * {@link Producer#consumersConnected}methods.
	 * 
	 * <p>
	 * The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_UPDATED}after the updated properties are
	 * available from the <tt>Wire</tt> object.
	 * 
	 * @param wire The <tt>Wire</tt> object which is to be updated.
	 * @param properties The new <tt>Wire</tt> object's properties or
	 *        <tt>null</tt> if no properties are required.
	 */
	public void updateWire(Wire wire, Dictionary properties) {
		try {
			// The updated wire must be valid
			if (wire.isValid()) {
				Dictionary wireProps = wire.getProperties();
				String pid = (String) wireProps.get(WireConstants.WIREADMIN_PID);
				String consumerPID = (String) wireProps
					.get(WireConstants.WIREADMIN_CONSUMER_PID);
				String producerPID = (String) wireProps
					.get(WireConstants.WIREADMIN_PRODUCER_PID);
				properties.put(WireConstants.WIREADMIN_PRODUCER_PID, producerPID);
				properties.put(WireConstants.WIREADMIN_CONSUMER_PID, consumerPID);
				properties.put(WireConstants.WIREADMIN_PID, String.valueOf(pid));
				getCM().getConfiguration(((WireImpl) wire).getPID()).update(
					properties);
				((WireImpl)wire).setProperties(properties);
			}
		}
		catch (IOException iox) {
			getLogService().log(LogService.LOG_ERROR,
					"unable to persist wires via CM", iox);
		}
	}

	/**
	 * Forward a WireAdminEvent to all registered WireAdminListeners.
	 */
	public void bCast(int type, Wire wire, Throwable throwable) {
		WireAdminEvent event = new WireAdminEvent(myReference, type, wire,
				throwable);
		ServiceReference[] references = listenerTracker.getServiceReferences();
		if (references == null) {
			return;
		}
		WireAdminListener listener;
		for (int x = 0; x < references.length; x++) {
			try {
				int events = ((Integer) references[x]
						.getProperty(WireConstants.WIREADMIN_EVENTS))
						.intValue();
				if (events == type || (events & type) > 0) {
					listener = (WireAdminListener) context
							.getService(references[x]);
					listener.wireAdminEvent(event);
				}
			}
			catch (Exception ex) {
				ex.printStackTrace();
			}
		}
	}

	/**
	 * Called when the bundle is started so that the bundle can perform any
	 * bundle specific activities to start the bundle. Bundle programmers can
	 * use this method to register the bundle's services or to allocate any
	 * resources that the bundle needs.
	 * 
	 * <p>
	 * This method must complete and return to its caller in a timely manner.
	 * 
	 * @param context The execution context of the bundle being started.
	 * @exception java.lang.Exception If this method throws an exception, the
	 *            bundle is marked as stopped and the framework will remove the
	 *            bundle's listeners, unregister all service's registered by the
	 *            bundle, release all service's used by the bundle.
	 */
	public void start(BundleContext context) throws Exception {
		this.context = context;
		allWires = new Hashtable();
		producers = new Hashtable();
		consumers = new Hashtable();
		connectedProducers = new Hashtable();
		connectedConsumers = new Hashtable();
		ptot = new Vector();
		vtot = new Vector();
		justCreated = new Vector();
		dispatcher = new UpdateDispatcher(this);
		ServiceRegistration registration = context.registerService(
				WireAdmin.class.getName(), this, null);
		myReference = registration.getReference();
		listenerTracker = new ServiceTracker(context, WireAdminListener.class
				.getName(), null);
		listenerTracker.open();
		checkExistingProducers();
		checkExistingConsumers();
		try {
			context.addServiceListener(this, "(|("
					+ org.osgi.framework.Constants.OBJECTCLASS + "="
					+ Producer.class.getName() + ")("
					+ org.osgi.framework.Constants.OBJECTCLASS + "="
					+ Consumer.class.getName() + "))");
		}
		catch (InvalidSyntaxException ivsx) {
			ivsx.printStackTrace();
		}
		Hashtable props = new Hashtable(1);
		props.put(org.osgi.framework.Constants.SERVICE_PID, FACTORY_PID);
		context.registerService(ManagedServiceFactory.class.getName(), this,
				props);
		WireCommandProvider cProvider = new WireCommandProvider(context, this);
		context.registerService("org.osgi.tools.command.CommandProvider",
				cProvider, null);
	}

	/**
	 * Called when the bundle is stopped so that the bundle can perform any
	 * bundle specific activities necessary to stop the bundle. In general, this
	 * method should undo the work that the {@link #start start}method did.
	 * When this method returns the bundle should have no active threads. A
	 * stopped bundle should be stopped and should not be calling any framework
	 * objects.
	 * 
	 * <p>
	 * This method must complete and return to its caller in a timely manner.
	 * 
	 * @param context The execution context of the bundle being stopped.
	 * @exception java.lang.Exception If this method throws an exception, the
	 *            bundle is still marked as stopped and the framework will
	 *            remove the bundle's listeners, unregister all service's
	 *            registered by the bundle, release all service's used by the
	 *            bundle.
	 */
	public void stop(BundleContext context) throws Exception {
		// kill all wires
		listenerTracker.close();
		listenerTracker = null;
		dispatcher.stopDispatching();
		dispatcher = null;
		allWires = null;
		producers = null;
		consumers = null;
		connectedProducers = null;
		connectedConsumers = null;
		Iterator it = ptot.iterator();
		while (it.hasNext()) {
			Producer p = (Producer) (it.next());
			p.consumersConnected(null);
		}
		Iterator it2 = vtot.iterator();
		while (it2.hasNext()) {
			Consumer v = (Consumer) (it2.next());
			v.producersConnected(null);
		}
	}

	BundleContext getBundleContext() {
		return context;
	}

	Wire[] getProducerWires(String producerPID) {
		return getWires((Vector) connectedProducers.get(producerPID));
	}

	Wire[] getConsumerWires(String consumerPID) {
		return getWires((Vector) connectedConsumers.get(consumerPID));
	}

	private Wire[] getWires(Vector store) {
		if (store == null || store.size() == 0) {
			return null;
		}
		Wire[] result = new Wire[store.size()];
		Enumeration e = store.elements();
		for (int x = 0; x < result.length; x++) {
			result[x] = (Wire) e.nextElement();
		}
		return result;
	}

	void addWire(WireImpl wire) {
		allWires.put(wire.getPID(), wire);
		Vector wires = (Vector) producers.get(wire.getProducerPID());
		if (wires == null) {
			wires = new Vector();
			producers.put(wire.getProducerPID(), wires);
		}
		wires.addElement(wire);
		wires = (Vector) consumers.get(wire.getConsumerPID());
		if (wires == null) {
			wires = new Vector();
			consumers.put(wire.getConsumerPID(), wires);
		}
		wires.addElement(wire);
		bCast(WireAdminEvent.WIRE_CREATED, wire, null);
		getLogService().log(
				LogService.LOG_DEBUG,
				"created wire with PID " + wire.getProducerPID() + " and CID "
						+ wire.getConsumerPID());
	}

	void removeWire(WireImpl wire) {
		allWires.remove(wire.getPID());
		Vector wires = (Vector) producers.get(wire.getProducerPID());
		if (wires != null) {
			wires.removeElement(wire);
			if (wires.size() == 0) {
				producers.remove(wire.getProducerPID());
			}
		}
		wires = (Vector) consumers.get(wire.getConsumerPID());
		if (wires != null) {
			wires.removeElement(wire);
			if (wires.size() == 0) {
				consumers.remove(wire.getConsumerPID());
			}
		}
	}

	/**
	 * A Consumer or Producer has been registered --> look for wires and set
	 * their producer/consumer references.
	 */
	public Object addingService(ServiceReference reference) {
		Object service = context.getService(reference);
		String[] classes = (String[]) reference
				.getProperty(org.osgi.framework.Constants.OBJECTCLASS);
		String pid = (String) reference
				.getProperty(org.osgi.framework.Constants.SERVICE_PID);
		for (int x = 0; x < classes.length; x++) {
			if (classes[x].equals(Producer.class.getName())) {
				Producer producer = (Producer) service;
				Vector wires = (Vector) producers.get(pid);
				boolean noConnectedWires = true;
				WireImpl aWire;
				if (wires != null) {
					synchronized (wires) {
						for (Enumeration e = wires.elements(); e
								.hasMoreElements();) {
							aWire = (WireImpl) e.nextElement();
							aWire.setProducer(reference);
							if (aWire.isConnected()) {
								noConnectedWires = false;
							}
						}
					}
				}
				else {
				}
				if (noConnectedWires) {
					dispatcher.addProducerUpdate(producer, null, null);
				}
			}
			else
				if (classes[x].equals(Consumer.class.getName())) {
					Consumer consumer = (Consumer) service;
					Vector wires = (Vector) consumers.get(pid);
					if (wires != null) {
						synchronized (wires) {
							for (Enumeration e = wires.elements(); e
									.hasMoreElements();) {
								((WireImpl) e.nextElement())
										.setConsumer(reference);
							}
						}
					}
					else {
						dispatcher.addConsumerUpdate(consumer, null, null);
					}
				}
		}
		return service;
	}

	/**
	 * If a Consumer was modified, update the flavors/filter.
	 */
	public void modifiedService(ServiceReference reference) {
		String[] classes = (String[]) reference
				.getProperty(org.osgi.framework.Constants.OBJECTCLASS);
		
		for (int x = 0; x < classes.length; x++) {
			// Checks if the service is a Consumer and modifies reference to the service
			if (classes[x].equals(Consumer.class.getName())) {
				String pid = (String) reference
						.getProperty(org.osgi.framework.Constants.SERVICE_PID);
				Vector wires = (Vector) consumers.get(pid);
				synchronized (wires) {
					for (Enumeration e = wires.elements(); e.hasMoreElements();) {
						((WireImpl) e.nextElement()).setConsumer(reference);
					}
				}
			}
			
			// Checks if the service is a Producer and modifies reference to the service
			else if (classes[x].equals(Producer.class.getName())) {
				String pid = (String) reference.getProperty(org.osgi.framework.Constants.SERVICE_PID);
				Vector wires = (Vector) producers.get(pid);
				synchronized (wires) {
					for (Enumeration e = wires.elements(); e.hasMoreElements();) {
						((WireImpl) e.nextElement()).setProducer(reference);
					}
				}
			}
		}
	}

	/**
	 * Look for wires to disconnect.
	 */
	public void removedService(ServiceReference reference) {
		String pid = (String) reference
				.getProperty(org.osgi.framework.Constants.SERVICE_PID);
		String[] classes = (String[]) reference
				.getProperty(org.osgi.framework.Constants.OBJECTCLASS);
		for (int x = 0; x < classes.length; x++) {
			if (classes[x].equals(Producer.class.getName())) {
				Vector wires = (Vector) producers.get(pid);
				if (wires != null) {
					synchronized (wires) {
						for (Enumeration e = wires.elements(); e
								.hasMoreElements();) {
							((WireImpl) e.nextElement()).setProducer(null);
						}
						//producers.remove(pid);
					}
				}
			}
			else
				if (classes[x].equals(Consumer.class.getName())) {
					Vector wires = (Vector) consumers.get(pid);
					if (wires != null) {
						synchronized (wires) {
							for (Enumeration e = wires.elements(); e
									.hasMoreElements();) {
								((WireImpl) e.nextElement()).setConsumer(null);
							}
							//consumers.remove(pid);
						}
					}
				}
		}
	}

	LogService getLogService() {
		ServiceReference sr = context.getServiceReference(LogService.class
				.getName());
		if (sr == null) {
			return null;
		}
		return (LogService) context.getService(sr);
	}

	ConfigurationAdmin getCM() {
		ServiceReference sr = context
				.getServiceReference(ConfigurationAdmin.class.getName());
		if (sr == null) {
			return null;
		}
		return (ConfigurationAdmin) context.getService(sr);
	}

	/**
	 * Remove a service instance.
	 * 
	 * Remove the service instance associated with the PID. If the instance was
	 * registered with the service registry, it should be unregistered.
	 * <p>
	 * If this method throws any Exception, the ConfigurationAdmin must catch it
	 * and should log it.
	 * <p>
	 * The ConfigurationAdmin must call this method on a thread other than the
	 * thread which called delete() on the corresponding Configuration object.
	 * 
	 * @param pid the PID of the service to be removed
	 */
	public void deleted(String pid) {
		try {
			WireImpl wire = (WireImpl) allWires.get(pid);
			wireDisconnected(wire);
			wire.delete();
			removeWire(wire);
			bCast(WireAdminEvent.WIRE_DELETED, wire, null);
		}
		catch (Exception e) {
			e.printStackTrace(); //To change body of catch statement use
								 // Options | File Templates.
		}
	}

	/**
	 * Return a descriptive name of this factory.
	 * 
	 * @return the name for the factory, which might be localized
	 */
	public String getName() {
		return "WireAdmin";
	}

	/**
	 * Create a new instance, or update the configuration of an existing
	 * instance.
	 * 
	 * If the PID of the configuration object is new for the
	 * ManagedServiceFactory, then create a new service instance, using the
	 * configuration properties provided. Else, update the service instance with
	 * the provided properties.
	 * <p>
	 * If the service instance is registered with the framework, then the
	 * configuration properties should be copied to its registry properties.
	 * This is not mandatory and security sensitive properties should obviously
	 * not be copied.
	 * <p>
	 * If this method throws any Exception, the ConfigurationAdmin must catch it
	 * and should log it.
	 * <p>
	 * When the implementation of updated() detects any kind of error in the
	 * configuration properties, it should create a new ConfigurationException
	 * which describes the problem.
	 * <p>
	 * The ConfigurationAdmin must call this method on a thread other than the
	 * thread which necessitated the call-back. This implies that implementors
	 * of ManagedServiceFactory can be assured that the call-back will not take
	 * place during registration when they execute the registration in a
	 * synchronized method.
	 * 
	 * @param pid the PID for this configuration
	 * @param properties the configuration properties
	 * @throws ConfigurationException when the configuration is invalid
	 */
	public void updated(String pid, Dictionary properties)
			throws ConfigurationException {
		WireImpl wire = (WireImpl) allWires.get(pid);
		getLogService().log(LogService.LOG_INFO,
				"wire with pid " + pid + " was updated by CM");
		if (wire != null) {
			if (justCreated.contains(wire)) {
				justCreated.remove(wire);
			}
			else {
				wire.setProperties(properties);
				bCast(WireAdminEvent.WIRE_UPDATED, wire, null);
			}
		}
		else {
			// try to create a new one
			String producerPID = (String) properties
					.get(WireConstants.WIREADMIN_PRODUCER_PID);
			if (producerPID == null) {
				throw new ConfigurationException(
						WireConstants.WIREADMIN_PRODUCER_PID, "doesn't exist");
			}
			String consumerPID = (String) properties
					.get(WireConstants.WIREADMIN_CONSUMER_PID);
			if (consumerPID == null) {
				throw new ConfigurationException(
						WireConstants.WIREADMIN_CONSUMER_PID, "doesn't exist");
			}
			wire = new WireImpl();
			wire.setParent(this);
			wire.setPID(pid);
			wire.setProducerPID(producerPID);
			wire.setConsumerPID(consumerPID);
			if (properties == null) {
				properties = new Hashtable();
			}
			wire.setProperties(properties);
			addWire(wire);
			findEndPoints(wire);
		}
	}

	UpdateDispatcher getUpdateDispatcher() {
		return dispatcher;
	}

	/**
	 * Receive notification that a service has had a change occur in it's
	 * lifecycle.
	 * 
	 * @param event The ServiceEvent.
	 */
	public void serviceChanged(ServiceEvent event) {
		switch (event.getType()) {
			case ServiceEvent.REGISTERED :
				addingService(event.getServiceReference());
				break;
			case ServiceEvent.MODIFIED :
				modifiedService(event.getServiceReference());
				break;
			case ServiceEvent.UNREGISTERING :
				removedService(event.getServiceReference());
				break;
		}
	}

	private void findEndPoints(WireImpl wire) {
		// check if producers/consumers have already been registered
		try {
			ServiceReference[] references = context.getServiceReferences(
					Producer.class.getName(), "(service.pid="
							+ wire.getProducerPID() + ")");
			if (references != null) {
				wire.setProducer(references[0]);
			}
			references = context.getServiceReferences(Consumer.class.getName(),
					"(service.pid=" + wire.getConsumerPID() + ")");
			if (references != null) {
				wire.setConsumer(references[0]);
			}
		}
		catch (InvalidSyntaxException ivsx) {
			ivsx.printStackTrace();
		}
	}

	void wireConnected(WireImpl wire) {
		ptot.add(wire.getProducer());
		Vector wires = (Vector) connectedProducers.get(wire.getProducerPID());
		if (wires == null) {
			wires = new Vector();
			connectedProducers.put(wire.getProducerPID(), wires);
		}
		wires.addElement(wire);
		wires = (Vector) connectedConsumers.get(wire.getConsumerPID());
		if (wires == null) {
			wires = new Vector();
			connectedConsumers.put(wire.getConsumerPID(), wires);
			vtot.add(wire.getConsumer());
		}
		wires.addElement(wire);
		bCast(WireAdminEvent.WIRE_CONNECTED, wire, null);
	}

	void wireDisconnected(WireImpl wire) {
		boolean event = false;
		Vector wires = (Vector) connectedProducers.get(wire.getProducerPID());
		if (wires != null) {
			event = true;
			wires.removeElement(wire);
			if (wires.size() == 0) {
				connectedProducers.remove(wire.getProducerPID());
				ptot.remove(wire.getProducer());
			}
		}
		wires = (Vector) connectedConsumers.get(wire.getConsumerPID());
		if (wires != null) {
			event = true;
			wires.removeElement(wire);
			if (wires.size() == 0) {
				connectedConsumers.remove(wire.getConsumerPID());
				vtot.remove(wire.getConsumer());
			}
		}
		if (event) {
			bCast(WireAdminEvent.WIRE_DISCONNECTED, wire, null);
		}
	}

	void checkExistingConsumers() {
		ServiceReference[] sr = null;
		try {
			sr = context.getServiceReferences(
					"org.osgi.service.wireadmin.Consumer", null);
		}
		catch (InvalidSyntaxException e) {
			// duh
			e.printStackTrace();
			System.exit(0);
		}
		if (sr != null) {
			for (int i = 0; i < sr.length; i++) {
				Consumer c = (Consumer) (context.getService(sr[i]));
				c.producersConnected(null);
			}
		}
	}

	void checkExistingProducers() {
		ServiceReference[] sr = null;
		try {
			sr = context.getServiceReferences(
					"org.osgi.service.wireadmin.Producer", null);
		}
		catch (InvalidSyntaxException e) {
			// duh
			e.printStackTrace();
			System.exit(0);
		}
		if (sr != null) {
			for (int i = 0; i < sr.length; i++) {
				Producer p = (Producer) (context.getService(sr[i]));
				p.consumersConnected(null);
			}
		}
	}

	public void updateProducer(Producer producer, WireImpl source, String pid ) {
		dispatcher.addProducerUpdate(producer,source, getProducerWires(pid));
	}

	public void updateConsumer(Consumer consumer, WireImpl wire, String pid ) {
		dispatcher.addConsumerUpdate(consumer,null, getConsumerWires(pid));
	}

}
