<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->

<chapter label="117"
         revision="$Id$"
         version="5.0" xml:id="service.dmt"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Dmt Admin Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.dmt-version"
    linkend="org.osgi.service.dmt"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>There are a large number of Device Management standards available
    today. Starting with the ITU X.700 series in the seventies, SNMP in the
    eighties and then an explosion of different protocols when the use of the
    Internet expanded in the nineties. Many device management standards have
    flourished, and some subsequently withered, over the last decades. Some
    examples:</para>

    <itemizedlist>
      <listitem>
        <para>X.700 CMIP</para>
      </listitem>

      <listitem>
        <para>IETF SNMP</para>
      </listitem>

      <listitem>
        <para>IETF LDAP</para>
      </listitem>

      <listitem>
        <para>OMA DM</para>
      </listitem>

      <listitem>
        <para>Broadband Forum TR-069</para>
      </listitem>

      <listitem>
        <para>UPnP Forum's Device Management</para>
      </listitem>

      <listitem>
        <para>IETF NETCONF</para>
      </listitem>

      <listitem>
        <para>OASIS WS Distributed Management</para>
      </listitem>
    </itemizedlist>

    <para>This heterogeneity of the remote management for OSGi Framework based
    devices is a problem for device manufacturers. Since there is often no
    dominant protocol these manufacturers have to develop multiple solutions
    for different remote management protocols. It is also problematic for
    device operators since they have to choose a specific protocol but by that
    choice could exclude a class of devices that do not support that protocol.
    There is therefore a need to allow the use of multiple protocols at
    minimal costs.</para>

    <para>Almost all management standards are based on hierarchical object
    models and provide <emphasis>primitives</emphasis> like:</para>

    <itemizedlist>
      <listitem>
        <para>Get and replace values</para>
      </listitem>

      <listitem>
        <para>Add/Remove instances</para>
      </listitem>

      <listitem>
        <para>Discovery of value names and instance ids</para>
      </listitem>

      <listitem>
        <para>Provide notifications</para>
      </listitem>
    </itemizedlist>

    <para>A Device Management standard consists of a <emphasis>protocol
    stack</emphasis> and a number of <emphasis>object models</emphasis>. The
    protocol stack is generic and shared for all object types; the object
    model describes a specific device's properties and methods. For example,
    the protocol stack can consist of a set of SOAP message formats and an
    object model is a <code>Deployment Unit</code>. An object model consists
    of a data model and sometimes a set of functions.</para>

    <para>The core problem is that the generic Device Management Tree must be
    mapped to device specific functions. This specification therefore defines
    an API for managing a device using general device management concepts but
    providing an effective plugin model to link the generic tree to the
    specific device functions.</para>

    <para>The API is decomposed in the following
    packages/functionality:</para>

    <itemizedlist>
      <listitem>
        <para><code>org.osgi.service.dmt</code> - Main package that provides
        access to the local Device Management Tree. Access is session
        based.</para>
      </listitem>

      <listitem>
        <para><code>org.osgi.service.dmt.notification</code> - The
        notification package provides the capability to send alerts to a
        management server.</para>
      </listitem>

      <listitem>
        <para><code>org.osgi.service.dmt.spi</code> - Provides the capability
        to register subtree handlers in the Device Management Tree.</para>
      </listitem>

      <listitem>
        <para><code>org.osgi.service.dmt.notification.spi</code> - The API to
        provide the possibility to extend the notification system.</para>
      </listitem>

      <listitem>
        <para><code>org.osgi.service.dmt.security</code> - Permission
        classes.</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Device Management Tree</emphasis> - The Device
          Management Tree (DMT) is the logical view of manageable aspects of
          an OSGi Environment, implemented by plugins and structured in a tree
          with named nodes.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dmt Admin</emphasis> - A service through which the
          DMT can be manipulated. It is used by <emphasis>Local
          Managers</emphasis> or by <emphasis>Protocol Adapters</emphasis>
          that initiate DMT operations. The Dmt Admin service forwards
          selected DMT operations to Data Plugins and execute operations to
          Exec Plugins; in certain cases the Dmt Admin service handles the
          operations itself. The Dmt Admin service is a singleton.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dmt Session</emphasis> - A session groups a set of
          operations on a sub-tree with optional transactionality and locking.
          Dmt Session objects are created by the Dmt Admin service and are
          given to a plugin when they first join the session.</para>
        </listitem>

        <listitem>
          <para><emphasis>Local Manager</emphasis> - A bundle which uses the
          Dmt Admin service directly to read or manipulate the DMT. Local
          Managers usually do not have a principal associated with the
          session.</para>
        </listitem>

        <listitem>
          <para><emphasis>Protocol Adapter</emphasis> - A bundle that
          communicates with a management server external to the device and
          uses the Dmt Admin service to operate on the DMT. Protocol Adapters
          usually have a principal associated with their sessions.</para>
        </listitem>

        <listitem>
          <para><emphasis>Meta Node</emphasis> - Information provided by the
          node implementer about a node for the purpose of performing
          validation and providing assistance to users when these values are
          edited.</para>
        </listitem>

        <listitem>
          <para><emphasis>Multi nodes</emphasis> - Interior nodes that have a
          homogeneous set of children. All these children share the same meta
          node.</para>
        </listitem>

        <listitem>
          <para><emphasis>Plugin</emphasis> - Services which take the
          responsibility over a given sub-tree of the DMT: Data Plugin
          services and Exec Plugin services.</para>
        </listitem>

        <listitem>
          <para><emphasis>Data Plugin</emphasis> - A Plugin that can create a
          Readable Data Session, Read Write Data Session, or Transactional
          Data Session for data operations on a sub-tree for a Dmt
          Session.</para>
        </listitem>

        <listitem>
          <para><emphasis>Exec Plugin</emphasis> - A Plugin that can handle
          execute operations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Readable Data Session</emphasis> - A plugin session
          that can only read.</para>
        </listitem>

        <listitem>
          <para><emphasis>Read Write Data Session</emphasis> - A plugin
          session that can read and write.</para>
        </listitem>

        <listitem>
          <para><emphasis>Transactional Data Session</emphasis> - A plugin
          session that is transactional.</para>
        </listitem>

        <listitem>
          <para><emphasis>Principal</emphasis> - Represents the optional
          identity of an initiator of a Dmt Session. When a session has a
          principal, the Dmt Admin must enforce ACLs and must ignore Dmt
          Permissions.</para>
        </listitem>

        <listitem>
          <para><emphasis>ACL</emphasis> - An Access Control List is a set of
          principals that is associated with permitted operations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dmt Event</emphasis> - Information about a
          modification of the DMT.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dmt Event Listener</emphasis> - Listeners to Dmt
          Events. These listeners are services according to the white board
          pattern.</para>
        </listitem>

        <listitem>
          <para><emphasis>Mount Point</emphasis> - A point in the DMT where a
          Plugin or the Dmt Admin service allows other Plugins to have their
          root.</para>
        </listitem>
      </itemizedlist>

      <para>The overall service interaction diagram is depicted in <xref
      linkend="i2818213"/>.</para>

      <figure xml:id="i2818213">
        <title>Overall Service Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.072in"
                       contentwidth="6.230in" fileref="overall.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The entities used in the Dmt Admin operations and notifications
      are depicted in <xref linkend="i2421961"/>.</para>

      <figure pgwide="1" xml:id="i2421961">
        <title>Using Dmt Admin service, org.osgi.service.dmt and
        org.osgi.service.dmt.notification.* packages</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="4.538in"
                       contentwidth="7.000in" fileref="dmtadmin-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Extending the Dmt Admin service with Plugins is depicted in <xref
      linkend="i2422005"/>.</para>

      <figure pgwide="1" xml:id="i2422005">
        <title>Extending the Dmt Admin service, org.osgi.service.dmt.spi
        package</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="4.107in"
                       contentwidth="7.000in" fileref="spi-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>The Device Management Model</title>

    <para>The standard-based features of the DMT model are:</para>

    <itemizedlist>
      <listitem>
        <para>The Device Management Tree consists of
        <emphasis>interior</emphasis> nodes and <emphasis>leaf</emphasis>
        nodes. Interior nodes can have children and leaf nodes have primitive
        values.</para>
      </listitem>

      <listitem>
        <para>All nodes have a set of properties: Name, Title, Format, ACL,
        Version, Size, Type, Value, and TimeStamp.</para>
      </listitem>

      <listitem>
        <para>The storage of the nodes is undefined. Nodes typically map to
        peripheral registers, settings, configuration, databases, etc.</para>
      </listitem>

      <listitem>
        <para>A node's name must be unique among its siblings.</para>
      </listitem>

      <listitem>
        <para>Nodes can have Access Control Lists (ACLs), associating
        operations allowed on those nodes with a particular principal.</para>
      </listitem>

      <listitem>
        <para>Nodes can have Meta Nodes that describe actual nodes and their
        siblings.</para>
      </listitem>

      <listitem>
        <para>Base value types (called <emphasis>formats</emphasis> in the
        standard) are</para>

        <itemizedlist>
          <listitem>
            <para>integer</para>
          </listitem>

          <listitem>
            <para>long</para>
          </listitem>

          <listitem>
            <para>string</para>
          </listitem>

          <listitem>
            <para>boolean</para>
          </listitem>

          <listitem>
            <para>binary data (multiple types)</para>
          </listitem>

          <listitem>
            <para>datetime</para>
          </listitem>

          <listitem>
            <para>time</para>
          </listitem>

          <listitem>
            <para>float</para>
          </listitem>

          <listitem>
            <para>XML fragments</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Leaf nodes in the tree can have default values specified in the
        meta node.</para>
      </listitem>

      <listitem>
        <para>Meta Nodes define allowed access operations (<code>Get</code>,
        <code>Add</code>, <code>Replace</code>, <code>Delete</code> and
        <code>Exec</code>)</para>
      </listitem>
    </itemizedlist>

    <figure pgwide="1" xml:id="i1416892">
      <title>Device Management Tree example</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.586in"
                     contentwidth="5.011in" fileref="dmt-example.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Tree Terminology</title>

      <para>In the following sections, the DMT is discussed frequently. Thus,
      well-defined terms for all the concepts that the DMT introduces are
      needed. The different terms are shown in <xref
      linkend="i1659141"/>.</para>

      <figure xml:id="i1659141">
        <title>DMT naming, relative to node F</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.913in"
                       contentwidth="5.011in" fileref="naming-f.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>All terms are defined relative to node <code>F</code>. For this
      node, the terminology is as follows:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>URI</emphasis> - The path consisting of node names
          that uniquely defines a node, see <xref linkend="i2275977"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>ancestors</emphasis> - All nodes that are above the
          given node ordered in proximity. The closest node must be first in
          the list. In the example, this list is [./<code>E</code>,
          <code>.]</code></para>
        </listitem>

        <listitem>
          <para><emphasis>parent</emphasis> - The first ancestor, in this
          example this is <code>./E</code>.</para>
        </listitem>

        <listitem>
          <para><emphasis>children</emphasis> - A list of nodes that are
          directly beneath the given node without any preferred ordering. For
          node <code>F</code> this list is <code>{ ./E/F/f1, ./E/F/f2, ./E/F/G
          }</code>.</para>
        </listitem>

        <listitem>
          <para><emphasis>siblings</emphasis> - An unordered list of nodes
          that have the same parent. All siblings must have different names.
          For <code>F</code>, this is <code>{ ./E/K}</code></para>
        </listitem>

        <listitem>
          <para><emphasis>descendants</emphasis> - A list of all nodes below
          the given node. For F this is <code>{ ./E/F/f1, ./E/F/G, ./E/F/f2,
          ./E/F/G/H, ./E/F/G/I, ./E/F/G/J }</code></para>
        </listitem>

        <listitem>
          <para><emphasis>sub-tree</emphasis> - The given node plus the list
          of all descendants. For node <code>F</code> this is <code>{ ./E/F,
          ./E/F/f1, ./E/F/G, ./E/F/f2, ./E/F/G/H, ./E/F/G/I, ./E/F/G/J
          }</code></para>
        </listitem>

        <listitem>
          <para><emphasis>overlap</emphasis> - Two given URIs overlap if they
          share any node in their sub-trees. In the example, the sub-tree
          <code>./E/F</code> and <code>./E/F/G</code> overlap.</para>
        </listitem>

        <listitem>
          <para><emphasis>data root URI</emphasis> - A URI which represents
          the root of a Data Plugin.</para>
        </listitem>

        <listitem>
          <para><emphasis>exec root URI</emphasis> - A URI which represents
          the root of an Exec Plugin.</para>
        </listitem>

        <listitem>
          <para><emphasis>Parent Plugin</emphasis> - A Plugin <code>A</code>
          is a Parent Plugin of Plugin <code>B</code> if <code>B</code>'s root
          is a in <code>A</code>'s sub-tree, this requires a Parent Plugin to
          at least have one mount point.</para>
        </listitem>

        <listitem>
          <para><emphasis>Child Plugin</emphasis> - A Plugin <code>A</code> is
          a Child Plugin of Plugin <code>B</code> if <code>A</code>'s root is
          in <code>B</code>'s sub-tree.</para>
        </listitem>

        <listitem>
          <para><emphasis>Scaffold Node</emphasis> - An ancestor node of a
          Plugin that is managed by the Dmt Admin service to ensure that all
          nodes are discoverable by traversing from the root.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Actors</title>

      <para>There are two typical users of the Dmt Admin service:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Remote manager</emphasis> - The typical client of
          the Dmt Admin service is a <emphasis>Protocol Adapter</emphasis>. A
          management server external to the device can issue DMT operations
          over some management protocol. The protocol to be used is not
          specified by this specification. For example, OMA DM, TR-069, or
          others could be used. The protocol operations reach the Framework
          through the Protocol Adapter, which forwards the calls to the Dmt
          Admin service in a session. Protocol Adapters should authenticate
          the remote manager and set the principal in the session. This
          association will make the Dmt Admin service enforce the ACLs. This
          requires that the principal is equal to the server name.</para>

          <para>The Dmt Admin service provides a facility to send
          notifications to the remote manager with the Notification
          Service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Local Manager</emphasis> - A bundle which uses the
          Dmt Admin service to operate on the DMT: for example, a GUI
          application that allows the end user to change settings through the
          DMT.</para>

          <para>Although it is possible to manage some aspects of the system
          through the DMT, it can be easier for such applications to directly
          use the services that underlie the DMT; many of the management
          features available through the DMT are also available as services.
          These services shield the callers from the underlying details of the
          abstract, and sometimes hard to use DMT structure. As an example, it
          is more straightforward to use the Monitor Admin service than to
          operate upon the monitoring sub-tree. The local management
          application might listen to Dmt Events if it is interested in
          updates in the tree made by other entities, however, these events do
          not necessarily reflect the accurate state of the underlying
          services.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Actors</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.176in"
                       contentwidth="4.922in" fileref="actors.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>The DMT Admin Service</title>

    <para>The Dmt Admin service operates on the Device Management Tree of an
    OSGi-based device. The Dmt Admin API is loosely modeled after the OMA DM
    protocol: the operations for <code>Get</code>, <code>Replace</code>,
    <code>Add</code>, <code>Delete</code> and <code>Exec</code> are directly
    available. The Dmt Admin is a singleton service.</para>

    <para>Access to the DMT is session-based to allow for locking and
    transactionality. The sessions are, in principle, concurrent, but
    implementations that queue sessions can be compliant. The client indicates
    to the Dmt Admin service what kind of session is needed:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Exclusive Update Session</emphasis> - Two or more
        updating sessions cannot access the same part of the tree
        simultaneously. An updating session must acquire an exclusive lock on
        the sub-tree which blocks the creation of other sessions that want to
        operate on an overlapping sub-tree.</para>
      </listitem>

      <listitem>
        <para><emphasis>Multiple Readers Session</emphasis> - Any number of
        read-only sessions can run concurrently, but ongoing read-only
        sessions must block the creation of an updating session on an
        overlapping sub-tree.</para>
      </listitem>

      <listitem>
        <para><emphasis>Atomic Session</emphasis> - An atomic session is the
        same as an exclusive update session, except that the session can be
        rolled back at any moment, undoing all changes made so far in the
        session. The participants must accept the outcome: rollback or commit.
        There is no prepare phase. The lack of full two phase commit can lead
        to error situations which are described later in this document; see
        <xref linkend="i1724768"/>.</para>
      </listitem>
    </itemizedlist>

    <para>Although the DMT represents a persistent data store with
    transactional access and without size limitations, the notion of the DMT
    should not be confused with a general purpose database. The intended
    purpose of the DMT is to provide a <emphasis>dynamic view</emphasis> of
    the management state of the device; the DMT model and the Dmt Admin
    service are designed for this purpose.</para>
  </section>

  <section>
    <title>Manipulating the DMT</title>

    <section xml:id="i2275977">
      <title>The DMT Addressing URI</title>

      <para>The OMA DM limits URIs to the definition of a URI in <xref
      linkend="i1418110"/>. The <xref linkend="org.osgi.service.dmt.Uri"
      xrefstyle="hyperlink"/> utility classes handles nearly all escaping
      issues with a number of static methods. All URIs in any of the API
      methods can use the full Unicode character set. For example, the
      following URIs as used in Java code are valid URIs for the Dmt Admin
      service.</para>

      <programlisting>"./ACME © 2000/A/x"
"./ACME/Address/Street/9C, Avenue St. Drézéry"</programlisting>

      <para>This strategy has a number of consequences.</para>

      <itemizedlist>
        <listitem>
          <para>A solidus (<code>'/' \u002F</code>) collides with the use of
          the solidus as separator of the node names. Solidi must therefore be
          escaped using a reverse solidus (<code>'\' \u005C</code>). The
          reverse solidus must be escaped with a double reverse solidus
          sequence. The Dmt Admin service must ignore a reverse solidus when
          it is not followed by a solidus or reverse solidus. The solidus and
          reverse solidus must not be escaped using the <code>%00</code> like
          escaping defined for URIs. For example, a node that has the name of
          a MIME type could look like:</para>

          <programlisting>./OSGi/mime/application\/png</programlisting>

          <para>In Java, a reverse solidus must be escaped as well, therefore
          requiring double reverse solidi:</para>

          <programlisting>String a = "./OSGi/mime/application\\/png";</programlisting>

          <para>A literal reverse solidus would therefore require 4 reverse
          solidi in a Java string.</para>
        </listitem>

        <listitem>
          <para>The length of a node name is defined to be the length of the
          byte array that results from UTF-8 encoding a string.</para>
        </listitem>
      </itemizedlist>

      <para>The <xref linkend="org.osgi.service.dmt.Uri"
      xrefstyle="hyperlink"/> class provides an <xref
      linkend="org.osgi.service.dmt.Uri.encode-String-"
      xrefstyle="hyperlink"/> method to escape a string and a <xref
      linkend="org.osgi.service.dmt.Uri.decode-String-"
      xrefstyle="hyperlink"/> method to unescape a string. Though in general
      the Dmt Admin service implementations should not impose unnecessary
      constraints on the node name length, it is possible that an
      implementation runs out of space. In that case it must throw a <xref
      linkend="org.osgi.service.dmt.DmtException" xrefstyle="hyperlink"/>
      <xref linkend="org.osgi.service.dmt.DmtException.URI_TOO_LONG"
      xrefstyle="hyperlink"/>.</para>

      <para>Nodes are addressed by presenting a <emphasis>relative</emphasis>
      or <emphasis>absolute URI</emphasis> for the requested node. The URI is
      defined with the following grammar:</para>

      <programlisting>uri             ::= relative-uri | absolute-uri
absolute-uri    ::= './' relative-uri
relative-uri    ::= segment ( '/' segment )*
segment         ::= (~['/'])*</programlisting>

      <para>The <xref linkend="org.osgi.service.dmt.Uri"
      xrefstyle="hyperlink"/> <xref
      linkend="org.osgi.service.dmt.Uri.isAbsoluteUri-String-"
      xrefstyle="hyperlink"/> method makes it simple to find out if a URI is
      relative or absolute. Relative URIs require a base URI that is for
      example provided by the session, see <xref linkend="i2275981"/>.</para>

      <para>Each node name is appended to the previous ones using a solidus
      (<code>'/' \u002F</code>) as the separating character. The first node of
      an absolute URI must be the full stop (<code>'.' \u002E</code>). For
      example, to access the <code>Bach</code> leaf node in the
      <code>RingTones</code> interior node from <xref linkend="i1416892"
      xrefstyle="template:Figure %n on page %p"/>, the URI must be:</para>

      <programlisting>./Vendor/RingSignals/Bach</programlisting>

      <para>The URI must be given with the root of the management tree as the
      starting point. URIs used in the DMT must be treated and interpreted as
      <emphasis>case-sensitive</emphasis>. I.e.<code>./Vendor</code> and
      <code>./vendor</code> designate two different nodes. The following
      mandatory restrictions on URI syntax are intended to simplify the
      parsing of URIs.</para>

      <para>The full stop has no special meaning in a node name. That is,
      sequences like <code>..</code> do not imply parent node. The <xref
      linkend="org.osgi.service.dmt.Uri.isValidUri-String-"
      xrefstyle="hyperlink"/> method verifies that a URI fulfills all its
      obligations and is valid.</para>
    </section>

    <section xml:id="i2275981">
      <title>Locking and Sessions</title>

      <para>The Dmt Admin service is the main entry point into the DMT, its
      usage is to create sessions. A simple example is getting a session on a
      specific sub-tree. Such a session can be created with the <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-"
      xrefstyle="hyperlink"/> method. This method creates an updating session
      with an exclusive lock on the given sub-tree. The given sub-tree can be
      a single leaf node, if so desired.</para>

      <para>Each session has an ID associated with it which is unique to the
      machine and is never reused. This id is always greater than 0. The value
      -1 is reserved as place holder to indicate a situation has no session
      associated with it, for example an event generated from an underlying
      service. The URI argument addresses the sub-tree root. If
      <code>null</code>, it addresses the root of the DMT. All nodes can be
      reached from the root, so specifying a session root node is not strictly
      necessary but it permits certain optimizations in the
      implementations.</para>

      <para>If the default exclusive locking mode of a session is not
      adequate, it is possible to specify the locking mode with the <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-int-"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-String-int-"
      xrefstyle="hyperlink"/> method. These methods supports the following
      locking modes:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_SHARED"
          xrefstyle="hyperlink"/> - Creates a <emphasis>shared
          session</emphasis>. It is limited to read-only access to the given
          sub-tree, which means that multiple sessions are allowed to read the
          given sub-tree at the same time.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_EXCLUSIVE"
          xrefstyle="hyperlink"/> - Creates an <emphasis>exclusive
          session</emphasis>. The lock guarantees full read-write access to
          the tree. Such sessions, however, cannot share their sub-tree with
          any other session. This type of lock requires that the underlying
          implementation supports Read Write Data Sessions.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_ATOMIC"
          xrefstyle="hyperlink"/> - Creates an <emphasis>atomic
          session</emphasis> with an exclusive lock on the sub-tree, but with
          added transactionality. Operations on such a session must either
          succeed together or fail together. This type of lock requires that
          the underlying implementation supports Transactional Data Sessions.
          If the Dmt Admin service does not support transactions, then it must
          throw a Dmt Exception with the <xref
          linkend="org.osgi.service.dmt.DmtException.FEATURE_NOT_SUPPORTED"
          xrefstyle="hyperlink"/> code. If the session accesses data plugins
          that are not transactional in write mode, then the Dmt Admin service
          must throw a Dmt Exception with the <xref
          linkend="org.osgi.service.dmt.DmtException.TRANSACTION_ERROR"
          xrefstyle="hyperlink"/> code. That is, data plugins can participate
          in a atomic sessions as long as they only perform read
          operations.</para>
        </listitem>
      </itemizedlist>

      <para>The Dmt Admin service must lock the sub-tree in the requested mode
      before any operations are performed. If the requested sub-tree is not
      accessible, the <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-int-"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-String-int-"
      xrefstyle="hyperlink"/>, or <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-"
      xrefstyle="hyperlink"/> method must block until the sub-tree becomes
      available. The implementation can decide after an
      implementation-dependent period to throw a Dmt Exception with the <xref
      linkend="org.osgi.service.dmt.DmtException.SESSION_CREATION_TIMEOUT"
      xrefstyle="hyperlink"/> code.</para>

      <para>As a simplification, the Dmt Admin service is allowed to lock the
      entire tree irrespective of the given sub-tree. For performance reasons,
      implementations should provide more fine-grained locking when
      possible.</para>

      <para>Persisting the changes of a session works differently for
      exclusive and atomic sessions. Changes to the sub-tree in an atomic
      session are not persisted until the <xref
      linkend="org.osgi.service.dmt.DmtSession.commit--"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.service.dmt.DmtSession.close--"
      xrefstyle="hyperlink"/> method of the session is called. Changes since
      the last transaction point can be rolled back with the <xref
      linkend="org.osgi.service.dmt.DmtSession.rollback--"
      xrefstyle="hyperlink"/> method.</para>

      <para>The <xref linkend="org.osgi.service.dmt.DmtSession.commit--"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.dmt.DmtSession.rollback--"
      xrefstyle="hyperlink"/> methods can be called multiple times in a
      session; they do not close the session. The <code>open</code>, <xref
      linkend="org.osgi.service.dmt.DmtSession.commit--"
      xrefstyle="hyperlink"/>, and <xref
      linkend="org.osgi.service.dmt.DmtSession.rollback--"
      xrefstyle="hyperlink"/> methods all establish a <emphasis>transaction
      point</emphasis>. The rollback operation cannot roll back further than
      the last transaction point.</para>

      <para>Once a fatal error is encountered (as defined by the
      <code>DmtException</code> <xref
      linkend="org.osgi.service.dmt.DmtException.isFatal--"
      xrefstyle="hyperlink"/> method), all successful changes must be rolled
      back automatically to the last transaction point. Non-fatal errors do
      not rollback the session. Any error/exception in the <code>commit</code>
      or <code>rollback</code> methods invalidates and closes the session.
      This can happen if, for example, the mapping state of a plugin changes
      that has its plugin root inside the session's sub-tree.</para>

      <para>Changes in an exclusive session are persisted immediately after
      each separate operation. Errors do not roll back any changes made in
      such a session.</para>

      <para>Due to locking and transactional behavior, a session of any type
      must be closed once it is no longer used. Locks must always be released,
      even if the <xref linkend="org.osgi.service.dmt.DmtSession.close--"
      xrefstyle="hyperlink"/> method throws an exception.</para>

      <para>Once a session is closed no further operations are allowed and
      manipulation methods must throw a Dmt Illegal State Exception when
      called. Certain information methods like for example <xref
      linkend="org.osgi.service.dmt.DmtSession.getState--"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.dmt.DmtSession.getRootUri--"
      xrefstyle="hyperlink"/> can still be called for logging or diagnostic
      purposes. This is documented with the Dmt Session methods.</para>

      <para>The <xref linkend="org.osgi.service.dmt.DmtSession.close--"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.service.dmt.DmtSession.commit--"
      xrefstyle="hyperlink"/> method can be expected to fail even if all or
      some of the individual operations were successful. This failure can
      occur due to multi-node constraints defined by a specific
      implementation. The details of how an implementation specifies such
      constraints is outside the scope of this specification.</para>

      <para>Events in an atomic session must only be sent at commit
      time.</para>
    </section>

    <section>
      <title>Associating a Principal</title>

      <para>Protocol Adapters must use the <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-String-int-"
      xrefstyle="hyperlink"/> method which features the principal as the first
      parameter. The principal identifies the external entity on whose behalf
      the session is created. This server identification string is determined
      during the authentication process in a way specific to the management
      protocol.</para>

      <para>For example, the identity of the OMA DM server can be established
      during the handshake between the OMA DM agent and the server. In the
      simpler case of OMA CP protocol, which is a one-way protocol based on
      WAP Push, the identity of the principal can be a fixed value.</para>
    </section>

    <section>
      <title>Relative Addressing</title>

      <para>All DMT operation methods are found on the session object. Most of
      these methods accept a <emphasis>relative</emphasis> or
      <emphasis>absolute</emphasis> URI as their first parameter: for example,
      the method <xref
      linkend="org.osgi.service.dmt.DmtSession.isLeafNode-String-"
      xrefstyle="hyperlink"/>. This URI is absolute or relative to the
      sub-tree with which the session is associated. For example, if the
      session is opened on:</para>

      <programlisting>./Vendor</programlisting>

      <para>then the following URIs address the <code>Bach</code> ring
      tone:</para>

      <programlisting>RingTones/Bach
./Vendor/RingTones/Bach</programlisting>

      <para>Opening the session with a <code>null</code> URI is identical to
      opening the session at the root. But the absolute URI can be used to
      address the <code>Bach</code> ring tone as well as a relative
      URI.</para>

      <programlisting>./Vendor/RingTones/Bach
Vendor/RingTones/Bach</programlisting>

      <para>If the URI specified does not correspond to a legitimate node in
      the tree, a Dmt Exception must be thrown. The only exception to this
      rule is the <xref
      linkend="org.osgi.service.dmt.DmtSession.isNodeUri-String-"
      xrefstyle="hyperlink"/> method that can verify if a node is actually
      valid. The <xref
      linkend="org.osgi.service.dmt.DmtSession.getMetaNode-String-"
      xrefstyle="hyperlink"/> method must accept URIs to non-existing nodes if
      an applicable meta node is available; otherwise it must also throw a Dmt
      Exception.</para>
    </section>

    <section xml:id="i2070130">
      <title>Creating Nodes</title>

      <para>The methods that create interior nodes are:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.DmtSession.createInteriorNode-String-"
          xrefstyle="hyperlink"/> - Create a new interior node using the
          default meta data. If the principal does not have
          <code>Replace</code> access rights on the parent of the new node
          then the session must automatically set the ACL of the new node so
          that the creating server has <code>Add</code>, <code>Delete</code>
          and <code>Replace</code> rights on the new node.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.DmtSession.createInteriorNode-String-String-"
          xrefstyle="hyperlink"/> - Create a new interior node. The meta data
          for this new node is identified by the second argument, which is a
          URI <emphasis>identifying</emphasis> an OMA DM Device Description
          Framework (DDF) file, this does not have to be a valid location. It
          uses a format like <code>org.osgi/1.0/LogManagementObject</code>.
          This meta node must be consistent with any meta information from the
          parent node.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.DmtSession.createLeafNode-String-"
          xrefstyle="hyperlink"/> - Create a new leaf node with a default
          value.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.DmtSession.createLeafNode-String-DmtData-"
          xrefstyle="hyperlink"/> - Create a leaf node and assign a value to
          the leaf-node.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.DmtSession.createLeafNode-String-DmtData-String-"
          xrefstyle="hyperlink"/> - Create a leaf node and assign a value for
          the node. The last argument is the MIME type, which can be
          <code>null</code>.</para>
        </listitem>
      </itemizedlist>

      <para>For a node to be created, the following conditions must be
      fulfilled:</para>

      <itemizedlist>
        <listitem>
          <para>The URI of the new node has to be a valid URI.</para>
        </listitem>

        <listitem>
          <para>The principal of the Dmt Session, if present, must have ACL
          <code>Add</code> permission to add the node to the parent.
          Otherwise, the caller must have the necessary permission.</para>
        </listitem>

        <listitem>
          <para>All constraints of the meta node must be verified, including
          value constraints, name constraints, type constraints, and MIME type
          constraints. If any of the constraints fail, a Dmt Exception must be
          thrown with an appropriate code.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Node Properties</title>

      <para>A DMT node has a number of runtime properties that can be set
      through the session object. These properties are:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Title</emphasis> - (<code>String</code>) A human
          readable title for the object. The title is distinct from the node
          name. The title can be set with <xref
          linkend="org.osgi.service.dmt.DmtSession.setNodeTitle-String-String-"
          xrefstyle="hyperlink"/> and read with <xref
          linkend="org.osgi.service.dmt.DmtSession.getNodeTitle-String-"
          xrefstyle="hyperlink"/>. This specification does not define how this
          information is localized. This property is optional depending on the
          implementation that handles the node.</para>
        </listitem>

        <listitem>
          <para><emphasis>Type</emphasis> -(<code>String</code>) The MIME
          type, as defined in <xref linkend="i1662528"/>, of the node's value
          when it is a leaf node. The type of an interior node is a string
          identifying a DDF type. These types can be set with <xref
          linkend="org.osgi.service.dmt.DmtSession.setNodeType-String-String-"
          xrefstyle="hyperlink"/> and read with <xref
          linkend="org.osgi.service.dmt.DmtSession.getNodeType-String-"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Version</emphasis> - (<code>int</code>) Version
          number, which must start at 0, incremented after every modification
          (for both a leaf and an interior node) modulo 0x10000. Changes to
          the value or any of the properties (including ACLs), or
          adding/deleting nodes, are considered changes. The <xref
          linkend="org.osgi.service.dmt.DmtSession.getNodeVersion-String-"
          xrefstyle="hyperlink"/> method returns this version; the value is
          read-only. In certain cases, the underlying data structure does not
          support change notifications or makes it difficult to support
          versions. This property is optional depending on the node's
          implementation.</para>
        </listitem>

        <listitem>
          <para><emphasis>Size</emphasis> - (<code>int</code>) The size
          measured in bytes is read-only and can be read with <xref
          linkend="org.osgi.service.dmt.DmtSession.getNodeSize-String-"
          xrefstyle="hyperlink"/>. Not all nodes can accurately provide this
          information.</para>
        </listitem>

        <listitem>
          <para><emphasis>Time Stamp</emphasis> -(<code>Date</code>) Time of
          the last change in version. The <xref
          linkend="org.osgi.service.dmt.DmtSession.getNodeTimestamp-String-"
          xrefstyle="hyperlink"/> returns the time stamp. The value is read
          only. This property is optional depending on the node's
          implementation.</para>
        </listitem>

        <listitem>
          <para><emphasis>ACL</emphasis> - The Access Control List for this
          and descendant nodes. The property can be set with <xref
          linkend="org.osgi.service.dmt.DmtSession.setNodeAcl-String-Acl-"
          xrefstyle="hyperlink"/> and obtained with <xref
          linkend="org.osgi.service.dmt.DmtSession.getNodeAcl-String-"
          xrefstyle="hyperlink"/>.</para>
        </listitem>
      </itemizedlist>

      <para>If a plugin that does not implement an optional property is
      accessed, a Dmt Exception with the code <xref
      linkend="org.osgi.service.dmt.DmtException.FEATURE_NOT_SUPPORTED"
      xrefstyle="hyperlink"/> must be thrown.</para>
    </section>

    <section xml:id="i2538437">
      <title>Setting and Getting Data</title>

      <para>Values are represented as <code>DmtData</code> objects, which are
      immutable. The are acquired with the <xref
      linkend="org.osgi.service.dmt.DmtSession.getNodeValue-String-"
      xrefstyle="hyperlink"/> method and set with the <xref
      linkend="org.osgi.service.dmt.DmtSession.setNodeValue-String-DmtData-"
      xrefstyle="hyperlink"/> method.</para>

      <para><code>DmtData</code> objects are dynamically typed by an integer
      enumeration. In OMA DM, this integer is called the
      <emphasis>format</emphasis> of the data value. The format of the
      <code>DmtData</code> class is similar to the type of a variable in a
      programming language, but the word <emphasis>format</emphasis> is used
      here. The available data formats are listed in the following
      table.</para>

      <table pgwide="1">
        <title>Data Formats</title>

        <tgroup cols="6">
          <colspec colnum="1" colwidth="2.8*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="1*"/>

          <colspec colnum="4" colwidth="3*"/>

          <colspec colnum="5" colwidth="2*"/>

          <colspec colnum="6" colwidth="3*"/>

          <thead>
            <row>
              <entry>Format Type</entry>

              <entry>Java Type</entry>

              <entry>Format Name</entry>

              <entry>Constructor</entry>

              <entry>Get</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_BASE64"
              xrefstyle="hyperlink"/></entry>

              <entry><code>byte[]</code></entry>

              <entry><code>base64</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-byte---boolean-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getBase64--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Binary type that must be encoded with base 64, see
              <xref linkend="i1869240"/>.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_BINARY"
              xrefstyle="hyperlink"/></entry>

              <entry><code>byte[]</code></entry>

              <entry><code>binary</code></entry>

              <entry><code><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-byte---"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-byte---boolean-"
              xrefstyle="hyperlink"/></code></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getBinary--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para> A byte array. The <code>DmtData</code> object is
              created with the constructor. The byte array can only be
              acquired with the method.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_BOOLEAN"
              xrefstyle="hyperlink"/></entry>

              <entry><code>boolean</code></entry>

              <entry><code>boolean</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-boolean-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getBoolean--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Boolean. There are two constants for this
              type:</para><itemizedlist>
                  <listitem>
                    <para><xref
                    linkend="org.osgi.service.dmt.DmtData.FALSE_VALUE"
                    xrefstyle="hyperlink"/></para>
                  </listitem>

                  <listitem>
                    <para><xref
                    linkend="org.osgi.service.dmt.DmtData.TRUE_VALUE"
                    xrefstyle="hyperlink"/></para>
                  </listitem>
                </itemizedlist></entry>
            </row>

            <row>
              <entry><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_DATE"
              xrefstyle="hyperlink"/></entry>

              <entry><code>String</code></entry>

              <entry><code>date</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-String-int-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getString--"
              xrefstyle="hyperlink"/> </para><para><xref
              linkend="org.osgi.service.dmt.DmtData.getDate--"
              xrefstyle="hyperlink"/> </para></entry>

              <entry><para>A Date (no time). Syntax defined in <xref
              linkend="i2437549"/> as the <code>date</code>
              type.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_DATE_TIME"
              xrefstyle="hyperlink"/></entry>

              <entry><code>String</code></entry>

              <entry><code>dateTime</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-Date-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getDateTime--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>A <code>Date</code> object representing a point in
              time.</para></entry>
            </row>

            <row>
              <entry><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_FLOAT"
              xrefstyle="hyperlink"/></entry>

              <entry><code>float</code></entry>

              <entry><code>float</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-float-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getFloat--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Float</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_INTEGER"
              xrefstyle="hyperlink"/></entry>

              <entry><code>int</code></entry>

              <entry><code>integer</code></entry>

              <entry><xref linkend="org.osgi.service.dmt.DmtData.DmtData-int-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getInt--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Integer</para></entry>
            </row>

            <row>
              <entry><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_LONG"
              xrefstyle="hyperlink"/></entry>

              <entry><code>long</code></entry>

              <entry><code>long</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-long-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getLong--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Long</para></entry>
            </row>

            <row>
              <entry><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_NODE"
              xrefstyle="hyperlink"/></entry>

              <entry><code>Object</code></entry>

              <entry><code>NODE</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-Object-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getNode--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>A <code>DmtData</code> object can have a format of
              <xref linkend="org.osgi.service.dmt.DmtData.FORMAT_NODE"
              xrefstyle="hyperlink"/>. This value is returned from a
              <code>MetaNode</code> <xref
              linkend="org.osgi.service.dmt.MetaNode.getFormat--"
              xrefstyle="hyperlink"/> method if the node is an interior node
              or for a data value when the Plugin supports complex
              values.</para></entry>
            </row>

            <row>
              <entry><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_NULL"
              xrefstyle="hyperlink"/></entry>

              <entry/>

              <entry/>

              <entry/>

              <entry><para/></entry>

              <entry><para>No valid data is available. <code>DmtData</code>
              objects with this format cannot be constructed; the only
              instance is the <code>DmtData</code> <xref
              linkend="org.osgi.service.dmt.DmtData.NULL_VALUE"
              xrefstyle="hyperlink"/> constant.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_RAW_BINARY"
              xrefstyle="hyperlink"/></entry>

              <entry><code>byte[]</code></entry>

              <entry><code>&lt;custom&gt;</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-String-byte---"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getRawBinary--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>A raw binary format is always created with a format
              name. This format name allows the creator to define a
              proprietary format. The format name is available from the <xref
              linkend="org.osgi.service.dmt.DmtData.getFormatName--"
              xrefstyle="hyperlink"/> method, which has predefined values for
              the standard formats.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_RAW_STRING"
              xrefstyle="hyperlink"/></entry>

              <entry><code>String</code></entry>

              <entry><code>&lt;custom&gt;</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-String-String-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getRawString--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>A raw string format is always created with a format
              name. This format name allows the creator to define a
              proprietary format. The format name is available from the <xref
              linkend="org.osgi.service.dmt.DmtData.getFormatName--"
              xrefstyle="hyperlink"/> method, which has predefined values for
              the standard formats.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_STRING"
              xrefstyle="hyperlink"/></entry>

              <entry><code>String</code></entry>

              <entry><code>string</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-String-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getString--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>String</para></entry>
            </row>

            <row>
              <entry><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_TIME"
              xrefstyle="hyperlink"/></entry>

              <entry><code>String</code></entry>

              <entry><code>time</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-String-int-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getString--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Time of Day. Syntax defined in <xref
              linkend="i2437549"/> as the <code>time</code>
              type.</para></entry>
            </row>

            <row>
              <entry><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_XML"
              xrefstyle="hyperlink"/></entry>

              <entry><code>String</code></entry>

              <entry><code>xml</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtData.DmtData-String-int-"
              xrefstyle="hyperlink"/></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.getXml--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>A string containing an XML fragment. It can be
              obtained with. The validity of the XML must not be verified by
              the Dmt Admin service.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Complex Values</title>

      <para>The OMA DM model prescribes that only leaf nodes have primitive
      values. This model maps very well to remote managers. However, when a
      manager is written in Java and uses the Dmt Admin API to access the
      tree, there are often unnecessary conversions from a complex object, to
      leaf nodes, and back to a complex object. For example, an interior node
      could hold the current GPS position as an OSGi <code>Position</code>
      object, which consists of a longitude, latitude, altitude, speed, and
      direction. All these objects are <code>Measurement</code> objects which
      consist of value, error, and unit. Reading such a <code>Position</code>
      object through its leaf nodes only to make a new <code>Position</code>
      object is wasting resources. It is therefore that the Dmt Admin service
      also supports <emphasis>complex values</emphasis> as a supplementary
      facility.</para>

      <para>If a complex value is used then the leaves must also be accessible
      and represent the same semantics as the complex value. A manager unaware
      of complex values must work correctly by only using the leaf nodes.
      Setting or getting the complex value of an interior node must be
      identical to setting or getting the leaf nodes.</para>

      <para>Accessing a complex value requires <code>Get</code> access to the
      node and all its descendants. Setting a complex value requires
      <code>Replace</code> access to the interior node. Replacing a complex
      value must only generate a single Replace event.</para>

      <para>Trying to set or get a complex value on an interior node that does
      not support complex values must throw a Dmt Exception with the code
      <xref linkend="org.osgi.service.dmt.DmtException.FEATURE_NOT_SUPPORTED"
      xrefstyle="hyperlink"/>.</para>
    </section>

    <section>
      <title>Nodes and Types</title>

      <para>The node's type can be set with the <xref
      linkend="org.osgi.service.dmt.DmtSession.setNodeType-String-String-"
      xrefstyle="hyperlink"/> method and acquired with <xref
      linkend="org.osgi.service.dmt.DmtSession.getNodeType-String-"
      xrefstyle="hyperlink"/>. The namespaces for the types differ for
      interior and leaf nodes. A leaf node is typed with a MIME type and an
      interior node is typed with a DDF Document URI. However, in both cases
      the Dmt Admin service must not verify the syntax of the type
      name.</para>

      <para>The <xref
      linkend="org.osgi.service.dmt.DmtSession.createLeafNode-String-DmtData-String-"
      xrefstyle="hyperlink"/> method takes a MIME type as last argument that
      will type the leaf node. The MIME type reflects how the data of the node
      should be <emphasis>interpreted</emphasis>. For example, it is possible
      to store a GIF and a JPEG image in a <code>DmtData</code> object with a
      <code>FORMAT_BINARY</code> format. Both the GIF and the JPEG object
      share the same <emphasis>format</emphasis>, but will have MIME types of
      <code>image/jpg</code> and <code>image/gif</code> respectively. The Meta
      Node provides a list of possible MIME types.</para>

      <para>The <xref
      linkend="org.osgi.service.dmt.DmtSession.createInteriorNode-String-String-"
      xrefstyle="hyperlink"/> method takes a DDF Document URI as the last
      argument that will type the interior node. This specification defines
      the DDF Document URIs listed in the following table for interior nodes
      that have a particular meaning in this specification.</para>

      <table>
        <title>Standard Interior Node Types</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="2*"/>

          <colspec colnum="2" colwidth="3*"/>

          <thead>
            <row>
              <entry>Interior Node Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtConstants.DDF_SCAFFOLD"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Scaffold nodes are automatically generated nodes by
              the Dmt Admin service to provide the children node names so that
              Plugins are reachable from the root. See <xref
              linkend="i2931854"/>.</para></entry>
            </row>

            <row>
              <entry><xref linkend="org.osgi.service.dmt.DmtConstants.DDF_MAP"
              xrefstyle="hyperlink"/></entry>

              <entry><para><code>MAP</code> nodes define a <code>key</code>
              -&gt; <code>value</code> mapping construct using the node name
              (key) and the node value (value). See <xref
              linkend="i2837021"/>.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtConstants.DDF_LIST"
              xrefstyle="hyperlink"/></entry>

              <entry><para><code>LIST</code> nodes use the node name to
              maintain an index in a list. See <xref
              linkend="i2836847"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Deleting Nodes</title>

      <para>The <xref
      linkend="org.osgi.service.dmt.DmtSession.deleteNode-String-"
      xrefstyle="hyperlink"/> method on the session represents the Delete
      operation. It deletes the sub-tree of that node. This method is
      applicable to both leaf and interior nodes. Nodes can be deleted by the
      Dmt Admin service in any order. The root node of the session cannot be
      deleted.</para>

      <para>For example, given <xref linkend="i1647301"/>, deleting node
      <code>P</code> must delete the nodes <code>./P</code>, <code>./P/
      M</code>, <code>./P/M/X</code>, <code>./P/M/n2</code> and
      <code>./P/M/n3</code> in any order.</para>

      <figure xml:id="i1647301">
        <title>DMT node and deletion</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.586in"
                       contentwidth="5.011in" fileref="deleting-nodes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Copying Nodes</title>

      <para>The <xref
      linkend="org.osgi.service.dmt.DmtSession.copy-String-String-boolean-"
      xrefstyle="hyperlink"/> method on the <code>DmtSession</code> object
      represents the <code>Copy</code> operation. A node is completely copied
      to a new URI. It can be specified with a <code>boolean</code> if the
      whole sub-tree (<code>true</code>) or just the indicated node is
      copied.</para>

      <para>The ACLs must not be copied; the new access rights must be the
      same as if the caller had created the new nodes individually. This
      restriction means that the copied nodes inherit the access rights from
      the parent of the destination node, unless the calling principal does
      not have <code>Replace</code> rights for the parent. See <xref
      linkend="i2070130"/> for details.</para>
    </section>

    <section>
      <title>Renaming Nodes</title>

      <para>The <xref
      linkend="org.osgi.service.dmt.DmtSession.renameNode-String-String-"
      xrefstyle="hyperlink"/> method on the <code>DmtSession</code> object
      represents the <code>Rename</code> operation, which replaces the node
      name. It requires permission for the <code>Replace</code> operation. The
      root node for the current session can not be renamed.</para>
    </section>

    <section>
      <title>Execute</title>

      <para>The <xref
      linkend="org.osgi.service.dmt.DmtSession.execute-String-String-"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.dmt.DmtSession.execute-String-String-String-"
      xrefstyle="hyperlink"/> methods can <emphasis>execute</emphasis> a node.
      Executing a node is intended to be used when a problem is hard to model
      as a set of leaf nodes. This can be related to synchronization issues or
      data manipulation. The execute methods can provide a correlator for a
      notification and an opaque string that is forwarded to the implementer
      of the node.</para>

      <para>Execute operations can not take place in a read only session
      because simultaneous execution could make conflicting changes to the
      tree.</para>
    </section>

    <section>
      <title>Closing</title>

      <para>When all the changes have been made, the session must be closed by
      calling the <xref linkend="org.osgi.service.dmt.DmtSession.close--"
      xrefstyle="hyperlink"/> method on the session. The Dmt Admin service
      must then finalize, clean up, and release any locks. For atomic
      sessions, the Dmt Admin service must automatically commit any changes
      that were made since the last transaction point.</para>

      <para>A session times out and is invalidated after an extended period of
      inactivity. The exact length of this period is not specified, but is
      recommended to be at least 1 minute and at most 24 hours. All methods of
      an invalidated session must throw an Dmt Illegal State Exception after
      the session is invalidated.</para>

      <para>A session's state is one of the following: <xref
      linkend="org.osgi.service.dmt.DmtSession.STATE_CLOSED"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.service.dmt.DmtSession.STATE_INVALID"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.service.dmt.DmtSession.STATE_OPEN"
      xrefstyle="hyperlink"/>, as can be queried by the <xref
      linkend="org.osgi.service.dmt.DmtSession.getState--"
      xrefstyle="hyperlink"/> call. The invalid state is reached either after
      a fatal error case is encountered or after the session is timed out.
      When an atomic session is invalidated, it is automatically rolled back
      to the last transaction point of the session.</para>
    </section>
  </section>

  <section xml:id="i2538447">
    <title>Meta Data</title>

    <para>The <xref
    linkend="org.osgi.service.dmt.DmtSession.getMetaNode-String-"
    xrefstyle="hyperlink"/> method returns a <code>MetaNode</code> object for
    a given URI. This node is called the <emphasis>meta node</emphasis>. A
    meta node provides information about nodes.</para>

    <para>Any node can optionally have a meta node associated with it. The one
    or more nodes that are described by the meta nodes are called the meta
    node's <emphasis>related instances</emphasis>. A meta node can describe a
    singleton-related instance, or it can describe all the children of a given
    parent if it is a <emphasis>multi-node</emphasis>. That is to say, meta
    nodes can exist without an actual instance being present. In order to
    retrieve the meta node of a multi-node any name can be used.</para>

    <para>For example, if a new ring tone, <code>Grieg</code>, was created in
    <xref linkend="i1465151"/> it would be possible to get the Meta Node for
    <code>./Vendor/RingSignals/Grieg</code> before the node was created. This
    is usually the case for multi nodes. The model is depicted in <xref
    linkend="i1465151"/>.</para>

    <figure xml:id="i1465151">
      <title>Nodes and meta nodes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.719in"
                     contentwidth="6.248in" fileref="meta-nodes.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>A URI is generally associated with the same Meta Node. The <xref
    linkend="org.osgi.service.dmt.DmtSession.getMetaNode-String-"
    xrefstyle="hyperlink"/> should return the same meta node for the same URI
    except in the case of <xref linkend="i2931854"/>. As the ownership of
    scaffold nodes can change from the Dmt Admin service to the Parent Plugin
    service, or from a Parent Plugin to a Child Plugin, the Meta Node can
    change as well.</para>

    <para>The last segment of the URI to get a Meta Node can be any valid node
    name, for example, instead of <code>Grieg</code> it would have been
    possible to retrieve the same Meta Node with the name
    <code>./Vendor/RingSignals/0</code>,
    <code>./Vendor/RingSignals/anyName</code>,
    <code>./Vendor/RingSignals/&lt;&gt;</code>, etc.</para>

    <para>The actual meta data can come from two sources:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Dmt Admin</emphasis> - Each Dmt Admin service likely
        has a private meta data repository. This meta data is placed in the
        device in a proprietary way.</para>
      </listitem>

      <listitem>
        <para><emphasis>Plugins</emphasis> - Plugins can carry meta nodes and
        provide these to the Dmt Admin service by implementing the <xref
        linkend="org.osgi.service.dmt.spi.ReadableDataSession.getMetaNode-String---"
        xrefstyle="hyperlink"/> method. If a plugin returns a non-null value,
        the Dmt Admin service must use that value, possibly complemented by
        its own metadata for elements not provided by the plugin.</para>
      </listitem>
    </itemizedlist>

    <para>The <code>MetaNode</code> interface supports methods to retrieve
    read-only meta data. The following sections describes this meta-data in
    more detail.</para>

    <section xml:id="i2760251">
      <title>Operations</title>

      <para>The <xref linkend="org.osgi.service.dmt.MetaNode.can-int-"
      xrefstyle="hyperlink"/> method provide information as to whether the
      associated node can perform the given operation. This information is
      only about the capability; it can still be restricted in runtime by ACLs
      and permissions.</para>

      <para>For example, if the <code>can(MetaNode.CMD_EXECUTE)</code> method
      returns <code>true</code>, the target object supports the
      <code>Execute</code> operation. That is, calling the <xref
      linkend="org.osgi.service.dmt.DmtSession.execute-String-String-"
      xrefstyle="hyperlink"/> method with the target URI is possible.</para>

      <para>The <xref linkend="org.osgi.service.dmt.MetaNode.can-int-"
      xrefstyle="hyperlink"/> method can take the following constants as
      parameters:</para>

      <itemizedlist>
        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.CMD_ADD"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.CMD_DELETE"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.CMD_EXECUTE"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.CMD_GET"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.CMD_REPLACE"
          xrefstyle="hyperlink"/></para>
        </listitem>
      </itemizedlist>

      <para>For example:</para>

      <programlisting>void foo( DmtSession session, String nodeUri) {
    MetaNode    meta = session.getMetaNode(nodeUri);
  if ( meta !=null &amp;&amp; meta.<code>can(MetaNode.CMD_EXECUTE)</code> )
        session.execute(nodeUri,"foo" );
}</programlisting>
    </section>

    <section xml:id="i2965501">
      <title>Scope</title>

      <para>The scope is part of the meta information of a node. It provides
      information about what the life cycle role is of the node. The <xref
      linkend="org.osgi.service.dmt.MetaNode.getScope--"
      xrefstyle="hyperlink"/> method on the Meta Node provides this
      information. The value of the scope can be one of the following:</para>

      <itemizedlist>
        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.DYNAMIC"
          xrefstyle="hyperlink"/> - Dynamic nodes are intended to be created
          and deleted by a management system or an other controlling source.
          This does not imply that it actually is possible to add new nodes
          and delete nodes, the actions can still allow or deny this. However,
          in principle nodes that can be added or deleted have the <xref
          linkend="org.osgi.service.dmt.MetaNode.DYNAMIC"
          xrefstyle="hyperlink"/> scope. The <code>LIST</code> and
          <code>MAP</code> nodes, see <xref
          linkend="service.dmt.osgiobjectmodeling"/>, always have <xref
          linkend="org.osgi.service.dmt.MetaNode.DYNAMIC"
          xrefstyle="hyperlink"/> scope.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.PERMANENT"
          xrefstyle="hyperlink"/> - Permanent nodes represent an entity in the
          system. This can be a network interface, a device description, etc.
          Permanent nodes in general map to an object in an object oriented
          language. Despite their name, <xref
          linkend="org.osgi.service.dmt.MetaNode.PERMANENT"
          xrefstyle="hyperlink"/> nodes can appear and disappear, for example
          the plugging in of a USB device might create a new <xref
          linkend="org.osgi.service.dmt.MetaNode.PERMANENT"
          xrefstyle="hyperlink"/> node. Generally, the Plugin roots map to
          <xref linkend="org.osgi.service.dmt.MetaNode.PERMANENT"
          xrefstyle="hyperlink"/> nodes.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.AUTOMATIC"
          xrefstyle="hyperlink"/> - Automatic nodes map in general to nodes
          that are closely tied to the parent. They are similar to fields of
          an object in an object oriented language. They cannot be deleted or
          added.</para>
        </listitem>
      </itemizedlist>

      <para>For example, a node representing the Battery can never be deleted
      because it is an intrinsic part of the device; it will therefore be
      <xref linkend="org.osgi.service.dmt.MetaNode.PERMANENT"
      xrefstyle="hyperlink"/>. The <code>Level</code> and number of
      <code>ChargeCycle</code> nodes will be <xref
      linkend="org.osgi.service.dmt.MetaNode.AUTOMATIC"
      xrefstyle="hyperlink"/>. A new ring tone is dynamically created by a
      manager and is therefore <xref
      linkend="org.osgi.service.dmt.MetaNode.DYNAMIC"
      xrefstyle="hyperlink"/>.</para>
    </section>

    <section>
      <title>Description and Default</title>

      <itemizedlist>
        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.getDescription--"
          xrefstyle="hyperlink"/> - (<code>String</code>) A description of the
          node. Descriptions can be used in dialogs with end users: for
          example, a GUI application that allows the user to set the value of
          a node. Localization of these values is not defined.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.getDefault--"
          xrefstyle="hyperlink"/> - (<code>DmtData</code>) A default data
          value.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Validation</title>

      <para>The validation information allows the runtime system to verify
      constraints on the values; it also allows user interfaces to provide
      guidance.</para>

      <para>A node does not have to exist in the DMT in order to have meta
      data associated with it. Nodes may exist that have only partial meta
      data, or no metadata, associated with them. For each type of metadata,
      the default value to assume when it is omitted is described in <xref
      linkend="org.osgi.service.dmt.MetaNode" xrefstyle="hyperlink"/>.</para>
    </section>

    <section xml:id="i2955405">
      <title>Data Types</title>

      <para>A leaf node can be constrained to a certain format and one of a
      set of MIME types.</para>

      <itemizedlist>
        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.getFormat--"
          xrefstyle="hyperlink"/> - (<code>int</code>) The required type. This
          type is a logical OR of the supported formats.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.MetaNode.getRawFormatNames--"
          xrefstyle="hyperlink"/> - Return an array of possible raw format
          names. This is only applicable when the <xref
          linkend="org.osgi.service.dmt.MetaNode.getFormat--"
          xrefstyle="hyperlink"/> returns the <xref
          linkend="org.osgi.service.dmt.DmtData.FORMAT_RAW_BINARY"
          xrefstyle="hyperlink"/> or <xref
          linkend="org.osgi.service.dmt.DmtData.FORMAT_RAW_STRING"
          xrefstyle="hyperlink"/> formats. The method must return
          <code>null</code> otherwise.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.getMimeTypes--"
          xrefstyle="hyperlink"/> - (<code>String[]</code>) A list of MIME
          types for leaf nodes or DDF types for interior nodes. The Dmt Admin
          service must verify that the actual type of the node is part of this
          set.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i2760429">
      <title>Cardinality</title>

      <para>A meta node can constrain the number of
      <emphasis>siblings</emphasis> (i.e., not the number of children) of an
      interior or leaf node. This constraint can be used to verify that a node
      must not be deleted, because there should be at least one node left on
      that level ( <xref
      linkend="org.osgi.service.dmt.MetaNode.isZeroOccurrenceAllowed--"
      xrefstyle="hyperlink"/> ), or to verify that a node cannot be created,
      because there are already too many siblings ( <xref
      linkend="org.osgi.service.dmt.MetaNode.getMaxOccurrence--"
      xrefstyle="hyperlink"/> ).</para>

      <para>If the cardinality of a meta node is more than one, all siblings
      must share the same meta node to prevent an invalid situation. For
      example, if a node has two children that are described by different meta
      nodes, and any of the meta nodes has a cardinality &gt;1, that situation
      is invalid.</para>

      <para>For example, the <code>./Vendor/RingSignals/&lt;&gt;</code> meta
      node (where &lt;&gt; stands for any name) could specify that there
      should be between 0 and 12 ring signals.</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.MetaNode.getMaxOccurrence--"
          xrefstyle="hyperlink"/> - (<code>int</code>) A value greater than 0
          that specifies the maximum number of instances for this node.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.MetaNode.isZeroOccurrenceAllowed--"
          xrefstyle="hyperlink"/> - (<code>boolean</code>) Returns
          <code>true</code> if zero instances are allowed. If not, the last
          instance must not be deleted.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Matching</title>

      <para>The following methods provide validation capabilities for leaf
      nodes.</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.MetaNode.isValidValue-DmtData-"
          xrefstyle="hyperlink"/> - (<code>DmtData</code>) Verify that the
          given value is valid for this meta node.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.getValidValues--"
          xrefstyle="hyperlink"/> - (<code>DmtData[]</code>) A set of possible
          values for a node, or <code>null</code> otherwise. This can for
          example be used to give a user a set of options to choose
          from.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Numeric Ranges</title>

      <para>Numeric leaf nodes (format must be <xref
      linkend="org.osgi.service.dmt.DmtData.FORMAT_INTEGER"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.service.dmt.DmtData.FORMAT_LONG"
      xrefstyle="hyperlink"/>, or <xref
      linkend="org.osgi.service.dmt.DmtData.FORMAT_FLOAT"
      xrefstyle="hyperlink"/> ) can be checked for a minimum and maximum
      value.</para>

      <para>Minimum and maximum values are inclusive. That is, the range is
      <code>[getMin(),getMax()]</code>. For example, if the maximum value is 5
      and the minimum value is -5, then the range is [-5,5]. This means that
      valid values are -5,-4,-3,-2... 4, 5.</para>

      <itemizedlist>
        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.getMax--"
          xrefstyle="hyperlink"/> - (<code>double</code>) The value of the
          node must be less than or equal to this maximum value.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.getMin--"
          xrefstyle="hyperlink"/> - (<code>double</code>) The value of the
          node must be greater than or equal to this minimum value.</para>
        </listitem>
      </itemizedlist>

      <para>If no meta data is provided for the minimum and maximum values,
      the meta node must return the <code>Double.MIN_VALUE</code>, and
      <code>Double.MAX_VALUE</code> respectively.</para>
    </section>

    <section>
      <title>Name Validation</title>

      <para>The meta node provides the following name validation facilities
      for both leaf and interior nodes:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.MetaNode.isValidName-String-"
          xrefstyle="hyperlink"/> - (<code>String</code>) Verifies that the
          given name matches the rules for this meta node.</para>
        </listitem>

        <listitem>
          <para><xref linkend="org.osgi.service.dmt.MetaNode.getValidNames--"
          xrefstyle="hyperlink"/> - (<code>String[]</code>) An array of
          possible names. A valid name for this node must appear in this
          list.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>User Extensions</title>

      <para>The Meta Node provides an extension mechanism; each meta node can
      be associated with a number of properties. These properties are then
      interpreted in a proprietary way. The following methods are used for
      user extensions:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.MetaNode.getExtensionPropertyKeys--"
          xrefstyle="hyperlink"/> - Returns an array of key names that can be
          provided by this meta node.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.MetaNode.getExtensionProperty-String-"
          xrefstyle="hyperlink"/> - Returns the value of an extension
          property.</para>
        </listitem>
      </itemizedlist>

      <para>For example, a manufacturer could use a regular expression to
      validate the node names with the <xref
      linkend="org.osgi.service.dmt.MetaNode.isValidName-String-"
      xrefstyle="hyperlink"/> method. In a web based user interface it is
      interesting to provide validity checking in the browser, however, in
      such a case the regular expression string is required. This string could
      then be provided as a user extension under the key
      <code>x-acme-regex-javascript</code>.</para>
    </section>
  </section>

  <section>
    <title>Plugins</title>

    <para>The Plugins take the responsibility of handling DMT operations
    within certain sub-trees of the DMT. It is the responsibility of the Dmt
    Admin service to forward the operation requests to the appropriate plugin.
    The only exceptions are the ACL manipulation commands. ACLs must be
    enforced by the Dmt Admin service and never by the plugin. The model is
    depicted in <xref linkend="i2926111"/>.</para>

    <figure pgwide="1" xml:id="i2926111">
      <title>Device Management Tree example</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.024in"
                     contentwidth="5.011in" fileref="plugin-example.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Plugins are OSGi services. The Dmt Admin service must dynamically
    map and unmap the plugins, acting as node handler, as they are registered
    and unregistered. Service properties are used to specify the sub-tree that
    the plugin can manage as well as mount points that it provides to
    <emphasis>Child Plugins</emphasis>; plugins that manage part of the
    Plugin's sub-tree.</para>

    <para>For example, a plugin related to Configuration Admin handles the
    sub-tree which stores configuration data. This sub-tree could start at
    <code>./OSGi/Configuration</code>. When the client wants to add a new
    configuration object to the DMT, it must issue an <code>Add</code>
    operation to the <code>./OSGi/Configuration</code> node. The Dmt Admin
    service then forwards this operation to the configuration plugin. The
    plugin maps the request to one or more method calls on the Configuration
    Admin service. Such a plugin can be a simple proxy to the Configuration
    Admin service, so it can provide a DMT view of the configuration data
    store.</para>

    <para>There are two types of Dmt plugins: <emphasis>data
    plugins</emphasis> and <emphasis>exec plugins</emphasis>. A data plugin is
    responsible for handling the sub-tree retrieval, addition and deletion
    operations, and handling of meta data, while an exec plugin handles a node
    execution operation.</para>

    <section>
      <title>Data Sessions</title>

      <para>Data Plugins must participate in the Dmt Admin service sessions. A
      Data Plugin provider must therefore register a Data Plugin service. Such
      a service can create a session for the Dmt Admin service when the given
      sub-tree is accessed by a Dmt Session. If the associated Dmt Session is
      later closed, the Data Session will also be closed. Three types of
      sessions provide different capabilities. Data Plugins do not have to
      implement all session types; if they choose not to implement a session
      type they can return <code>null</code>.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Readable Data Session</emphasis> - Must always be
          supported. It provides the basic read-only access to the nodes and
          the <code>close()</code> method. The Dmt Admin service uses this
          session type when the lock mode is <xref
          linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_SHARED"
          xrefstyle="hyperlink"/> for the Dmt Session. Such a session is
          created with the plugin's <xref
          linkend="org.osgi.service.dmt.spi.DataPlugin.openReadOnlySession-String---DmtSession-"
          xrefstyle="hyperlink"/>, method which returns a <xref
          linkend="org.osgi.service.dmt.spi.ReadableDataSession"
          xrefstyle="hyperlink"/> object.</para>
        </listitem>

        <listitem>
          <para><emphasis>Read Write Data Session</emphasis> - Extends the
          Readable Data Session with capabilities to modify the DMT. This is
          used for Dmt Sessions that are opened with <xref
          linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_EXCLUSIVE"
          xrefstyle="hyperlink"/>. Such a session is created with the plugin's
          <xref
          linkend="org.osgi.service.dmt.spi.DataPlugin.openReadWriteSession-String---DmtSession-"
          xrefstyle="hyperlink"/> method, which returns a <xref
          linkend="org.osgi.service.dmt.spi.ReadWriteDataSession"
          xrefstyle="hyperlink"/> object.</para>
        </listitem>

        <listitem>
          <para><emphasis>Transactional Data Session</emphasis> - Extends the
          Read Write Data Session with commit and rollback methods so that
          this session can be used with transactions. It is used when the Dmt
          Session is opened with lock mode <xref
          linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_ATOMIC"
          xrefstyle="hyperlink"/>. Such a session is created with the plugin's
          <xref
          linkend="org.osgi.service.dmt.spi.DataPlugin.openAtomicSession-String---DmtSession-"
          xrefstyle="hyperlink"/> method, which returns a <xref
          linkend="org.osgi.service.dmt.spi.TransactionalDataSession"
          xrefstyle="hyperlink"/> object.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>URIs and Plugins</title>

      <para>The plugin Data Sessions do not use a simple string to identify a
      node as the Dmt Session does. Instead the URI parameter is a
      <code>String[]</code>. The members of this <code>String[]</code> are the
      different segments. The first node after the root is the second segment
      and the node name is the last segment. The different segments require
      escaping of the solidus (<code>'/' \u002F</code>) and reverse solidus
      (<code>'\' \u005C</code>).</para>

      <para>The reason to use <code>String[]</code> objects instead of the
      original string is to reduce the number times that the URI is parsed.
      The entry String objects, however, are still escaped. For example, the
      URI <code>./A/B/image\/jpg</code> gives the following
      <code>String[]</code>:</para>

      <programlisting>{ ".", "A", "B", "image\/jpg" }</programlisting>

      <para>A plugin can assume that the path is validated and can be used
      directly.</para>
    </section>

    <section>
      <title>Associating a sub-tree</title>

      <para>Each plugin is associated with one or more DMT sub-trees. The top
      node of a sub-tree is called the <emphasis>plugin root</emphasis>. The
      plugin root is defined by a service registration property. This property
      is different for exec plugins and data plugins:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.spi.DataPlugin.DATA_ROOT_URIS"
          xrefstyle="hyperlink"/> - (<code>String+</code>) A sequence of
          <emphasis>data URI</emphasis>, defining a plugin root for data
          plugins.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.spi.ExecPlugin.EXEC_ROOT_URIS"
          xrefstyle="hyperlink"/> - (<code>String+</code>) A sequence of
          <emphasis>exec URI</emphasis>, defining a plugin root for exec
          plugins.</para>
        </listitem>
      </itemizedlist>

      <para>If the Plugin modifies these service properties then the Dmt Admin
      service must reflect these changes as soon as possible. The reason for
      the different properties is to allow a single service to register both
      as a Data Plugin service as well as an Exec Plugin service.</para>

      <para>Data and Exec Plugins live in independent trees and can fully
      overlap. However, an Exec Plugin can only execute a node when the there
      exists a valid node at the corresponding node in the Data tree. That is,
      to be able to execute a node it is necessary that <xref
      linkend="org.osgi.service.dmt.DmtSession.isNodeUri-String-"
      xrefstyle="hyperlink"/> would return <code>true</code>.</para>

      <para>For example, a data plugin can register itself in its activator to
      handle the sub-tree <code>./Dev/Battery</code>:</para>

      <programlisting>public void start(BundleContext context) {
  Hashtable ht = new Hashtable();
  ht.put(Constants.SERVICE_PID, "com.acme.data.plugin");
  ht.put( DataPlugin.<code>DATA_ROOT_URIS</code>, "./Dev/Battery");
  context.registerService( 
        DataPlugin.class.getName(),
        new BatteryHandler(context);
        ht );
}</programlisting>

      <para>If this activator was executed, an access to
      <code>./Dev/Battery</code> must be forwarded by the Dmt Admin service to
      this plugin via one of the data session.</para>
    </section>

    <section>
      <title>Synchronization with Dmt Admin Service</title>

      <para>The Dmt Admin service can, in certain cases, detect that a node
      was changed without the plugin knowing about this change. For example,
      if the ACL is changed, the version and timestamp must be updated; these
      properties are maintained by the plugin. In these cases, the Dmt Admin
      service must open a <code>ReadableDataSession</code> and call <xref
      linkend="org.osgi.service.dmt.spi.ReadableDataSession.nodeChanged-String---"
      xrefstyle="hyperlink"/> method with the changed URI.</para>
    </section>

    <section>
      <title>Plugin Meta Data</title>

      <para>Plugins can provide meta data; meta data from the Plugin must take
      precedence over the meta data of the Dmt Admin service. If a plugin
      provides meta information, the Dmt Admin service must verify that an
      operation is compatible with the meta data of the given node.</para>

      <para>For example if the plugin reports in its meta data that the
      <code>./A</code> leaf node can only have the <code>text/plain</code>
      MIME type, the <xref
      linkend="org.osgi.service.dmt.DmtSession.createLeafNode-String-"
      xrefstyle="hyperlink"/> calls must not be forwarded to the Plugin if the
      third argument specifies any other MIME type. If this contract between
      the Dmt Admin service and the plugin is violated, the plugin should
      throw a Dmt Exception <xref
      linkend="org.osgi.service.dmt.DmtException.METADATA_MISMATCH"
      xrefstyle="hyperlink"/>.</para>
    </section>

    <section xml:id="i1724768">
      <title>Plugins and Transactions</title>

      <para>For the Dmt Admin service to be transactional, transactions must
      be supported by the data plugins. This support is not mandatory in this
      specification, and therefore the Dmt Admin service has no transactional
      guarantees for atomicity, consistency, isolation or durability. The
      <code>DmtAdmin</code> interface and the <code>DataPlugin</code> (or more
      specifically the data session) interfaces, however, are designed to
      support Data Plugin services that are transactional. Exec plugins need
      not be transaction-aware because the <code>execute</code> method does
      not provide transactional semantics, although it can be executed in an
      atomic transaction.</para>

      <para>Data Plugins do not have to support atomic sessions. When the Dmt
      Admin service creates a Transactional Data Session by calling <xref
      linkend="org.osgi.service.dmt.spi.DataPlugin.openAtomicSession-String---DmtSession-"
      xrefstyle="hyperlink"/> the Data Plugin is allowed to return
      <code>null</code>. In that case, the plugin does not support atomic
      sessions. The caller receives a Dmt Exception.</para>

      <para>Plugins must persist any changes immediately for Read Write Data
      Sessions. Transactional Data Sessions must delay changes until the <xref
      linkend="org.osgi.service.dmt.spi.TransactionalDataSession.commit--"
      xrefstyle="hyperlink"/> method is called, which can happen multiple
      times during a session. The opening of an atomic session and the <xref
      linkend="org.osgi.service.dmt.spi.TransactionalDataSession.commit--"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.dmt.spi.TransactionalDataSession.rollback--"
      xrefstyle="hyperlink"/> methods all establish a <emphasis>transaction
      point</emphasis>. Rollback can never go further back than the last
      transaction point.</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.spi.TransactionalDataSession.commit--"
          xrefstyle="hyperlink"/> - Commit any changes that were made to the
          DMT but not yet persisted. This method should not throw an Exception
          because other Plugins already could have persisted their data and
          can no longer roll it back. The <code>commit</code> method can be
          called multiple times in an open session, and if so, the commit must
          make persistent the changes since the last transaction point.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.spi.TransactionalDataSession.rollback--"
          xrefstyle="hyperlink"/> - Undo any changes made to the sub-tree
          since the last transaction point.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.spi.ReadableDataSession.close--"
          xrefstyle="hyperlink"/> - Clean up and release any locks. The Dmt
          Admin service must call the <code>commit</code> methods before the
          close method is called. A Plugin must not perform any persistency
          operations in the <code>close</code> method.</para>
        </listitem>
      </itemizedlist>

      <para>The <xref
      linkend="org.osgi.service.dmt.spi.TransactionalDataSession.commit--"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.service.dmt.spi.TransactionalDataSession.rollback--"
      xrefstyle="hyperlink"/>, and <xref
      linkend="org.osgi.service.dmt.spi.ReadableDataSession.close--"
      xrefstyle="hyperlink"/> plugin data session methods must all be called
      in reverse order of that in which Plugins joined the session.</para>

      <para>If a Plugin throws a fatal exception during an operation, the Dmt
      Session must be rolled back immediately, automatically rolling back all
      data plugins, as well as the plugins that threw the fatal Dmt Exception.
      The fatality of an Exception can be checked with the Dmt Exception <xref
      linkend="org.osgi.service.dmt.DmtException.isFatal--"
      xrefstyle="hyperlink"/> method.</para>

      <para>If a plugin throws a non-fatal exception in any method accessing
      the DMT, the current operation fails, but the session remains open for
      further commands. All errors due to invalid parameters (e.g.
      non-existing nodes, unrecognized values), all temporary errors, etc.
      should fall into this category.</para>

      <para>A rollback of the transaction can take place due to any
      irregularity during the session. For example:</para>

      <itemizedlist>
        <listitem>
          <para>A necessary Plugin is unregistered or unmapped</para>
        </listitem>

        <listitem>
          <para>A fatal exception is thrown while calling a plugin</para>
        </listitem>

        <listitem>
          <para>Critical data is not available</para>
        </listitem>

        <listitem>
          <para>An attempt is made to breach the security</para>
        </listitem>
      </itemizedlist>

      <para>Any Exception thrown during the course of a <xref
      linkend="org.osgi.service.dmt.spi.TransactionalDataSession.commit--"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.service.dmt.spi.TransactionalDataSession.rollback--"
      xrefstyle="hyperlink"/> method call is considered fatal, because the
      session can be in a half-committed state and is not safe for further
      use. The operation in progress should be continued with the remaining
      Plugins to achieve a <emphasis>best-effort</emphasis> solution in this
      limited transactional model. Once all plugins have been committed or
      rolled back, the Dmt Admin service must throw an exception, specifying
      the cause exception(s) thrown by the plugin(s), and should log an
      error.</para>
    </section>

    <section>
      <title>Side Effects</title>

      <para>Changing a node's value will have a side effect of changing the
      system. A plugin can also, however, cause state changes with a get
      operation. Sometimes the pattern to use a get operation to perform a
      state changing action can be quite convenient. The get operation,
      however, is defined to have no side effects. This definition is
      reflected in the session model, which allows the DMT to be shared among
      readers. Therefore, plugins should refrain from causing side effects for
      read-only operations.</para>
    </section>

    <section>
      <title>Copying</title>

      <para>Plugins do not have to support the copy operation. They can throw
      a Dmt Exception with a code <code>FEATURE_NOT_SUPPORTED</code>. In this
      case, the Dmt Admin service must do the copying node by node. For the
      clients of the Dmt Admin service, it therefore appears that the
      <code>copy</code> method is always supported.</para>
    </section>

    <section xml:id="i2931854">
      <title>Scaffold Nodes</title>

      <para>As Plugins can be mapped anywhere into the DMT it is possible that
      a part of the URI has no corresponding Plugin, such a plugin would not
      be <emphasis>reachable</emphasis> unless the intermediate nodes were
      provided. A program that would try to discover the DMT would not be able
      to find the registered Plugins as the intermediate nodes would not be
      discoverable.</para>

      <para>These intermediate nodes that will make all plugins reachable must
      therefore be provided by the Dmt Admin service, they are called the
      <emphasis>scaffold nodes</emphasis>. The only purpose of the scaffold
      nodes is to allow every node to be discovered when the DMT is traversed
      from the root down. Scaffold nodes are provided both for Data Plugins as
      well as Exec Plugins as well as for Child Plugins that are mounted
      inside a Parent Plugin, see <xref linkend="i2538366"/>. In <xref
      linkend="i2931861"/> the <code>Device</code> node is a scaffold node
      because there is no plugin associated with it. The Dmt Admin service
      must, however, provide the <code>Battery</code> node as child node of
      the <code>Device</code> node.</para>

      <figure xml:id="i2931861">
        <title>Scaffold Nodes</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.681in"
                       contentwidth="6.274in" fileref="scaffold-nodes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A scaffold node is always an interior node and has limited
      functionality, it must have a type of <xref
      linkend="org.osgi.service.dmt.DmtConstants.DDF_SCAFFOLD"
      xrefstyle="hyperlink"/>. It has no value, it is impossible to add or
      delete nodes to it, and the methods that are allowed for a scaffold node
      are specified in the following table.</para>

      <table>
        <title>Supported Scaffold Node Methods</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="2*"/>

          <thead>
            <row>
              <entry>Method</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.getNodeAcl-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Must inherit from the root node.</para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.getChildNodeNames-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Answer the child node names such that plugin's in
              the sub-tree are reachable.</para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.getMetaNode-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Provides the Meta Node defined in <xref
              linkend="service.dmt-scaffold.metanode.methods"/></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.getNodeSize-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Must throw a <xref
              linkend="org.osgi.service.dmt.DmtException"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.dmt.DmtException.COMMAND_NOT_ALLOWED"
              xrefstyle="hyperlink"/></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.getNodeTitle-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>null</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.getNodeTimestamp-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Time first created</para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.getNodeType-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtConstants.DDF_SCAFFOLD"
              xrefstyle="hyperlink"/></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.isNodeUri-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>true</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.isLeafNode-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>false</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.getNodeVersion-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Away returns <code>0</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtSession.copy-String-String-boolean-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Not allowed for a single scaffold node as
              <code>nodeUri</code>, if the <code>recurse</code> parameter is
              <code>false</code> the <xref
              linkend="org.osgi.service.dmt.DmtException"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.dmt.DmtException.COMMAND_NOT_ALLOWED"
              xrefstyle="hyperlink"/></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Any other operations must throw a <xref
      linkend="org.osgi.service.dmt.DmtException" xrefstyle="hyperlink"/> with
      error code <xref
      linkend="org.osgi.service.dmt.DmtException.COMMAND_NOT_ALLOWED"
      xrefstyle="hyperlink"/>. The scope of a scaffold node is always
      <code>PERMANENT</code>. Scaffold nodes must have a Meta Node provided by
      the Dmt Admin service. This Meta Node must act as defined in the
      following table.</para>

      <table xml:id="service.dmt-scaffold.metanode.methods">
        <title>Scaffold Meta Node Supported Methods</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="2*"/>

          <colspec colnum="2" colwidth="3*"/>

          <thead>
            <row>
              <entry>Method</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.can-int-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.CMD_GET"
              xrefstyle="hyperlink"/></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getDefault--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getDescription--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getFormat--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_NODE"
              xrefstyle="hyperlink"/></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getMax--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>Double.MAX_VALUE</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getMaxOccurrence--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>1</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getMimeTypes--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtConstants.DDF_SCAFFOLD"
              xrefstyle="hyperlink"/></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getMin--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>Double.MIN_VALUE</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getRawFormatNames--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>null</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getScope--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.PERMANENT"
              xrefstyle="hyperlink"/></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getValidNames--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getValidValues--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.isLeaf--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>false</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.isValidName-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>true</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.isValidValue-DmtData-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>false</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.isZeroOccurrenceAllowed--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>true</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If a Plugin is registered then it is possible that a scaffold node
      becomes a Data Plugin root node. In that case the node and the Meta Node
      must subsequently be provided by the Data Plugin and can thus become
      different. Scaffold nodes are virtual, there are therefore no events
      associated with the life cycle of a scaffold node.</para>

      <para>For example, there are three plugins registered:</para>

      <programlisting>URI         Plugin  Children
./A/B       P1      ba
./A/C       P2      ca
./A/X/Y     P3      ya,yb</programlisting>

      <para>In this example, node <code>B</code>, <code>C</code>, and
      <code>Y</code> are the plugin roots of the different plugins. As there
      is no plugin the manage node <code>A</code> and <code>X</code> these
      must be provided by the Dmt Admin service. In this example, the child
      names returned from each node are summarized as follows:</para>

      <programlisting>Node        Children        Provided by
.           { A }           Dmt Admin (scaffold node)
A           { X, C, B }     Dmt Admin (scaffold node)
B           { ba }          P1
C           { ca }          P2
X           { Y  }          Dmt Admin (scaffold node)
Y           { ya, yb }      P3</programlisting>

      <figure>
        <title>Example Scaffold Nodes</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.884in"
                       contentwidth="6.248in"
                       fileref="scaffold-nodes-example.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section xml:id="i2538366">
    <title>Sharing the DMT</title>

    <para>The Dmt Admin service provides a model to integrate the management
    of the myriad of components that make up an OSGi device. This integration
    is achieved by sharing a single namespace: the DMT. Sharing a single
    namespace requires rules to prevent conflicts and to resolve any conflicts
    when Plugins register with plugin roots that overlap. It also requires
    rules for the Dmt Admin service when nodes are accessed for which there is
    no Plugin available.</para>

    <para>This section defines the management of overlapping plugins through
    the <emphasis>mount points</emphasis>, places where a Parent Plugin can
    allow a Child Plugin to take over.</para>

    <section xml:id="i2955614">
      <title>Mount Points</title>

      <para>With multiple plugins the DMT is a <emphasis>shared
      namespace</emphasis>. Sharing requires rules to ensure that conflicts
      are avoided and when they occur, can be resolved in a consistent way.
      The most powerful and flexible model is to allow general overlapping.
      However, in practice this flexibility comes at the cost of ordering
      issues and therefore timing dependent results. A best practice is
      therefore to strictly control the points where the DMT can be extended
      for both Data and Exec Plugins.</para>

      <para>A <emphasis>mount point</emphasis> is such a place. A Dmt Admin
      service at start up provides virtual mount points anywhere in the DMT
      and provides scaffold nodes for any intermediate nodes between the root
      of the DMT and the Plugin's root URI. Once a Plugin is mounted it is
      free to use its sub-tree (the plugin root and any ancestors) as it sees
      fit. However, this implies that the Plugin must implement the full
      sub-tree. In reality, many object models use a pattern where the
      different levels in the object model map to different domains.</para>

      <para>For example, an Internet Gateway could have an object model where
      the general information, like the name, vendor, etc. is stored in the
      first level but any attached interfaces are stored in the sub-tree.
      However, It is highly unlikely that the code that handles the first
      level with the general information is actually capable of handling the
      details of, for example, the different network interfaces. It is
      actually likely that these network interfaces are dynamic. A Virtual
      Private Network (VPN) can add virtual network interfaces on demand. Such
      a could have the object model depicted in <xref
      linkend="i2473404"/>.</para>

      <figure xml:id="i2473404">
        <title>Data Modeling</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.745in"
                       contentwidth="6.199in" fileref="data-modeling.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Forcing these different levels to be implemented by the same
      plugin violates one of the primary rules of modularity:
      <emphasis>cohesion</emphasis>. Plugins forced to handle all aspects
      become complex and hard to maintain. A Plugin like the one managing the
      <code>Gateway</code> node could provide its own Plugin mechanism but
      that would force a lot of replication and is error prone. For this
      reason, the Dmt Admin service allows a Plugin to provide <emphasis>mount
      points</emphasis> inside its sub-tree. A Plugin can specify that it has
      mount points by registering a <xref
      linkend="org.osgi.service.dmt.spi.DataPlugin.MOUNT_POINTS"
      xrefstyle="hyperlink"/> service property (the constant is defined both
      in <xref linkend="org.osgi.service.dmt.spi.DataPlugin"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.dmt.spi.ExecPlugin" xrefstyle="hyperlink"/>
      but have the same constant value). The type of this property must be
      <code>String+</code>, each string specifies a mount point. Each mount
      point is specified as a URI that is relative from the plugin root. That
      is, when the plugin root is <code>./A/B</code> and the mount point is
      specified as <code>C</code> then the absolute URI of the mount point is
      <code>./A/B/C</code>.</para>

      <para>A Plugin that has mount points acts as a <emphasis>Parent
      Plugin</emphasis> to a number of <emphasis>Child Plugins</emphasis>. In
      the previous example, the LAN, VPN, and WAN nodes, can then be provided
      by separate Child Plugins even though the <code>Gateway/Name</code> node
      is provided by the Parent Plugin. In this case, the mount points are
      children of the <code>Interface</code> node.</para>

      <para>A mount point can be used by a number of child plugins. In the
      previous example, there was a Child Plugin for the LAN node, the VPN
      node, and the WAN node. This model has the implicit problem that it
      requires coordination to ensure that their names are unique. Such a
      coordination between independent parties is complicated and error prone.
      Its is therefore possible to force the Dmt Admin service to provide
      unique names for these nodes, see <xref linkend="i2489028"/>.</para>

      <para>A Parent Plugin is not responsible for any scaffolding nodes to
      make its Child Plugins reachable. However, Dmt Admin may assume that a
      Plugin Root node always exists and may not provide a scaffold node on
      the Plugin Root. A Plugin is recommended to always provide the Plugin
      Root node to make its Child Plugins reachable. When a Parent Plugin
      provides the nodes to its mount points, the nodes should be the correct
      interior nodes to make its Child Plugins reachable.</para>

      <para>For example, the following setup of plugins:</para>

      <programlisting>Plugin      Plugin Root     Mount Points
P1          ./A             X/B
P2          ./A/X/B     </programlisting>

      <para>This setup is depicted in <xref linkend="i2842643"/>.</para>

      <figure xml:id="i2842643">
        <title>Example Scaffold Nodes For Child Plugin</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.923in"
                       contentwidth="6.248in"
                       fileref="scaffold-nodes-child-plugin.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>If the child node names are requested for the <code>./A</code>
      node then the plugin P1 is asked for the child node names and must
      return the names [<code>f,g]</code>. However, if plugin P2 is mapped
      then the Dmt Admin service must add the scaffold node name that makes
      this plugin reachable from that level, the returned set must therefore
      be <code>[f, g, X]</code>.</para>
    </section>

    <section>
      <title>Parent Plugin</title>

      <para>If a Plugin is registered with mount points then it is a
      <emphasis>Parent Plugin</emphasis>. A Parent Plugin must register with a
      single plugin root URI, that is the <xref
      linkend="org.osgi.service.dmt.spi.DataPlugin.DATA_ROOT_URIS"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.service.dmt.spi.ExecPlugin.EXEC_ROOT_URIS"
      xrefstyle="hyperlink"/> service properties must contain only one
      element. A Parent Plugin is allowed to be a Data and Exec Plugin at the
      same time. If a Parent Plugin is registered with multiple plugin root
      URIs then the Dmt Admin service must log an error and ignore the
      registration of such a Parent Plugin. A Parent Plugin can in itself also
      be a Child Plugin.</para>

      <para>For example, a Plugin <code>P1</code> that has a plugin root of
      <code>./A/B</code> and provides a mount point at <code>./A/B/C</code>
      and <code>./A/B/E/F</code>. as depicted in <xref
      linkend="i2475982"/>.</para>

      <figure xml:id="i2475982">
        <title>Example Mount Points</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.942in"
                       contentwidth="6.297in"
                       fileref="mount-point-examples.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Registering such a Plugin would have to register the following
      service properties to allow the example configuration of the DMT:</para>

      <programlisting>dataRootUris    ./A/B
mountPoints     [ C, E/F ]</programlisting>
    </section>

    <section xml:id="i2489028">
      <title>Shared Mount Points</title>

      <para>Mount points can be shared between different Plugins. In the
      earlier example about the Gateway the <code>Interface</code> node
      contained a sub-tree of network interfaces. It is very likely in such an
      example that the Plugins for the VPN interface will be provided by a
      different organization than the WAN and LAN network interfaces. However,
      all these network interface plugins must share a single parent node, the
      <code>Interface</code> node, under which they would have to mount.
      Sharing therefore requires a prior agreement and a naming scheme.</para>

      <para>The naming scheme is defined by using the number sign (<code>'#'
      \u0023</code>) to specify a <emphasis>shared mount point</emphasis>. A
      plugin root that ends with the number sign, for example
      <code>./A/B/#</code>, indicates that it is willing to get any node under
      node <code>B</code>, leaving the naming of that node up to the Dmt Admin
      service. Shared mount points cannot overlap with normal mount points,
      the first one will become mapped and subsequent ones are in error, they
      are incompatible with each other. A Parent Plugin must specify a mount
      point explicitly as a shared mount point by using the number sign at the
      end of the mount point's relative URI.</para>

      <para>A plugin is compatible with other plugins if all other plugins
      specify a shared mount point to the same URI. It is compatible with its
      Parent Plugin if the child's plugin root and the mount point are either
      shared or not.</para>

      <para>The Dmt Admin service must provide a name for a plugin root that
      identifies a shared mount point such that every Plugin on that mount
      point has a unique integer name for that node level. The integer name
      must be &gt;= 1. The name must be convertible to an <code>int</code>
      with the static <code>Integer</code> <code>parseInt(String)</code>
      method.</para>

      <para>A management system in general requires permanent links to nodes.
      It is therefore necessary to choose the same integer every time a plugin
      is mapped to a shared mount point. A Child Plugin on a shared mount
      point must therefore get a permanent integer node name when it registers
      with a Persistent ID (PID). That is, it registers with the service
      property <code>service.pid</code>. The permanent link is then coupled to
      the PID and the bundle id since different bundles must be able to use
      the same PID. If a Plugin is registered with multiple PIDs then the
      first one must be used. Since permanent links can stay around for a long
      time implementations must strive to not reuse these integer
      names.</para>

      <para>If no <code>PID</code> is provided then the Dmt Admin service must
      choose a new number that has not been used yet nor matches any
      persistently stored names that are currently not registered.</para>

      <para>The Gateway example would require the following Plugin
      registrations:</para>

      <programlisting>Root URI                Mount Points    Plugin      Role
./Gateway               [Interface/#]   Gateway     Parent
./Gateway/Interface/#   []              WAN If.     Child
./Gateway/Interface/#   []              LAN If.     Child
./Gateway/Interface/#   []              VPN.1       Child</programlisting>

      <para>This setup is depicted in <xref linkend="i2673396"/>.</para>

      <figure xml:id="i2673396">
        <title>Mount Point Sharing</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.921in"
                       contentwidth="5.011in"
                       fileref="mount-point-sharing.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Meta Node for a Node on the level of the Mount Point can
      specify either an existing Plugin or it can refer to a non-existing
      node. If the node exists, the corresponding Plugin must provide the Meta
      Node. If the node does not exist, the Dmt Admin service must provide the
      Meta Node. Such a Meta Node must provide the responses as specified in
      <xref linkend="service.dmt-scaffold.metanode.methods"/>.</para>

      <table>
        <title>Shared Mount Point Meta Node Supported Methods</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="2*"/>

          <colspec colnum="2" colwidth="3*"/>

          <thead>
            <row>
              <entry>Method</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.can-int-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.CMD_GET"
              xrefstyle="hyperlink"/></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getDefault--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getDescription--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getFormat--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_NODE"
              xrefstyle="hyperlink"/></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getMax--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>Double.MAX_VALUE</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getMaxOccurrence--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>Integer.MAX_VALUE</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getMimeTypes--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getMin--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>Double.MIN_VALUE</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getRawFormatNames--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>null</code></para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getScope--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The scope will depend on the Parent</para></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getValidNames--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.getValidValues--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.isLeaf--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>false</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.isValidName-String-"
              xrefstyle="hyperlink"/></para></entry>

              <entry>name &gt;=1 &amp;&amp; name &lt;
              <code>Integer.MAX_VALUE</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.isValidValue-DmtData-"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>false</code></entry>
            </row>

            <row>
              <entry><para><xref
              linkend="org.osgi.service.dmt.MetaNode.isZeroOccurrenceAllowed--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><code>true</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>A URI can cross multiple mount points, shared and unshared. For
      example, if a network interface could be associated with a number of
      firewall rules then it is possible to register a URI on the designated
      network interface that refers to the Firewall rules. For the previous
      example, a Plugin could register a Firewall if the following
      registrations were done:</para>

      <programlisting>Root URI                    Mount Points    Plugin  Parent  Name    
./Gateway                   [Interface/#]   Gw              
./Gateway/Interface/#       [Fw/#]          WAN If. Gw      11
./Gateway/Interface/#       []              LAN If. Gw      33
./Gateway/Interface/#       []              VPN.1   Gw      42
./Gateway/Interface/11/Fw/# []              Fw.1    WAN If. 97</programlisting>

      <para>This example DMT is depicted in <xref linkend="i2673550"/>.</para>

      <figure xml:id="i2673550">
        <title>Mount Point Multiple Sharing</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.458in"
                       contentwidth="5.011in"
                       fileref="mount-point-multiple-sharing.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Mount Points are Excluded</title>

      <para>Mount nodes are logically not included in the sub-tree of a
      Plugin. The Dmt Admin service must never ask any information from/about
      a Mount Point node to its Parent Plugin. A Parent Plugin must also not
      return the name of a mount point in the list of child node names, the
      Mount Point and its subtree is logically excluded from the sub-tree. For
      the Dmt Admin service an unoccupied mount point is a node that does not
      exist. Its name, must only be discoverable if a Plugin has actually
      mounted the node. The Dmt Admin service must ensure that the names of
      the mounted Plugins are included for that level.</para>

      <para>In the case of shared mount points the Dmt Admin service must
      provide the children names of all registered Child Plugins that share
      that node level.</para>

      <para>For example, a Plugin <code>P1</code> registered with the plugin
      root of <code>./A/B</code>, having two leaf nodes <code>E</code>, and a
      mount point <code>C</code> must not return the name <code>C</code> when
      the child node names for node <code>B</code> are requested. This is
      depicted in <xref linkend="i2488828"/>. The Dmt Admin service must
      ensure that <code>C</code> is returned in the list of names when a
      Plugin is mounted on that node.</para>

      <figure xml:id="i2488828">
        <title>Example Exclusion</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.693in"
                       contentwidth="6.297in" fileref="exclusion-example.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="i2498904">
      <title>Mapping a Plugin</title>

      <para>A Plugin is not stand alone, its validity can depend on other
      Plugins. Invalid states make it possible that a Plugin is either
      <emphasis>mapped</emphasis> or <emphasis>unmapped</emphasis>. When a
      Plugin is mapped it is available in the DMT and when it is unmapped it
      is not available. Any registration, unregistration, or modification of
      its services properties of a Plugin can potentially alter the mapped
      state of any related Plugin. A plugin becomes
      <emphasis>eligible</emphasis> for mapping when it is registered.</para>

      <para>A plugin can have multiple roots. However, the mapping is
      described as if there is a single plugin root. Plugins with multiple
      roots must be treated as multiple plugins that can each independently be
      mapped or unmapped depending on the context.</para>

      <para>If no Parent Plugin is available, the Dmt Admin service must act
      as a virtual Parent Plugin that allows mount points anywhere in the tree
      where there is no mapped plugin yet.</para>

      <para>When a Plugin becomes eligible then the following assertions must
      be valid for that Plugin to become mapped:</para>

      <itemizedlist>
        <listitem>
          <para>If it has one or more mount points then</para>

          <itemizedlist>
            <listitem>
              <para>It must have at most one Data and/or Exec Root URI.</para>
            </listitem>

            <listitem>
              <para>None of its mount points must overlap.</para>
            </listitem>

            <listitem>
              <para>Any already mapped Child Plugins must be compatible with
              its mount points.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If no mount points are specified then there must be no Child
          Plugins already registered.</para>
        </listitem>

        <listitem>
          <para>The plugin root must be compatible with the corresponding
          parent's mount point. When a Parent Plugin is available, the plugin
          root must match exactly to the absolute URI of the parent's mount
          point.</para>
        </listitem>

        <listitem>
          <para>The plugin root must be compatible with any other plugins on
          that mount point.</para>
        </listitem>
      </itemizedlist>

      <para>If either of these assertions fail then the Dmt Admin service must
      log an error and ignore the registered Plugin, it must not become
      mapped. If, through the unregistration or modification of the service
      properties, the assertions can become valid then the Dmt Admin service
      must retry mapping the Plugin so that it can become available in the
      DMT. Any mappings and unmappings that affect nodes that are in the
      sub-tree of an active session must abort that session with a <xref
      linkend="org.osgi.service.dmt.DmtException.CONCURRENT_ACCESS"
      xrefstyle="hyperlink"/> exception.</para>

      <para>When there are errors in the configuration then the ordering will
      define which plugins are mapped or not. Since this is an error situation
      no ordering is defined between conflicting plugins.</para>

      <para>For example, a number of Plugins are registered in the given
      order:</para>

      <programlisting>Plugin Root     Children    Mount Points    Plugin
./A/B           E           C               P1
./A/B/C                                     P2
./A/B/D                                     P3</programlisting>

      <para>The first Plugin <code>P1</code> will be registered immediately
      without problems. It has only a single plugin root as required by the
      fact that it is a Parent Plugin (it has a mount point). There are no
      Child Plugins yet so it is impossible to have a violation of the mount
      points. As there is no Parent Plugin registered, the Dmt Admin service
      will map plugin <code>P1</code> and automatically provide the scaffold
      node <code>A</code>.</para>

      <para>When Plugin <code>P2</code> is registered its plugin root maps to
      a mount point in Plugin <code>P1</code>. As <code>P2</code> is not a
      Parent Plugin it is only necessary that it has no Child Plugins. As it
      has no Child Plugins, the mapping will succeed.</para>

      <para>Plugin <code>P3</code> cannot be mapped because the Parent Plugin
      is <code>P1</code> but <code>P1</code> does not provide a mount point
      for <code>P3</code>'s plugin root <code>./A/B/D</code>.</para>

      <para>If, at a later time P1 is unregistered then the Dmt Admin service
      must map plugin <code>P3</code> and leave plugin <code>P2</code> mapped.
      This sequence of action is depicted in <xref
      linkend="i2743587"/>.</para>

      <para>If plugin <code>P1</code> becomes registered again at a later time
      it can then in its turn not be mapped as there would be a child plugin
      (<code>P3</code>) that would not map to its mount point.</para>

      <figure xml:id="i2743587">
        <title>Plugin Activation</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.246in"
                       contentwidth="6.297in" fileref="plugin-activation.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="i2743673">
      <title>Mount Plugins</title>

      <para>In <xref linkend="i2498904"/> it is specified that a Plugin can be
      <emphasis>mapped</emphasis> or not. The mapped state of a Plugin can
      change depending on other plugins that are registered and unregistered.
      Plugins require in certain cases to know:</para>

      <itemizedlist>
        <listitem>
          <para>What is the name of their root node if they mount on a shared
          mount point.</para>
        </listitem>

        <listitem>
          <para>What is the mapping state of the Plugin.</para>
        </listitem>
      </itemizedlist>

      <para>To find out these details a Plugin can implement the <xref
      linkend="org.osgi.service.dmt.spi.MountPlugin" xrefstyle="hyperlink"/>
      interface; this is a mixin interface, it is not necessary to register it
      as <xref linkend="org.osgi.service.dmt.spi.MountPlugin"
      xrefstyle="hyperlink"/> service. The Dmt Admin service must do an
      <code>instanceof</code> operation on Data Plugin services and Exec
      Plugin services to detect if they are interested in the mount point
      information.</para>

      <para>The Mount Point interface is used by the Dmt Admin service to
      notify the Plugin when it becomes mapped and when it becomes unmapped.
      The Plugin will be informed about each plugin root separately.</para>

      <para>The Mount Plugin specifies the following methods that are called
      synchronously:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.spi.MountPlugin.mountPointAdded-MountPoint-"
          xrefstyle="hyperlink"/> - The Dmt Admin service must call this
          method after it has mapped a plugin root. From this point on the
          given mount point provides the actual path until the <xref
          linkend="org.osgi.service.dmt.spi.MountPlugin.mountPointRemoved-MountPoint-"
          xrefstyle="hyperlink"/> is called with an equal object. The given
          Mount Point can be used to post events.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.spi.MountPlugin.mountPointRemoved-MountPoint-"
          xrefstyle="hyperlink"/> - The Dmt Admin service must call this
          method after it has unmapped the given mount point. This method must
          always be called when a plugin root is unmapped, even if this is
          caused by the unregistration of the plugin.</para>
        </listitem>
      </itemizedlist>

      <para>As the mapping and unmapping of a plugin root can happen any
      moment in time a Plugin that implements the Mount Plugin interface must
      be prepared to handle these events at any time on any thread.</para>

      <para>The <xref linkend="org.osgi.service.dmt.spi.MountPoint"
      xrefstyle="hyperlink"/> interface has two separate
      responsibilities:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Path</emphasis> - The path that this Mount Point is
          associated with. This path is a plugin root of the plugin. This path
          is identical to the Plugin's root except when it is mounted on a
          shared mount point; in that case the URI ends in the name chosen by
          the Dmt Admin service. The <xref
          linkend="org.osgi.service.dmt.spi.MountPoint.getMountPath--"
          xrefstyle="hyperlink"/> method provides the path.</para>
        </listitem>

        <listitem>
          <para><emphasis>Events</emphasis> - Post events about the given
          sub-tree that signal internal changes that occur outside a Dmt
          Session. The Dmt Admin service must treat these events as they were
          originated from modifications to the DMT. That is, they need to be
          forwarded to the Event Admin as well as the Dmt Listeners. For this
          purpose there are the <xref
          linkend="org.osgi.service.dmt.spi.MountPoint.postEvent-String-String---Dictionary-"
          xrefstyle="hyperlink"/> and <xref
          linkend="org.osgi.service.dmt.spi.MountPoint.postEvent-String-String---String---Dictionary-"
          xrefstyle="hyperlink"/> methods.</para>
        </listitem>
      </itemizedlist>

      <para>For example, a Data Plugin monitoring one of the batteries
      registers with the following service properties:</para>

      <programlisting>dataRootURIs                "./Device/Battery/#"</programlisting>

      <para>The <code>Device</code> node is from a Parent Plugin that provided
      the shared mount point. The Battery Plugin implements the <xref
      linkend="org.osgi.service.dmt.spi.MountPlugin" xrefstyle="hyperlink"/>
      interface so it gets called back when it is mapped. This will cause the
      Dmt Admin service to call the <xref
      linkend="org.osgi.service.dmt.spi.MountPlugin.mountPointAdded-MountPoint-"
      xrefstyle="hyperlink"/> method on the plugin. In this case, it will get
      just one mount point, the mount point for its plugin root. If the Dmt
      Admin service would have assigned the Battery Plugin number 101 then the
      <xref linkend="org.osgi.service.dmt.spi.MountPoint.getMountPath--"
      xrefstyle="hyperlink"/> would return:</para>

      <programlisting>[ ".", "Device", "Battery", "101" ]</programlisting>

      <para>As the Plugin monitors the charge state of the battery it can
      detect a significant change. In that case it must send an event to
      notify any observers. The following code shows how this could be
      done:</para>

      <programlisting>@Component( properties="dataRootURIs=./Device/Battery/#",
                provide=DataPlugin.class)
public class Battery implements DataPlugin, MountPlugin {
    Timer          timer;
    volatile float charge;
    TimerTask      task;

    public void mountPointsAdded(final MountPoint[] mountPoints){
        task = new TimerTask() {
            public void run() {
                float next = measure();
                if (Math.abs(charge - next) &gt; 0.2) {
                    charge = next;
                    mountPoints[0].postEvent(DmtConstants.EVENT_TOPIC_REPLACED,
                        new String[] { "Charge" }, null);
                }
            }
        };
        timer.schedule(task, 1000);
    }

    public void mountPointsRemoved(MountPoint[] mountPoints){
            task.cancel();
            task = null;
    }
    ... // Other methods
}</programlisting>
    </section>
  </section>

  <section>
    <title>Access Control Lists</title>

    <para>Each node in the DMT can be protected with an <emphasis>access
    control list</emphasis>, or <emphasis>ACL</emphasis>. An ACL is a list of
    associations between <emphasis>Principal</emphasis> and
    <emphasis>Operation</emphasis>:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Principal</emphasis> - The identity that is authorized
        to use the associated operations. Special principal is the wildcard
        (<code>'*' \u002A</code>); the operations granted to this principal
        are called the <emphasis>global permissions</emphasis>. The global
        permissions are available to all principals.</para>
      </listitem>

      <listitem>
        <para><emphasis>Operation</emphasis> - A list of operations:
        <code>ADD, DELETE, GET, REPLACE, EXECUTE</code>.</para>
      </listitem>
    </itemizedlist>

    <para>DMT ACLs are defined as strings with an internal syntax in <xref
    linkend="i2165260"/>. Instances of the ACL class can be created by
    supplying a valid OMA DM ACL string as its parameter. The syntax of the
    ACL is presented here in shortened form for convenience:</para>

    <programlisting>acl         ::= ( acl-entry ( '&amp;' acl-entry)* )
acl-entry   ::= command '=' ( principals | '*' )
principals  ::= principal ( '+' principal )*
principal   ::= ~['=' '&amp;' '*' '+' '\t' '\n' '\r']+</programlisting>

    <para>The principal name should only use printable characters according to
    the OMA DM specification.</para>

    <programlisting>command     ::= 'Add' | 'Delete' | 'Exec'| 'Get' | 'Replace'</programlisting>

    <para>White space between tokens is not allowed.</para>

    <para>Examples:</para>

    <programlisting>Add=*&amp;Replace=*&amp;Get=*

Add=www.sonera.fi-8765&amp;Delete=www.sonera.fi-8765&amp; «
Replace=www.sonera.fi-8765+321_ibm.com&amp;Get=*</programlisting>

    <para>The <xref linkend="org.osgi.service.dmt.Acl.Acl-String-"
    xrefstyle="hyperlink"/> constructor can be used to construct an ACL from
    an ACL string. The <xref linkend="org.osgi.service.dmt.Acl.toString--"
    xrefstyle="hyperlink"/> method returns a <code>String</code> object that
    is formatted in the specified form, also called the canonical form. In
    this form, the principals must be sorted alphabetically and the order of
    the commands is:</para>

    <programlisting> ADD,   DELETE,   EXEC,   GET,   REPLACE</programlisting>

    <para>The <code>Acl</code> class is immutable, meaning that a
    <code>Acl</code> object can be treated like a string, and that the object
    cannot be changed after it has been created.</para>

    <para>ACLs must only be verified by the Dmt Admin service when the session
    has an associated principal.</para>

    <para>ACLs are properties of nodes. If an ACL is <emphasis>not set
    </emphasis>(i.e. contains no commands nor principals), the
    <emphasis>effective</emphasis> ACL of that node must be the ACL of its
    first ancestor that has a non-empty ACL. This effective ACL can be
    acquired with the <xref
    linkend="org.osgi.service.dmt.DmtSession.getEffectiveNodeAcl-String-"
    xrefstyle="hyperlink"/> method. The root node of DMT must always have an
    ACL associated with it. If this ACL is not explicitly set, it should be
    set to <code>Add=*&amp;Get=*&amp;Replace=*</code>.</para>

    <para>This effect is shown in <xref linkend="i1547055"/>. This diagram
    shows the ACLs set on a node and their effect (which is shown by the
    shaded rectangles). Any principal can get the value of <code>p</code>,
    <code>q</code> and <code>r</code>, but they cannot replace, add or delete
    the node. Node <code>t</code> can only be read and replaced by principal
    <code>S1</code>.</para>

    <para>Node <code>X</code> is fully accessible to any authenticated
    principal because the root node specifies that all principals have
    <code>Get</code>, <code>Add</code> and <code>Replace</code> access
    (*-&gt;G,A,R).</para>

    <figure xml:id="i1547055">
      <title>ACL inheritance</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.471in"
                     contentwidth="5.011in" fileref="acl-inheritance.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The definition and example demonstrate the access rights to the
    properties of a node, which includes the value.</para>

    <para>Changing the ACL property itself has different rules. If a principal
    has <code>Replace</code> access to an interior node, the principal is
    permitted to change its own ACL property <emphasis>and</emphasis> the ACL
    properties of all its child nodes. <code>Replace</code> access on a leaf
    node does not allow changing the ACL property itself.</para>

    <para>In the previous example, only principal S1 is authorized to change
    the ACL of node B because it has <code>Replace</code> permission on node
    <code>B</code>'s parent node <code>A</code>.</para>

    <figure xml:id="i1551391">
      <title>ACLs for the ACL property</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.529in"
                     contentwidth="5.011in"
                     fileref="acls-for-acl-property.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para><xref linkend="i1551391"/> demonstrates the effect of this rule with
    an example. Server S1 can change the ACL properties of all interior nodes.
    A more detailed analysis:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Root</emphasis> - The root allows all authenticated
        principals to access it. The root is an interior node so the
        <code>Replace</code> permission permits the change of the ACL
        property.</para>
      </listitem>

      <listitem>
        <para><emphasis>Node A</emphasis> - Server S1 has <code>Replace</code>
        permission and node A is an interior node so principal S1 can modify
        the ACL.</para>
      </listitem>

      <listitem>
        <para><emphasis>Node B</emphasis> - Server S1 has no
        <code>Replace</code> permission for node B, but the parent node A of
        node B grants principal S1 <code>Replace</code> permission, and S1 is
        therefore permitted to change the ACL.</para>
      </listitem>

      <listitem>
        <para><emphasis>Node t</emphasis> - Server <code>S1</code> must not be
        allowed to change the ACL of node <code>t</code>, despite the fact
        that it has <code>Replace</code> permission on node <code>t</code>.
        For leaf nodes, permission to change an ACL is defined by the
        <code>Replace</code> permission in the parent node's ACL. This parent,
        node B, has no such permission set and thus, access is denied.</para>
      </listitem>
    </itemizedlist>

    <para>The following methods provide access to the ACL property of the
    node.</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.DmtSession.getNodeAcl-String-"
        xrefstyle="hyperlink"/> - Return the ACL for the given node, this
        method must not take any ACL inheritance into account. The ACL may be
        <code>null</code> if no ACL is set.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.DmtSession.getEffectiveNodeAcl-String-"
        xrefstyle="hyperlink"/> - Return the effective ACL for the given node,
        taking any inheritance into account.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.DmtSession.setNodeAcl-String-Acl-"
        xrefstyle="hyperlink"/> - Set the node's ACL. The ACL can be
        <code>null</code>, in which case the effective permission must be
        derived from an ancestor. The Dmt Admin service must call <xref
        linkend="org.osgi.service.dmt.spi.ReadableDataSession.nodeChanged-String---"
        xrefstyle="hyperlink"/> on the data session with the given plugin to
        let the plugin update any timestamps and versions.</para>
      </listitem>
    </itemizedlist>

    <para>The <code>Acl</code> class maintains the permissions for a given
    principal in a bit mask. The following permission masks are defined as
    constants in the <code>Acl</code> class:</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.service.dmt.Acl.ADD"
        xrefstyle="hyperlink"/></para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.service.dmt.Acl.DELETE"
        xrefstyle="hyperlink"/></para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.service.dmt.Acl.EXEC"
        xrefstyle="hyperlink"/></para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.service.dmt.Acl.GET"
        xrefstyle="hyperlink"/></para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.service.dmt.Acl.REPLACE"
        xrefstyle="hyperlink"/></para>
      </listitem>
    </itemizedlist>

    <para>The class features methods for getting permissions for given
    principals. A number of methods allow an existing ACL to be modified while
    creating a new ACL.</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.Acl.addPermission-String-int-"
        xrefstyle="hyperlink"/> - Return a new <code>Acl</code> object where
        the given permissions have been added to permissions of the given
        principal.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.Acl.deletePermission-String-int-"
        xrefstyle="hyperlink"/> - Return a new <code>Acl</code> object where
        the given permissions have been removed from the permissions of the
        given principal.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.Acl.setPermission-String-int-"
        xrefstyle="hyperlink"/> - Return a new <code>Acl</code> object where
        the permissions of the given principal are overwritten with the given
        permissions.</para>
      </listitem>
    </itemizedlist>

    <para>Information from a given ACL can be retrieved with:</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.service.dmt.Acl.getPermissions-String-"
        xrefstyle="hyperlink"/> - (<code>int</code>) Return the combined
        permission mask for this principal.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.service.dmt.Acl.getPrincipals--"
        xrefstyle="hyperlink"/> - (<code>String[]</code>) Return a list of
        principals (<code>String</code> objects) that have been granted
        permissions for this node.</para>
      </listitem>
    </itemizedlist>

    <para>Additionally, the <xref
    linkend="org.osgi.service.dmt.Acl.isPermitted-String-int-"
    xrefstyle="hyperlink"/> method verifies if the given ACL authorizes the
    given permission mask. The method returns <code>true</code> if all
    commands in the mask are allowed by the ACL.</para>

    <para>For example:</para>

    <programlisting>    Acl acl = new Acl("Get=S1&amp;Replace=S1");

    if ( acl.isPermitted("S1", Acl.GET+Acl.REPLACE ))
        ... // will execute

    if ( acl.isPermitted(
        "S1", Acl.GET+Acl.REPLACE+Acl.ADD ))
        ... // will NOT execute</programlisting>

    <section>
      <title>Global Permissions</title>

      <para>Global permissions are indicated with the <code>'*'</code> and the
      given permissions apply to all principals. Processing the global
      permissions, however, has a number of non-obvious side effects:</para>

      <itemizedlist>
        <listitem>
          <para>Global permissions can be retrieved and manipulated using the
          special '*' principal: all methods of the <code>Acl</code> class
          that have a principal parameter also accept this principal.</para>
        </listitem>

        <listitem>
          <para>Global permissions are automatically granted to all specific
          principals. That is, the result of the <code>getPermissions</code>
          or <code>isPermitted</code> methods will be based on the OR of the
          global permissions and the principal-specific permissions.</para>
        </listitem>

        <listitem>
          <para>If a global permission is revoked, it is revoked from all
          specific principals, even if the specific principals already had
          that permission before it was made global.</para>
        </listitem>

        <listitem>
          <para>None of the global permissions can be revoked from a specific
          principal. The OMA DM ACL format does not handle exceptions, which
          must be enforced by the <code>deletePermission</code> and
          <code>setPermission</code> methods.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Ghost ACLs</title>

      <para>The ACLs are fully maintained by the Dmt Admin service and
      enforced when the session has an associated principal. A plugin must be
      completely unaware of any ACLs. The Dmt Admin service must synchronize
      the ACLs with any change in the DMT that is made through its service
      interface. For example, if a node is deleted through the Dmt Admin
      service, it must also delete an associated ACL.</para>

      <para>The DMT nodes, however, are mapped to plugins, and plugins can
      delete nodes outside the scope of the Dmt Admin service.</para>

      <para>As an example, consider a configuration record which is mapped to
      a DMT node that has an ACL. If the configuration record is deleted using
      the Configuration Admin service, the data disappears, but the ACL entry
      in the Dmt Admin service remains. If the configuration dictionary is
      recreated with the same PID, it will get the old ACL, which is likely
      not the intended behavior.</para>

      <para>This specification does not specify a solution to solve this
      problem. Suggestions to solve this problem are:</para>

      <itemizedlist>
        <listitem>
          <para>Use a proprietary callback mechanism from the underlying
          representation to notify the Dmt Admin service to clean up the
          related ACLs.</para>
        </listitem>

        <listitem>
          <para>Implement the services on top of the DMT. For example, the
          Configuration Admin service could use a plugin that provides general
          data storage service.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="i2753759">
    <title>Notifications</title>

    <para>In certain cases it is necessary for some code on the device to
    alert a remote management server or to initiate a session; this process is
    called sending a notification or an <emphasis>alert</emphasis>. Some
    examples:</para>

    <itemizedlist>
      <listitem>
        <para>A Plugin that must send the result of an asynchronous
        <code>EXEC</code> operation.</para>
      </listitem>

      <listitem>
        <para>Sending a request to the server to start a management
        session.</para>
      </listitem>

      <listitem>
        <para>Notifying the server of completion of a software update
        operation.</para>
      </listitem>
    </itemizedlist>

    <para>Notifications can be sent to a management server using the <xref
    linkend="org.osgi.service.dmt.notification.NotificationService.sendNotification-String-int-String-AlertItem---"
    xrefstyle="hyperlink"/> method on the Notification Service. This method is
    on the Notification Service and not on the session, because the session
    can already be closed when the need for an alert arises. If an alert is
    related to a session, the session can provide the required principal, even
    after it is closed.</para>

    <para>The remote server is alerted with one or more <xref
    linkend="org.osgi.service.dmt.notification.AlertItem"
    xrefstyle="hyperlink"/> objects. The <code>AlertItem</code> class
    describes details of the alert. An alert code is an alert type identifier,
    usually requiring specifically formatted <code>AlertItem</code>
    objects.</para>

    <para>The data syntax and semantics vary widely between various alerts,
    and so does the optionality of particular parameters of an alert item. If
    an item, such as source or type, is not defined, the corresponding getter
    method must return <code>null</code>.</para>

    <para>The <xref linkend="org.osgi.service.dmt.notification.AlertItem"
    xrefstyle="hyperlink"/> class contains the following items. The value of
    these items must be defined in an alert definition:</para>

    <itemizedlist>
      <listitem>
        <para><code>source</code> - (<code>String</code>) The URI of a node
        that is related to this request. This parameter can be
        <code>null</code>.</para>
      </listitem>

      <listitem>
        <para><code>type</code> - (<code>String</code>) The type of the item.
        For example, <code>x-oma-application:syncml.samplealert</code> in the
        Generic Alert example.</para>
      </listitem>

      <listitem>
        <para><code>mark</code> - (<code>String</code>) Mark field of an
        alert. Contents depend on the alert type.</para>
      </listitem>

      <listitem>
        <para><code>data</code> - (<code>DmtData</code>) The payload of the
        alert with its type.</para>
      </listitem>
    </itemizedlist>

    <para>An <xref linkend="org.osgi.service.dmt.notification.AlertItem"
    xrefstyle="hyperlink"/> object can be constructed with two different
    constructors:</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.notification.AlertItem.AlertItem-String-String-String-DmtData-"
        xrefstyle="hyperlink"/> - This method takes all the previously defined
        fields.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.notification.AlertItem.AlertItem-String---String-String-DmtData-"
        xrefstyle="hyperlink"/> - Same as previous but with a convenience
        parameter for a segmented URI.</para>
      </listitem>
    </itemizedlist>

    <para>The Notification Service provides the following method to send <xref
    linkend="org.osgi.service.dmt.notification.AlertItem"
    xrefstyle="hyperlink"/> objects to the management server:</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.service.dmt.notification.NotificationService.sendNotification-String-int-String-AlertItem---"
        xrefstyle="hyperlink"/> - Send the alert to the server that is
        associated with the session. The first argument is the name of the
        principal (identifying the remote management system) or
        <code>null</code> for implementation defined routing. The
        <code>int</code> argument is the <emphasis>alert type</emphasis>. The
        alert types are defined by <emphasis>managed object types</emphasis>.
        The third argument (<code>String</code>) can be used for the
        correlation id of a previous execute operation that triggered the
        alert. The <code>AlertItem</code> objects contain the data of the
        alert. The method will run asynchronously from the caller. The
        Notification Service must provide a reliable delivery method for these
        alerts. Alerts must therefore not be re-transmitted.</para>

        <para>When this method is called with <code>null</code> correlator,
        <code>null</code> or empty <code>AlertItem</code> array, and a 0 code
        as values, it should send a protocol specific notification that must
        initiate a new management session.</para>
      </listitem>
    </itemizedlist>

    <para>Implementers should base the routing on the session or server
    information provided as a parameter in the <xref
    linkend="org.osgi.service.dmt.notification.NotificationService.sendNotification-String-int-String-AlertItem---"
    xrefstyle="hyperlink"/> method. Routing might even be possible without any
    routing information if there is a well known remote server for the
    device.</para>

    <para>If the request cannot be routed, the Alert Sender service must
    immediately throw a Dmt Exception with a code of <xref
    linkend="org.osgi.service.dmt.DmtException.ALERT_NOT_ROUTED"
    xrefstyle="hyperlink"/>. The caller should not attempt to retry the
    sending of the notification. It is the responsibility of the Notification
    Service to deliver the notification to the remote management
    system.</para>

    <section>
      <title>Routing Alerts</title>

      <para>The Notification Service allows external parties to route alerts
      to their destination. This mechanism enables Protocol Adapters to
      receive any alerts for systems with which they can communicate.</para>

      <para>Such a Protocol Adapter should register a Remote Alert Sender
      service. It should provide the following service property:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>principals</emphasis> - (<code>String+</code>) The
          array of principals to which this Remote Alert Sender service can
          route alerts. If this property is not registered, the Remote Alert
          Sender service will be treated as the default sender. The default
          alert sender is only used when a more specific alert sender cannot
          be found.</para>
        </listitem>
      </itemizedlist>

      <para>If multiple Remote Alert Sender services register for the same
      principals highest ranking service is taken as defined in the OSGi
      Core.</para>
    </section>
  </section>

  <section>
    <title>Exceptions</title>

    <para>Most of the methods of this Dmt Admin service API throw Dmt
    Exceptions whenever an operation fails. The <code>DmtException</code>
    class contains numeric error codes which describe the cause of the error.
    Some of the error codes correspond to the codes described by the OMA DM
    spec, while some are introduced by the OSGi Working Group. The documentation of
    each method describes what codes could potentially be used for that
    method.</para>

    <para>The fatality of the exception decides if a thrown Exception rolls
    back an atomic session or not. If the <xref
    linkend="org.osgi.service.dmt.DmtException.isFatal--"
    xrefstyle="hyperlink"/> method returns <code>true</code>, the Exception is
    fatal and the session must be rolled back.</para>

    <para>All possible error codes are constants in the
    <code>DmtException</code> class.</para>
  </section>

  <section>
    <title>Events</title>

    <para>There are the following mechanisms to work with events when using
    the Dmt Admin service.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Event Admin service</emphasis> - Standard asynchronous
        notifications</para>
      </listitem>

      <listitem>
        <para><emphasis>Dmt Event Listener service</emphasis> - A white board
        model for listener. A registered <xref
        linkend="org.osgi.service.dmt.DmtEventListener"
        xrefstyle="hyperlink"/> service can use service properties to filter
        the received events</para>
      </listitem>
    </itemizedlist>

    <para>In both cases events are delivered asynchronously and ordered per
    listener unless otherwise specified. Events to the DMT can occur because
    of modifications made in a session or they can occur because a Plugin
    changes its internal state and notifies the Dmt Admin service through the
    <xref linkend="org.osgi.service.dmt.spi.MountPoint"
    xrefstyle="hyperlink"/> interface.</para>

    <para>Changes made through a session always start with a
    <code>SESSION_OPENED</code> event directly after the session is opened.
    This event must contain the properties defined in <xref
    linkend="i2939626"/>.</para>

    <para>If events originate from an atomic session then these events must be
    queued until the sessions is successfully committed, which can happen
    multiple times over the life time of a session. If the session is rolled
    back or runs into an error then none of the queued events must be
    sent.</para>

    <para>When a session is closed, which can happen automatically when the
    session fails, then the <code>SESSION_CLOSED</code> event must be sent.
    This event must happen after any queued events. This closed event must
    contain the properties defined in <xref linkend="i2939626"/>.</para>

    <para>An event must only be sent when that type of event actually
    occurred.</para>

    <section>
      <title>Event Admin</title>

      <para>Event Admin, when present, must be used to deliver the Dmt Admin
      events asynchronously. The event types are specified in <xref
      linkend="service.dmt-event.types"
      xrefstyle="template:Table %n on page %p"/>, the Topic column defines the
      Event Admin topic. The <xref
      linkend="service.dmt-event.properties.lifecycle"
      xrefstyle="template:Table %n on page %p"/> and <xref
      linkend="service.dmt-event.properties.session"
      xrefstyle="template:Table %n on page %p"/> define the Life Cycle and
      Session properties that must be passed as the event properties of Event
      Admin.</para>
    </section>

    <section>
      <title>Dmt Event Listeners</title>

      <para>To receive the Dmt Admin events it is necessary to register a Dmt
      Event Listener service. It is possible to filter the events by
      registering a combination of the service properties defined in the
      following table.</para>

      <table pgwide="1">
        <title>Service Properties for the Dmt Event Listener</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="1*"/>

          <colspec colnum="4" colwidth="3*"/>

          <thead>
            <row>
              <entry>Service Property</entry>

              <entry>Data Type</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtEventListener.FILTER_EVENT"
              xrefstyle="hyperlink"/></entry>

              <entry><code>Integer</code></entry>

              <entry><para>All Events</para></entry>

              <entry><para>A bitmap of <xref
              linkend="org.osgi.service.dmt.DmtEvent" xrefstyle="hyperlink"/>
              types: <xref
              linkend="org.osgi.service.dmt.DmtEvent.SESSION_OPENED"
              xrefstyle="hyperlink"/>, <xref
              linkend="org.osgi.service.dmt.DmtEvent.ADDED"
              xrefstyle="hyperlink"/>, <xref
              linkend="org.osgi.service.dmt.DmtEvent.COPIED"
              xrefstyle="hyperlink"/>, <xref
              linkend="org.osgi.service.dmt.DmtEvent.DELETED"
              xrefstyle="hyperlink"/>, <xref
              linkend="org.osgi.service.dmt.DmtEvent.RENAMED"
              xrefstyle="hyperlink"/>, <xref
              linkend="org.osgi.service.dmt.DmtEvent.REPLACED"
              xrefstyle="hyperlink"/>, and <xref
              linkend="org.osgi.service.dmt.DmtEvent.SESSION_CLOSED"
              xrefstyle="hyperlink"/>. A Dmt Event's type must occur in the
              bitmap to be delivered.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtEventListener.FILTER_PRINCIPAL"
              xrefstyle="hyperlink"/></entry>

              <entry><code>String+</code></entry>

              <entry><para>Any node</para></entry>

              <entry><para>Only deliver Dmt Events for which at least one of
              the given principals has the right to <code>Get</code> that
              node.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.dmt.DmtEventListener.FILTER_SUBTREE"
              xrefstyle="hyperlink"/></entry>

              <entry><code>String+</code></entry>

              <entry><para>Any node</para></entry>

              <entry><para>This property defines a number of sub-trees by
              specifying the URI of the top nodes of these sub-trees. Only
              events that occur in one of the sub-trees must be
              delivered.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>A Dmt Event must only be delivered to a Dmt Event Listener if the
      Bundle that registers the Dmt Event Listener service has the <xref
      linkend="org.osgi.service.dmt.security.DmtPermission.GET"
      xrefstyle="hyperlink"/> Dmt Permission for each of the nodes used in the
      <code>nodes</code> and <code>newNodes</code> properties as tested with
      the Bundle <code>hasPermission</code> method.</para>

      <para>The Dmt Admin service must track Dmt Event Listener services and
      deliver matching events as long as a Dmt Event Listener service is
      registered. Any changes in the service properties must be expediently
      handled.</para>

      <para>A Dmt Event Listener must implement the <xref
      linkend="org.osgi.service.dmt.DmtEventListener.changeOccurred-DmtEvent-"
      xrefstyle="hyperlink"/> method. This method is called asynchronously
      from the actual event occurrence but each listener must receive the
      events in order.</para>

      <para>Events are delivered with a <xref
      linkend="org.osgi.service.dmt.DmtEvent" xrefstyle="hyperlink"/> object.
      This object provides access to the properties of the event. Some
      properties are available as methods others must be retrieved through the
      <xref linkend="org.osgi.service.dmt.DmtEvent.getProperty-String-"
      xrefstyle="hyperlink"/> method. The methods that provide property
      information are listed in the property tables, see <xref
      linkend="service.dmt-event.properties.lifecycle"
      xrefstyle="template:Table %n on page %p"/>.</para>
    </section>

    <section>
      <title>Atomic Sessions and Events</title>

      <para>The intent of the events is that a listener can follow the
      modifications to the DMT from the events alone. However, from an
      efficiency point of view certain events should be coalesced to minimize
      the number of events that a listener need to handle. For this reason,
      the Dmt Admin service must coalesce events if possible.</para>

      <para>Two consecutive events can be coalesced when they are of the same
      type. In that case the <code>nodes</code> and, if present, the
      <code>newNodes</code> of the second event can be concatenated with the
      first event and the <code>timestamp</code> must be derived from the
      first event. It is not necessary to remove duplicates from the
      <code>nodes</code> and <code>newNodes</code>. This guarantees that the
      order of the nodes is in the order of the events.</para>
    </section>

    <section>
      <title>Event Types</title>

      <para>This section describes the events that can be generated by the Dmt
      Admin service. <xref linkend="service.dmt-event.types"/> enumerates all
      the events and provides the name of the topic of Event Admin and the Dmt
      Event type for the listener model.</para>

      <para>There are two kinds of events:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Life Cycle Events</emphasis> - The events for
          session open and closed are the session events.</para>
        </listitem>

        <listitem>
          <para><emphasis>Session Events</emphasis> - <code>ADDED</code>,
          <code>DELETED</code>, <code>REPLACED</code>, <code>RENAMED</code>,
          and <code>COPIED</code>.</para>
        </listitem>
      </itemizedlist>

      <para>Session and life cycle events have different properties.</para>

      <table pgwide="1" xml:id="service.dmt-event.types">
        <title>Event Types</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="1.1*"/>

          <colspec colnum="4" colwidth="2*"/>

          <thead>
            <row>
              <entry>Event</entry>

              <entry>Topic</entry>

              <entry>Dmt Event Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>SESSION OPENED</code></entry>

              <entry><code>org/osgi/service/dmt/DmtEvent/SESSION_OPENED</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtEvent.SESSION_OPENED"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>A new session was opened. The event must the
              properties defined in <xref
              linkend="service.dmt-event.properties.session"
              xrefstyle="template:Table %n on page %p"/>.</para></entry>
            </row>

            <row>
              <entry><code>ADDED</code></entry>

              <entry><code>org/osgi/service/dmt/DmtEvent/ADDED</code></entry>

              <entry><para><xref linkend="org.osgi.service.dmt.DmtEvent.ADDED"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>One or more nodes were added.</para></entry>
            </row>

            <row>
              <entry><code>DELETED</code></entry>

              <entry><code>org/osgi/service/dmt/DmtEvent/DELETED</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtEvent.DELETED"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>One or more existing nodes were
              deleted.</para></entry>
            </row>

            <row>
              <entry><code>REPLACED</code></entry>

              <entry><code>org/osgi/service/dmt/DmtEvent/REPLACED</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtEvent.REPLACED"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Values of nodes were replaced.</para></entry>
            </row>

            <row>
              <entry><code>RENAMED</code></entry>

              <entry><code>org/osgi/service/dmt/DmtEvent/RENAMED</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtEvent.RENAMED"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Existing nodes were renamed.</para></entry>
            </row>

            <row>
              <entry><code>COPIED</code></entry>

              <entry><code>org/osgi/service/dmt/DmtEvent/COPIED</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtEvent.COPIED"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Existing nodes were copied. A copy operation does
              not trigger an <xref
              linkend="org.osgi.service.dmt.DmtEvent.ADDED"
              xrefstyle="hyperlink"/> event (in addition to the <xref
              linkend="org.osgi.service.dmt.DmtEvent.COPIED"
              xrefstyle="hyperlink"/> event), even though new node(s) are
              created. For efficiency reasons, recursive copy and delete
              operations must only generate a single <xref
              linkend="org.osgi.service.dmt.DmtEvent.COPIED"
              xrefstyle="hyperlink"/> and <xref
              linkend="org.osgi.service.dmt.DmtEvent.DELETED"
              xrefstyle="hyperlink"/> event for the root of the affected
              sub-tree.</para></entry>
            </row>

            <row>
              <entry><code>SESSION CLOSED</code></entry>

              <entry><code>org/osgi/service/dmt/DmtEvent/SESSION_CLOSED</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.dmt.DmtEvent.SESSION_CLOSED"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>A session was closed either because it was closed
              explicitly or because there was an error detected. The event
              must the properties defined in <xref
              linkend="service.dmt-event.properties.session"
              xrefstyle="template:Table %n on page %p"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>General Event Properties</title>

      <para>The following properties must be available as the event properties
      in Event Admin service and the properties in the Dmt Event for Dmt Event
      Listener services.</para>

      <table pgwide="1">
        <title>General Event</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="1.5*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="1.5*"/>

          <colspec colnum="4" colwidth="3*"/>

          <thead>
            <row>
              <entry>Property Name</entry>

              <entry>Type</entry>

              <entry>Dmt Event</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>event.topics</code></entry>

              <entry><code>String</code></entry>

              <entry/>

              <entry><para>Event topic, required by Event Admin but must also
              be present in the Dmt Events.</para></entry>
            </row>

            <row>
              <entry><code>session.id</code></entry>

              <entry><code>Integer</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtEvent.getSessionId--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>A unique identifier for the session that triggered
              the event. This property has the same value as <xref
              linkend="org.osgi.service.dmt.DmtEvent.getSessionId--"
              xrefstyle="hyperlink"/> of the associated DMT session. If this
              event is generated outside a session then the session id must be
              -1, otherwise it must be &gt;=1.</para></entry>
            </row>

            <row>
              <entry><para>timestamp</para></entry>

              <entry><para>Long</para></entry>

              <entry><para/></entry>

              <entry><para>The time the event was started as defined by
              <code>System.currentTimeMillis()</code></para></entry>
            </row>

            <row>
              <entry><para>bundle</para></entry>

              <entry><para>Bundle</para></entry>

              <entry><para/></entry>

              <entry><para>The initiating Bundle, this is the bundle that
              caused the event. This is either the Bundle that opened the
              associated session or the Plugin's bundle when there is no
              session (i.e. the session id is -1).</para></entry>
            </row>

            <row>
              <entry><para>bundle.signer</para></entry>

              <entry><para>String+</para></entry>

              <entry><para/></entry>

              <entry><para>The signer of the initiating Bundle</para></entry>
            </row>

            <row>
              <entry><para>bundle.symbolicName</para></entry>

              <entry><para>String</para></entry>

              <entry><para/></entry>

              <entry><para>The Bundle Symbolic name of the initiating
              Bundle</para></entry>
            </row>

            <row>
              <entry><para>bundle.version</para></entry>

              <entry><para>Version</para></entry>

              <entry><para/></entry>

              <entry><para>The Bundle version of the initiating
              Bundle.</para></entry>
            </row>

            <row>
              <entry><para>bundle.id</para></entry>

              <entry><para>Long</para></entry>

              <entry><para/></entry>

              <entry><para>The Bundle Id of the initiating
              Bundle.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Session Event Properties</title>

      <para>All session events must have the properties defined in the
      following table.</para>

      <table pgwide="1" xml:id="service.dmt-event.properties.session">
        <title>Event Properties For Session Events</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="1.5*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="1.5*"/>

          <colspec colnum="4" colwidth="3*"/>

          <thead>
            <row>
              <entry>Property Name</entry>

              <entry>Type</entry>

              <entry>Dmt Session</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>session.rooturi</code></entry>

              <entry><code>String</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtSession.getRootUri--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The root URI of the session that triggered the
              event.</para></entry>
            </row>

            <row>
              <entry><code>session.principal</code></entry>

              <entry><code>String</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtSession.getPrincipal--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The principal of the session, or absent if no
              principal is associated with this session. In the latter case
              the method returns <code>null</code>.</para></entry>
            </row>

            <row>
              <entry><code>session.locktype</code></entry>

              <entry><code>Integer</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtSession.getLockType--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The lock type of the session. The number is mapped
              as follows:</para><itemizedlist>
                  <listitem>
                    <para><xref
                    linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_SHARED"
                    xrefstyle="hyperlink"/> - 0</para>
                  </listitem>

                  <listitem>
                    <para><xref
                    linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_EXCLUSIVE"
                    xrefstyle="hyperlink"/> - 1</para>
                  </listitem>

                  <listitem>
                    <para><xref
                    linkend="org.osgi.service.dmt.DmtSession.LOCK_TYPE_ATOMIC"
                    xrefstyle="hyperlink"/> - 2</para>
                  </listitem>
                </itemizedlist></entry>
            </row>

            <row>
              <entry><code>session.timeout</code></entry>

              <entry><code>Boolean</code></entry>

              <entry/>

              <entry><para>If the session timed out then this property must be
              set to <code>true</code>. If it did not time out this property
              must be <code>false</code>.</para></entry>
            </row>

            <row>
              <entry><para><code>exception</code></para></entry>

              <entry><para><code>Throwable</code></para></entry>

              <entry><para/></entry>

              <entry><para>The name of the actual exception class if the
              session had a fatal exception.</para></entry>
            </row>

            <row>
              <entry><para>exception.message</para></entry>

              <entry><para>String</para></entry>

              <entry><para/></entry>

              <entry><para>Must describe the exception if the session had a
              fatal exception.</para></entry>
            </row>

            <row>
              <entry><para>exception.class</para></entry>

              <entry><para>String</para></entry>

              <entry><para/></entry>

              <entry><para>The name of the actual exception class if the
              session had a fatal exception.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="i2939626">
      <title>Life Cycle Event Properties</title>

      <para>All Life Cycle events must have the properties defined in the
      following table.</para>

      <table pgwide="1" xml:id="service.dmt-event.properties.lifecycle">
        <title>Event Properties for Life Cycle Events</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="1.5*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="1.5*"/>

          <colspec colnum="4" colwidth="3*"/>

          <thead>
            <row>
              <entry>Property Name</entry>

              <entry>Type</entry>

              <entry>Dmt Event</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>nodes</code></entry>

              <entry><code>String[]</code></entry>

              <entry><xref linkend="org.osgi.service.dmt.DmtEvent.getNodes--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The absolute URIs of each affected node. This is
              the <code>nodeUri</code> parameter of the Dmt API methods. The
              order of the URIs in the array corresponds to the chronological
              order of the operations. In case of a recursive delete or copy,
              only the session root URI is present in the array.
              </para></entry>
            </row>

            <row>
              <entry><code>newnodes</code></entry>

              <entry><code>String[]</code></entry>

              <entry><xref
              linkend="org.osgi.service.dmt.DmtEvent.getNewNodes--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The absolute URIs of new renamed or copied nodes.
              Only the <code>RENAMED</code> and <code>COPIED</code> events
              have this property.</para><para>The <code>newnodes</code> array
              runs parallel to the <code>nodes</code> array. In case of a
              rename, <code>newnodes[i]</code> must contains the new name of
              <code>nodes[i]</code>, and in case of a copy,
              <code>newnodes[i]</code> is the URI to which
              <code>nodes[i]</code> was copied.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Example Event Delivery</title>

      <para>The example in this section shows the change of a non-trivial tree
      and the events that these changes will cause.</para>

      <figure xml:id="i1768822">
        <title>Example DMT before</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.933in"
                       contentwidth="5.011in" fileref="dmt-example-before.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>For example, in a given session, when the DMT in <xref
      linkend="i1768822"/> is modified with the following operations:</para>

      <itemizedlist>
        <listitem>
          <para>Open atomic session 42 on the root URI</para>
        </listitem>

        <listitem>
          <para>Add node <code>./A/B/C</code></para>
        </listitem>

        <listitem>
          <para>Add node <code>./A/B/C/D</code></para>
        </listitem>

        <listitem>
          <para>Rename <code>./M/n1</code> to./M/n2</para>
        </listitem>

        <listitem>
          <para>Copy <code>./M/n2</code> to <code>./M/n3</code></para>
        </listitem>

        <listitem>
          <para>Delete node <code>./P/Q</code></para>
        </listitem>

        <listitem>
          <para>Add node <code>./P/Q</code></para>
        </listitem>

        <listitem>
          <para>Delete node <code>./P/Q</code></para>
        </listitem>

        <listitem>
          <para>Replace <code>./X/Y/z</code> with 3</para>
        </listitem>

        <listitem>
          <para>Commit</para>
        </listitem>

        <listitem>
          <para>Close</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Example DMT after</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.933in"
                       contentwidth="5.011in" fileref="dmt-example-after.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>When the Dmt Session is opened, the following event is
      published:</para>

      <programlisting>SESSION_OPENED {
        session.id = 42
        session.rooturi=.
        session.principal=null
        session.locktype=2
        timestamp=1313411544752
        bundle  =&lt;Bundle&gt;
        bundle.signer=[]
        bundle.symbolicname"com.acme.bundle"
        bundle.version=1.2.4711
        bundle.id=442
        ...
}</programlisting>

      <para>When the Dmt Session is closed (assuming it is atomic), the
      following events are published:</para>

      <programlisting>ADDED {
        nodes = [./A/B/C, ./A/B/C/D ]       # note the coalescing
        session.id = 42
        ...
}
RENAMED {
        nodes = [ ./M/n1 ]
        newnodes = [ ./M/n2 ]
        session.id = 42
        ...
}
COPIED {
        nodes = [ ./M/n2 ]
        newnodes = [ ./M/n3 ]
        session.id = 42
        ...
}
DELETED {
        nodes = [ ./P/Q ]
        session.id = 42
        ...
}
ADDED {
        nodes = [ ./P/Q ]
        session.id = 42
        ...
}
DELETED {
        nodes = [ ./P/Q ]
        session.id = 42
        ...
}
REPLACED {
        nodes = [ ./X/Y/z ]
        session.id = 42
        ...
}
SESSION_CLOSED {
        session.id = 42
        session.rooturi=.
        session.principal=null
        session.locktype=2
        ...
}</programlisting>
    </section>
  </section>

  <section xml:id="service.dmt.osgiobjectmodeling">
    <title>OSGi Object Modeling</title>

    <section>
      <title>Object Models</title>

      <para>Management protocols define only half the picture; the object
      models associated with a particular protocol are the other half. Object
      models are always closely associated with a remote management protocol
      since they are based on the data types and actions that are defined in
      the protocol. Even small differences between the data types of a
      protocol and its differences make accurate mapping between protocols
      virtually impossible. It is therefore necessary to make the distinction
      between <emphasis>native</emphasis> and <emphasis>foreign</emphasis>
      protocols for an object model.</para>

      <para>A native protocol for an object model originates from the same
      specification organization. For example, OMA DM consists of a protocol
      based on SyncML and a number of object models that define the structure
      and behavior of the nodes of the DMT. The FOMA specification defines an
      OMA DM native object model, it defines how firmware management is done.
      This is depicted in <xref linkend="i2869529"/>.</para>

      <figure xml:id="i2869529">
        <title>Device Management Architecture</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.887in"
                       contentwidth="5.236in"
                       fileref="device-management-architecture.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>If an object implements a standardized data model it must be
      visible through its <emphasis>native</emphasis> Protocol Adapter, that
      is the Protocol Adapter that belongs to the object model's standard. For
      example, an <code>ExecutionUnit</code> node defined in UPnP Device
      Management could be implemented as a bundle, exposed through a Data
      Plugin for the Dmt Admin service, and then translated by its native UPnP
      Protocol Adapter.</para>

      <para>If an object is present in the Dmt Admin service it is also
      available to <emphasis>foreign</emphasis> Protocol Adapters. A foreign
      Protocol Adapter is any Protocol Adapter except its native Protocol
      Adapter. For example, the Broadband Forum's <code>ExecutionUnit</code>
      could be browsed on the foreign OMA DM protocol.</para>

      <para>In a foreign Protocol Adapter the object model should be
      <emphasis>browsable</emphasis> but it would not map to one of its native
      object models. Browsable means that the information is available to the
      Protocol Adapter's remote manager but not recognized as a standard model
      for the manager. Browse can include, potentially limited,
      manipulation.</para>

      <para>In a native Protocol Adapter it is paramount that the mapping from
      the DMT to the native object is fully correct. It is the purpose of this
      part of the Dmt Admin service specification to allow the native Protocol
      Adapter to map the intentions of the Plugin without requiring knowledge
      of the specific native object model. That is, a TR-069 Plugin
      implementing a WAN interface must be available over the TR-069 protocol
      without the Protocol Adapter having explicit knowledge about the WAN
      interfaces object models from Broadband Forum.</para>

      <para>Therefore, the following use cases are recognized:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Foreign Mapping</emphasis> - Foreign mapping can is
          best-effort as there is no object model to follow. Each Protocol
          Adapter must define how the Dmt Admin model is mapped for this
          browse mode.</para>
        </listitem>

        <listitem>
          <para><emphasis>Native Mapping</emphasis> - Native mapping must be
          100% correct. As it is impossible automatically map DMTs to
          arbitrary protocols this specification provides the concept of a
          mapping model that allows a Plugin to instruct its native Protocol
          Adapter using Meta Nodes.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="service.dmt.protocolmapping">
      <title>Protocol Mapping</title>

      <para>The OSGi Working Group specifies an Execution Environment that can be
      used as a basis for residential gateways, mobiles, or other devices.
      This raises the issue how to expose the manageability of an OSGi device
      and the <emphasis>objects</emphasis>, the units of manageability, that
      are implemented through Plugins. Ideally, an object should be able to
      expose its management interface once and then Protocol Adapters convert
      the management interface to specific device management stacks. For
      example, an object can be exposed through the Dmt Admin service where
      then a TR-069 Protocol Adapter maps the DMT to the TR-069 Remote
      Procedure Calls (RPC).</para>

      <para><xref linkend="i2869627"/> shows an example of a TR-069 Protocol
      Adapter and an OMA DM Protocol Adapter. The TR-069 Protocol Adapter
      should be able to map native TR-069 objects in the DMT (the
      <code>Software Modules Impl</code> in the figure) to Broadband Forum's
      object models. It should also be able to browse the foreign DMT and
      other objects that are not defined in Broadband forum but can be
      accessed with the TR-069 RPCs.</para>

      <figure pgwide="1" xml:id="i2869627">
        <title>Implementing &amp; Browsing</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.326in"
                       contentwidth="6.260in"
                       fileref="implementing-browsing.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A <emphasis>Protocol Mapping</emphasis> is a document that
      describes the default mapping and the native mechanism for exact
      mapping.</para>

      <para>The following sections specify how Plugins must implement an
      object model that is exposed through the Dmt Admin service. This model
      is limited from the full Dmt Admin service capabilities so that for each
      protocol it is possible to specify a default mapping for browsing as
      well as a mechanism to ensure that special conversion requirements can
      be communicated from a Plugin to its native Protocol Adapter.</para>
    </section>

    <section xml:id="i2836536">
      <title>Hierarchy</title>

      <para>The Dmt Admin model provides an hierarchy of
      <emphasis>nodes</emphasis>. Each node has a <emphasis>type</emphasis>
      that is reflected by its Meta Node. A node is addressed with a URI. The
      flexibility of the Dmt Admin service allows a large number of
      constructs, for example, the name of the node can be used as a
      <emphasis>value</emphasis>, a feature that some management standards
      support. To simplify mapping to foreign Protocol Adapters, some of the
      fundamental constructs have been defined in the following
      sections.</para>
    </section>

    <section>
      <title>General Restriction Guidelines</title>

      <para>The Dmt Admin service provides a very rich tool to model complex
      object structures. Many choices can be made that would make it very hard
      to browse DMTs on non-OMA DM protocols or make the DMT hard to use
      through the Dmt Admin service. As Plugins can always signal special case
      handling to their native Protocol Adapter, any object model design
      should strive to be easy to use for the developers and managers.
      Therefore, this section provides a number of guidelines for the design
      of such object models that will improve the browsing experience for many
      Protocol Adapters.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Reading of a node must not change the state of a
          device</emphasis> - Management systems must be able to browse a tree
          without causing any side effects. If reading modified the DMT, a
          management system would have no way to warn the user that the system
          is modified. There are a number of technical reasons as well (race
          conditions, security holes, and eventing) but the most important
          reason is the browsability of the device.</para>
        </listitem>

        <listitem>
          <para><emphasis>No use of recursive structures</emphasis> - The Dmt
          Admin service provides a very rich tree model that has no problem
          with recursion. However, this does not have to be true for other
          models. To increase the changes that a model is browsable on another
          device it is strongly recommended to prevent recursive models. For
          example, TR-069 cannot handle recursive models.</para>
        </listitem>

        <listitem>
          <para><emphasis>Only a single format per meta node</emphasis> -
          Handling different types in different nodes simplifies the data
          conversion for both foreign and native protocols. Having a single
          choice from the Meta Node makes the conversion straightforward and
          does not require guessing.</para>
        </listitem>

        <listitem>
          <para><emphasis>All nodes must provide a Meta Node</emphasis> -
          Conversion without a Meta Node makes the conversion very hard since
          object model schemas are often not available in the Protocol
          Adapter.</para>
        </listitem>

        <listitem>
          <para><emphasis>Naming</emphasis> - Structured node members must
          have names only consisting of <code>[a-zA-Z0-9]</code> and must
          always start with a character <code>[a-zA-z]</code>. Member names
          must be different regardless of the case, that is <code>Abc</code>
          and <code>ABC</code> must not both be members of the same structured
          node. The reason for this restriction is that it makes it more
          likely that the chosen names are compatible with the supported
          protocols and do not require escaping.</para>
        </listitem>

        <listitem>
          <para><emphasis>Typing</emphasis> - Restrict the used formats to
          formats that maximize both the interoperability as the ease of use
          for Java developers. The following type are widely supported and are
          easy to use from Java:</para>

          <itemizedlist>
            <listitem>
              <para><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_STRING"
              xrefstyle="hyperlink"/></para>
            </listitem>

            <listitem>
              <para><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_BOOLEAN"
              xrefstyle="hyperlink"/></para>
            </listitem>

            <listitem>
              <para><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_INTEGER"
              xrefstyle="hyperlink"/></para>
            </listitem>

            <listitem>
              <para><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_LONG"
              xrefstyle="hyperlink"/></para>
            </listitem>

            <listitem>
              <para><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_FLOAT"
              xrefstyle="hyperlink"/></para>
            </listitem>

            <listitem>
              <para><xref
              linkend="org.osgi.service.dmt.DmtData.FORMAT_DATE_TIME"
              xrefstyle="hyperlink"/></para>
            </listitem>

            <listitem>
              <para><xref linkend="org.osgi.service.dmt.DmtData.FORMAT_BINARY"
              xrefstyle="hyperlink"/></para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>DDF</title>

      <para>The Data Description Format is part of OMA DM; it provides a
      description language for the object model. The following table provides
      an example of the Data Description Format as used in the OSGi
      specifications.</para>

      <informaltable>
        <tgroup cols="6">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="4*"/>

          <colspec colnum="4" colwidth="2*"/>

          <colspec colnum="5" colwidth="1*"/>

          <colspec colnum="6" colwidth="5*"/>

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Actions</entry>

              <entry>Type</entry>

              <entry>Card.</entry>

              <entry>S</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>FaultType</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>integer</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>...</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The columns have the following meanings:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Name</emphasis> - The name of the node</para>
        </listitem>

        <listitem>
          <para><emphasis>Actions</emphasis> - The set of actions that can be
          executed on the node, see <xref linkend="i2760251"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Type</emphasis> - The type of the node. All lower
          case are primitives, a name starting with an upper case is an
          interior node type. MAP, LIST, and SCAFFOLD are the special types.
          The NODE type is like an ANY type. Other type names are then further
          specified in the document. See <xref linkend="i2836625"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Cardinality</emphasis> - The number of occurrences
          of the node, see <xref linkend="i2760429"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Scope</emphasis> - The scope of the node, see <xref
          linkend="i2965501"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Description</emphasis> - A description of the
          node.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i2836625">
      <title>Types</title>

      <para>Each node is considered to have a <emphasis>type</emphasis>. The
      Dmt Admin service has a number of constructs that have typing like
      behavior. There are therefore the following <emphasis>kind</emphasis> of
      types:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Primitives</emphasis> - Primitives are data types
          like integers and strings; they include all the Dmt Admin data
          formats. See <xref linkend="i2836736"/>. Primitive type names are
          always lower case to distinguish them from the interior node type
          names.</para>
        </listitem>

        <listitem>
          <para><emphasis>Structured Types</emphasis> - A structured type
          types a structured node. See <xref linkend="i2836768"/>. A
          structured type has a type name that starts with an uppercase.
          Object models generally consist of defining these types.</para>
        </listitem>

        <listitem>
          <para><code>NODE</code> - A general unqualified Dmt Admin
          node.</para>
        </listitem>

        <listitem>
          <para><code>LIST</code> - A node that represents a homogeneous
          collection of child nodes; the name of the child nodes is the index
          in the collection. See <xref linkend="i2836847"/>.</para>
        </listitem>

        <listitem>
          <para><code>MAP</code> - A node that represents a mapping from a
          key, the name of the child node, and a value, the value of the child
          node. All values have the same type. See <xref
          linkend="i2837021"/>.</para>
        </listitem>

        <listitem>
          <para><code>SCAFFOLD</code> - A node provided by the Dmt Admin
          service or a Parent Plugin to make it possible to discover a DMT,
          see <xref linkend="i2931854"/>.</para>
        </listitem>
      </itemizedlist>

      <para>Nodes are treated as if there is a single type system. However,
      the Dmt Admin type system has the following mechanisms to type a
      node:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Format</emphasis> - The Dmt Admin primitive types
          used for leaf nodes, as defined on Dmt Data.</para>
        </listitem>

        <listitem>
          <para><emphasis>MIME</emphasis> - A MIME type on a leaf node which
          is available through <xref
          linkend="org.osgi.service.dmt.DmtSession.getNodeType-String-"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>DDF Document URI</emphasis> - A Data Description
          Format URI that provides a type name for an interior node. The URI
          provides a similar role as the MIME type for the leaf node and is
          also available through <xref
          linkend="org.osgi.service.dmt.DmtSession.getNodeType-String-"
          xrefstyle="hyperlink"/>.</para>
        </listitem>
      </itemizedlist>

      <para>The Dmt Admin service provides the MIME type for leaf nodes and
      the DDF Document URI for interior nodes through the <xref
      linkend="org.osgi.service.dmt.DmtSession.getNodeType-String-"
      xrefstyle="hyperlink"/> method. As both are strings they can both be
      used as type identifiers. The different types are depicted in <xref
      linkend="i2836666"/>.</para>

      <figure pgwide="1" xml:id="i2836666">
        <title>Type inheritance and structure</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.900in"
                       contentwidth="6.260in"
                       fileref="type-inheritance-structure.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="i2836736">
      <title>Primitives</title>

      <para>A primitive is a value stored in a leaf node. In the Dmt Admin
      service, the type of the primitive is called the
      <emphasis>format</emphasis>. The Dmt Admin service supports a large
      number of types that have semantic overlap. A Protocol Mapping must
      provide a unique mapping from each Dmt Admin format to the corresponding
      protocol type and provide conversion from a protocol type to the
      corresponding Dmt Admin types defined in a Meta Node.</para>

      <para>Primitives are documented in OSGi object models with a lower case
      name that is the last part of their format definition. For example, for
      <xref linkend="org.osgi.service.dmt.DmtData.FORMAT_STRING"
      xrefstyle="hyperlink"/> the DDF type name is <code>string</code>. A
      primitive DDF for an integer leaf node therefore looks like:</para>

      <informaltable>
        <tgroup cols="6">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="4*"/>

          <colspec colnum="4" colwidth="2*"/>

          <colspec colnum="5" colwidth="1*"/>

          <colspec colnum="6" colwidth="5*"/>

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Act</entry>

              <entry>Type</entry>

              <entry>Card.</entry>

              <entry>S</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>FaultType</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>integer</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>...</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id="i2836768">
      <title>Structured Nodes</title>

      <para>A <emphasis>structured node</emphasis> is like a
      <code>struct</code> in C or a class in an object oriented languages. A
      structured node is an interior node with a set of members (child nodes)
      with fixed names, it is never possible to add or remove such members
      dynamically. The meaning of each named node and its type is usually
      defined in a management specification. For example, a node representing
      the OSGi Bundle could have a <code>BundleId</code> child-node that maps
      to the <code>getBundleId()</code> method on the <code>Bundle</code>
      interface.</para>

      <para>It is an error to add or delete members to a Structured node, this
      must be reflected in the corresponding Meta Node, that is, Structured
      nodes must never have the <code>Add</code> or <code>Delete</code>
      action.</para>

      <para>A structured node is defined in a <emphasis>structured
      type</emphasis> to allow the reuse of the same information in different
      places in an object model. A structured type defines the members and
      their behaviors. A structured type can be referred by its name. The name
      of the type is often, but not required, the name of the member.</para>

      <para>For example, a <code>Unit</code> structured type could look
      like:</para>

      <informaltable>
        <tgroup cols="6">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="4*"/>

          <colspec colnum="4" colwidth="2*"/>

          <colspec colnum="5" colwidth="1*"/>

          <colspec colnum="6" colwidth="5*"/>

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Act</entry>

              <entry>Type</entry>

              <entry>Card.</entry>

              <entry>S</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>Id</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>long</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>...</para></entry>
            </row>

            <row>
              <entry><code>URL</code></entry>

              <entry><code>Get Set</code></entry>

              <entry><code>string</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>...</para></entry>
            </row>

            <row>
              <entry><code>Name</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>string</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>...</para></entry>
            </row>

            <row>
              <entry><code>Certificate</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>LIST</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry><code>&#160;[index]</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>Certificate</code></entry>

              <entry><code>1</code></entry>

              <entry><code>D</code></entry>

              <entry><para>Note the use of a structured type.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id="i2836847">
      <title>LIST Nodes</title>

      <para>A <code>LIST</code> node is an interior node representing a
      <emphasis>collection</emphasis> of elements. The elements are stored in
      the child nodes of the <code>LIST</code> node, they are called the
      <emphasis>index nodes</emphasis>. All index nodes must have the same
      type. The names of the index nodes are synthesized and represent the
      index of the index node. The first node is always named 0 and the
      sibling is 1, 2, etc. The sequence must be continuous and must have no
      missing indexes. A node name is always a string, it is therefore the
      responsibility of the plugin to provide the proper names. The index is
      assumed to be a signed positive integer limiting the <code>LIST</code>
      nodes size to <code>Integer.MAX_VALUE</code> elements.</para>

      <figure>
        <title>LIST Nodes</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.141in"
                       contentwidth="5.927in" fileref="list-nodes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Index nodes should only be used for types where the value of the
      index node is the identity. For example, a network interface has an
      identity; a manager will expect that a node representing such as a
      network interface node will always have the same URI even if other
      interfaces are added and deleted. Since <code>LIST</code> nodes renumber
      the index node names when an element is deleted or added, the URI would
      fail if a network interface was added or removed. If such a case, a
      <code>MAP</code> node should be used, see <xref linkend="i2837021"/>, as
      they allow the key to be managed by the remote manager.</para>

      <para><code>LIST</code> nodes can be mutable if the Meta Node of its
      index nodes support the <code>Add</code> or <code>Delete</code> action.
      A LIST node is modeled after a <code>java.util.List</code> that can
      automatically accommodate new elements. <code>Get</code> and
      <code>Replace</code> operations use the node name to index in this
      list.</para>

      <para>To rearrange the list the local manager can <code>Add</code> and
      <code>Delete</code> nodes or rename them as it sees fit. At any moment
      in time the underlying implementation must maintain a list that runs
      from 0 to <code>max(index)</code> (inclusive), where index is the name
      of the <code>LIST</code> child nodes. Inserting a node requires renaming
      all subsequent nodes. Any missing indexes must automatically be provided
      by the plugin when the child node names are retrieved.</para>

      <para>For example, a <code>LIST</code> node named <code>L</code>
      contains the following nodes:</para>

      <programlisting>L/0     A
L/1     B
L/2     C</programlisting>

      <para>To insert a node after <code>B</code>, <code>L/2</code> must be
      renamed to <code>L/3</code>. This will automatically extend the
      <code>LIST</code> node to 4 elements. That is, even though
      <code>L/2</code> is renamed, the implementation must automatically
      provide a new <code>L/2</code> node. The value of this node depends on
      the underlying implementation. The value of the list will therefore then
      be: <code>[A,B,?,C]</code>. If node 1 is deleted, then the list will be
      <code>[A,?,C]</code>. If a node L/5 is added then the list will be
      <code>[A,?,C,?,?,?]</code>. It is usually easiest to use the LIST node
      as a complex value, this is discussed in the next section.</para>

      <section>
        <title>Complex Collections</title>

        <para>An implementation of a <code>LIST</code> node must support a
        complex node value if its members are primitive; the interior node
        must then have a value of a Java object implementing the
        <code>Collection</code> interface from <code>java.util</code>. The
        elements in this map must be converted according to the following
        table.</para>

        <table xml:id="service.dmt-collections.conversion">
          <title>Conversion for Collections</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="2*"/>

            <colspec colnum="2" colwidth="5*"/>

            <thead>
              <row>
                <entry><para>Format</para></entry>

                <entry><para>Associated Java Type</para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para><xref
                linkend="org.osgi.service.dmt.DmtData.FORMAT_STRING"
                xrefstyle="hyperlink"/></para></entry>

                <entry><para><code>String</code></para></entry>
              </row>

              <row>
                <entry><para><xref
                linkend="org.osgi.service.dmt.DmtData.FORMAT_BOOLEAN"
                xrefstyle="hyperlink"/></para></entry>

                <entry><para><code>Boolean</code></para></entry>
              </row>

              <row>
                <entry><para><xref
                linkend="org.osgi.service.dmt.DmtData.FORMAT_INTEGER"
                xrefstyle="hyperlink"/></para></entry>

                <entry><para><code>Integer</code></para></entry>
              </row>

              <row>
                <entry><para><xref
                linkend="org.osgi.service.dmt.DmtData.FORMAT_LONG"
                xrefstyle="hyperlink"/></para></entry>

                <entry><para><code>Long</code></para></entry>
              </row>

              <row>
                <entry><para><xref
                linkend="org.osgi.service.dmt.DmtData.FORMAT_FLOAT"
                xrefstyle="hyperlink"/></para></entry>

                <entry><para><code>Float</code></para></entry>
              </row>

              <row>
                <entry><para><xref
                linkend="org.osgi.service.dmt.DmtData.FORMAT_DATE_TIME"
                xrefstyle="hyperlink"/></para></entry>

                <entry><para><code>Date</code></para></entry>
              </row>

              <row>
                <entry><para><xref
                linkend="org.osgi.service.dmt.DmtData.FORMAT_BINARY"
                xrefstyle="hyperlink"/></para></entry>

                <entry><para><code>byte[]</code></para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Alternatively, the Collection may contain Dmt Data objects but
        the collection must be homogeneous. The collection must always be a
        copy and changes made to the collection must not affect the
        DMT.</para>

        <para>For example, a <code>LIST</code> type for a list of URIs could
        look like:</para>

        <informaltable>
          <tgroup cols="6">
            <colspec colnum="1" colwidth="3*"/>

            <colspec colnum="2" colwidth="2*"/>

            <colspec colnum="3" colwidth="4*"/>

            <colspec colnum="4" colwidth="2*"/>

            <colspec colnum="5" colwidth="1*"/>

            <colspec colnum="6" colwidth="5*"/>

            <thead>
              <row>
                <entry>Name</entry>

                <entry>Act</entry>

                <entry>Type</entry>

                <entry>Card.</entry>

                <entry>S</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>URIs</code></entry>

                <entry><code>Get</code></entry>

                <entry><code>LIST</code></entry>

                <entry><code>1</code></entry>

                <entry><code>P</code></entry>

                <entry><para>A List of URIs</para></entry>
              </row>

              <row>
                <entry><code>&#160;[index]</code></entry>

                <entry><code>Get Set Add Del</code></entry>

                <entry><code>string</code></entry>

                <entry><code>0..n</code></entry>

                <entry><code>D</code></entry>

                <entry><para>A primitive index node</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Replacing a complex value will generate a single <xref
        linkend="org.osgi.service.dmt.DmtConstants.EVENT_TOPIC_REPLACED"
        xrefstyle="hyperlink"/> event for the <code>LIST</code> node.</para>
      </section>
    </section>

    <section xml:id="i2837021">
      <title>MAP Nodes</title>

      <para>A <code>MAP</code> node represents a mapping from a
      <emphasis>key</emphasis> to a <emphasis>value</emphasis>. The key is the
      name of the node and the value is the node's value. A <code>MAP</code>
      node performs the same functions as a Java Map. See <xref
      linkend="i2837027"/>.</para>

      <figure xml:id="i2837027">
        <title>MAP Nodes</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.377in"
                       contentwidth="5.927in" fileref="map-nodes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A <code>MAP</code> node has <emphasis>key nodes</emphasis> as
      children. A key node is an association between the name of the key node
      (which is the key) and the value of the key node. Key nodes are depicted
      with <code>[&lt;type&gt;]</code>, where the <code>&lt;type&gt;</code>
      indicates the type used for the string name. For example, a long type
      will have node names that can be converted to a <code>long</code>. A key
      type must always be one of the primitive types. For example, a list of
      Bundle locations can be handled with a <code>MAP</code> with
      <code>[string]</code> key nodes that have a value type of string. Since
      the key is used in URIs it must always be escaped, see <xref
      linkend="i2275977"/>.</para>

      <para>For example:</para>

      <informaltable>
        <tgroup cols="6">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="4*"/>

          <colspec colnum="4" colwidth="2*"/>

          <colspec colnum="5" colwidth="1*"/>

          <colspec colnum="6" colwidth="5*"/>

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Act</entry>

              <entry>Type</entry>

              <entry>Card.</entry>

              <entry>S</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>Location</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>MAP</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>A MAP of location where the index node is the
              Bundle Id.</para></entry>
            </row>

            <row>
              <entry><code>&#160;[long]</code></entry>

              <entry><code>Get Set Add Del</code></entry>

              <entry><code>string</code></entry>

              <entry><code>0..n</code></entry>

              <entry><code>D</code></entry>

              <entry><para>Name is the Bundle Id and the value is the
              location.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <section>
        <title>Complex Value</title>

        <para>An implementation of a <code>MAP</code> node must support an
        interior node value if its child nodes are primitive; the interior
        node must then be associated with a Java object implementing the
        <code>Map</code> interface from <code>java.util</code>. The values in
        this Map must homogeneous and be converted according to <xref
        linkend="service.dmt-collections.conversion"/> or the given values
        must of type <code>DmtData</code>. The <code>Map</code> object must a
        copy and does not track changes in the DMT or vice-versa.</para>

        <para>Replacing a complex value will generate a single <xref
        linkend="org.osgi.service.dmt.DmtConstants.EVENT_TOPIC_REPLACED"
        xrefstyle="hyperlink"/> event for that node.</para>
      </section>
    </section>

    <section xml:id="service.dmt.instanceid">
      <title>Instance Id</title>

      <para>Some protocols cannot handle arbitrary names in the access URI,
      they need a well defined <emphasis>instance id</emphasis> to index in a
      table or put severe restrictions on the node name's character set,
      length, or other aspects. For example, TR-069 can access an object with
      the following URI:</para>

      <programlisting>Device.VOIP.12.Name</programlisting>

      <para>The more natural model for the DMT is to use:</para>

      <programlisting>Device.VOIP.&lt;Name&gt;...</programlisting>

      <para>To provide assistance to these protocols this section defines a
      mechanism that can be used by Protocol Adapters to simplify
      access.</para>

      <para>An Object Model can define a child node <code>InstanceId</code>.
      The <code>InstanceId</code> node, if present, holds a long value that
      has the following qualities:</para>

      <itemizedlist>
        <listitem>
          <para>Its value must be between 1 and
          <code>Long.MAX_VALUE</code>.</para>
        </listitem>

        <listitem>
          <para>No other index/key node on the same level must have the same
          value for the <code>InstanceId</code> node</para>
        </listitem>

        <listitem>
          <para>The value must be persistent between sessions and restarts of
          the plugin</para>
        </listitem>

        <listitem>
          <para>A value must not be reused when a node is deleted until the
          number space is exhausted</para>
        </listitem>
      </itemizedlist>

      <para>Protocol Adapters can use this information to provide alternative
      access paths for the DMT.</para>
    </section>

    <section>
      <title>Conversions</title>

      <para>Each Protocol Mapping document should define a default conversion
      from the Dmt Admin data formats to the protocol types and vice versa,
      including the <code>LIST</code> and <code>MAP</code> nodes. However,
      this default mapping is likely to be too constraining in real world
      models since different protocols support different data types and a 1:1
      mapping is likely to be impossible.</para>

      <para>For this reason, the Protocol Mapping document should define a
      number of protocol specific MIME types for each unique data type that
      they support. A Data Plugin can associate such a MIME type with a node.
      The Protocol Adapter can then look for this MIME type. If none of the
      Protocol Adapter specific MIME types are available in a node the default
      conversion is used.</para>

      <para>For example, in the TR-069 Protocol Adapter specification there is
      a MIME type for each TR-069 data type. If for a given leaf node the Meta
      Node's type specifies <code>TR069_MIME_UNSIGNED_INT</code> and the node
      specifies the format <xref
      linkend="org.osgi.service.dmt.DmtData.FORMAT_INTEGER"
      xrefstyle="hyperlink"/> then the Protocol Adapter must convert the
      integer to an unsigned integer and encode the value as such in the
      response message. The Protocol Adapter there does not have to have
      specific knowledge of the object model, the Plugin drives the Protocol
      Adapter by providing the protocol specific MIME types on the leaf node
      Meta Nodes. This model is depicted in <xref linkend="i2837120"/>.</para>

      <figure xml:id="i2837120">
        <title>Conversions</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.450in"
                       contentwidth="6.312in" fileref="conversions.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Since a Meta Node can contain multiple MIME types, there is no
      restrictions on the number of Protocol Adapters; a Plugin can specify
      the MIME types of multiple Protocol Adapters.</para>
    </section>

    <section>
      <title>Extensions</title>

      <para>All interior nodes in this specification can have a node named
      <code>Ext</code>. These nodes are the <emphasis>extension</emphasis>
      nodes. If an implementation needs to expose additional details about an
      interior node then they should expose these extensions under the
      corresponding <code>Ext</code> node. To reduce name conflicts, it is
      recommended to group together implementation specific extensions under a
      unique name, recommended is to use the reverse domain name. For example,
      the following DDF defines an <code>Ext</code> node with extensions for
      the ACME provider.</para>

      <informaltable>
        <tgroup cols="6">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="4*"/>

          <colspec colnum="4" colwidth="2*"/>

          <colspec colnum="5" colwidth="1*"/>

          <colspec colnum="6" colwidth="5*"/>

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Act</entry>

              <entry>Type</entry>

              <entry>Card.</entry>

              <entry>S</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>Framework</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>Framework</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>...</para></entry>
            </row>

            <row>
              <entry><code>&#160;Ext</code></entry>

              <entry><code>Get</code></entry>

              <entry/>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>Extension node</para></entry>
            </row>

            <row>
              <entry><code>&#160;&#160;com.acme</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>AcmeFrameworkExt</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>The node for the ACME extensions</para></entry>
            </row>

            <row>
              <entry><code>&#160;&#160;&#160;Transactional</code></entry>

              <entry><code>Get</code></entry>

              <entry><code>boolean</code></entry>

              <entry><code>1</code></entry>

              <entry><code>P</code></entry>

              <entry><para>...</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>

  <section>
    <title>Security</title>

    <para>A key aspect of the Dmt Admin service model is the separation from
    DMT clients and plugins. The Dmt Admin service receives all the operation
    requests and, after verification of authority, forwards the requests to
    the plugins.</para>

    <figure pgwide="1">
      <title>Separation of clients and plugins</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.261in"
                     contentwidth="5.011in"
                     fileref="client-plugin-separation.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>This architecture makes it straightforward to use the OSGi security
    architecture to protect the different actors.</para>

    <section>
      <title>Principals</title>

      <para>The caller of the <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-String-int-"
      xrefstyle="hyperlink"/> method must have the Dmt Principal Permission
      with a target that matches the given principal. This Dmt Principal
      Permission is used to enforce that only trusted entities can act on
      behalf of remote managers.</para>

      <para>The Dmt Admin service must verify that all operations from a
      session with a principal can be executed on the given nodes using the
      available ACLs.</para>

      <para>The other two forms of the <code>getSession</code> method are
      meant for local management applications where no principal is available.
      No special permission is defined to restrict the usage of these methods.
      The callers that want to execute device management commands, however,
      need to have the appropriate Dmt Permissions.</para>
    </section>

    <section xml:id="i1662434">
      <title>Operational Permissions</title>

      <para>The operational security of a Local Manager and a remote manager
      is distinctly different. The distinction is made on the principal.
      Protocol Adapters should use the <code>getSession</code> method that
      takes an authenticated principal. Local Managers should not specify a
      principal.</para>

      <figure xml:id="i1613648">
        <title>Access control context, for Local Manager and Protocol Adapter
        operation</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.345in"
                       contentwidth="4.922in"
                       fileref="access-control-context.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Protocol Adapters</title>

      <para>A Protocol Adapter must provide a principal to the Dmt Admin
      service when it gets a session. It must use the <xref
      linkend="org.osgi.service.dmt.DmtAdmin.getSession-String-String-int-"
      xrefstyle="hyperlink"/> method. The Protocol Adapter must have Dmt
      Principal Permission for the given principal. The Dmt Admin service must
      then use this principal to determine the <emphasis>security
      scope</emphasis> of the given principal. This security scope is a set of
      permissions. How these permissions are found is not defined in this
      specification; they are usually in the management tree of a device. For
      example, the Mobile Specification stores these under the
      <code>$/Policy/Java/DmtPrincipalPermission</code> sub-tree.</para>

      <para>Additionally, a Dmt Session with a principal implies that the Dmt
      Admin service must verify the ACLs on the node for all
      operations.</para>

      <para>Any operation that is requested by a Protocol Adapter must be
      executed in a <code>doPrivileged</code> block that takes the principal's
      security scope. The <code>doPrivileged</code> block effectively hides
      the permissions of the Protocol Adapter; all operations must be
      performed under the security scope of the principal.</para>

      <para>The security check for a Protocol Adapter is therefore as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para>The operation method calls <code>doPrivileged</code> with the
          security scope of the principal.</para>
        </listitem>

        <listitem>
          <para>The operation is forwarded to the appropriate plugin. The
          underlying service must perform its normal security checks. For
          example, the Configuration Admin service must check for the
          appropriate Configuration Permission.</para>
        </listitem>
      </itemizedlist>

      <para>The Access Control context is shown in <xref linkend="i1613648"/>
      within the Protocol Adapter column.</para>

      <para>This principal-based security model allows for minimal permissions
      on the Protocol Adapter, because the Dmt Admin service performs a
      <code>doPrivileged</code> on behalf of the principal, inserting the
      permissions for the principal on the call stack. This model does not
      guard against malicious Protocol Adapters, though the Protocol Adapter
      must have the appropriate Dmt Principal Permission.</para>

      <para>The Protocol Adapter is responsible for the authentication of the
      principal. The Dmt Admin service must trust that the Protocol Adapter
      has correctly verified the identity of the other party. This
      specification does not address the type of authentication mechanisms
      that can be used. Once it has permission to use that principal, it can
      use any DMT command that is permitted for that principal at any
      time.</para>
    </section>

    <section>
      <title>Local Manager</title>

      <para>A Local Manager does not specify a principal. Security checks are
      therefore performed against the security scope of the Local Manager
      bundle, as shown in <xref linkend="i1613648"/> with the Local Manager
      stack. An operation is checked only with a Dmt Permission for the given
      node URI and operation. A thrown Security Exception must be passed
      unmodified to the caller of the operation method. The Dmt Admin service
      must not check the ACLs when no principal is set.</para>

      <para>A Local Manager, and all its callers, must therefore have
      sufficient permission to handle the DMT operations as well as the
      permissions required by the plugins when they proxy other services
      (which is likely an extensive set of Permissions).</para>
    </section>

    <section>
      <title>Plugin Security</title>

      <para>Plugins are required to hold the maximum security scope for any
      services they proxy. For example, the plugin that manages the
      Configuration Admin service must have
      <code>ConfigurationPermission("*","*")</code> to be effective.</para>

      <para>Plugins should not make <code>doPrivileged</code> calls, but
      should use the caller's context on the stack for permission
      checks.</para>
    </section>

    <section>
      <title>Events and Permissions</title>

      <para>Dmt Event Listener services must have the appropriate Dmt
      Permission to receive the event since this must be verified with the
      <code>hasPermission()</code> method on Bundle.</para>

      <para>The Dmt Event Listener services registered with a <xref
      linkend="org.osgi.service.dmt.DmtEventListener.FILTER_PRINCIPAL"
      xrefstyle="hyperlink"/> service property requires Dmt Principal
      Permission for the given principal. In this case, the principal must
      have <code>Get</code> access to see the nodes for the event. Any nodes
      that the listener does not have access to must be removed from the
      event.</para>

      <para>Plugins are not required to have access to the Event Admin
      service. If they send an event through the <xref
      linkend="org.osgi.service.dmt.spi.MountPoint" xrefstyle="hyperlink"/>
      interface then the Dmt Admin service must use a
      <code>doPrivileged</code> block to send the event to the Event Admin
      service.</para>
    </section>

    <section xml:id="i1919998">
      <title>Dmt Principal Permission</title>

      <para>Execution of the <code>getSession</code> methods of the Dmt Admin
      service featuring an explicit principal name is guarded by the Dmt
      Principal Permission. This permission must be granted only to Protocol
      Adapters that open Dmt Sessions on behalf of remote management
      servers.</para>

      <para>The <code>DmtPrincipalPermission</code> class does not have
      defined actions; it must always be created with a <code>*</code> to
      allow future extensions. The target is the principal name. A wildcard
      character is allowed at the end of the string to match a prefix.</para>

      <para>Example:</para>

      <programlisting>new DmtPrincipalPermission("com.acme.dep*","*" )</programlisting>
    </section>

    <section>
      <title>Dmt Permission</title>

      <para>The Dmt Permission controls access to management objects in the
      DMT. It is intended to control only the <emphasis>local</emphasis>
      access to the DMT. The Dmt Permission target string identifies the
      target node's URI (absolute path is required, starting with the
      <code>'./'</code> prefix) and the action field lists the management
      commands that are permitted on the node.</para>

      <para>The URI can end in a wildcard character <code>*</code> to indicate
      it is a prefix that must be matched. This comparison is string based so
      that node boundaries can be ignored.</para>

      <para>The following actions are defined:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.security.DmtPermission.ADD"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.security.DmtPermission.DELETE"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.security.DmtPermission.EXEC"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.security.DmtPermission.GET"
          xrefstyle="hyperlink"/></para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.dmt.security.DmtPermission.REPLACE"
          xrefstyle="hyperlink"/></para>
        </listitem>
      </itemizedlist>

      <para>For example, the following code creates a Dmt Permission for a
      bundle to add and replace nodes in any URI that starts with
      <code>./D</code>.</para>

      <programlisting>new DmtPermission("./D*", "Add,Replace")</programlisting>

      <para>This permission must imply the following permission:</para>

      <programlisting>new DmtPermission("./Dev/Operator/Name", "Replace")</programlisting>
    </section>

    <section>
      <title>Alert Permission</title>

      <para>The Alert Permission permits the holder of this permission to send
      a notification to a specific <emphasis>target principal</emphasis>. The
      target is identical to <xref linkend="i1919998"/>. No actions are
      defined for Alert Permission.</para>
    </section>

    <section>
      <title>Security Summary</title>

      <section>
        <title>Dmt Admin Service and Notification Service</title>

        <para>The Dmt Admin service is likely to require All Permission. This
        requirement is caused by the plugin model. Any permission required by
        any of the plugins must be granted to the Dmt Admin service. This set
        of permissions is large and hard to define. The following list shows
        the minimum permissions required if the plugin permissions are left
        out.</para>

        <programlisting>ServicePermission   ..DmtAdmin                            REGISTER
ServicePermission   ..NotificationService                 REGISTER
ServicePermission   ..DataPlugin                          GET
ServicePermission   ..ExecPlugin                          GET
ServicePermission   ..EventAdmin                          GET
ServicePermission   ..RemoteAlertSender                   GET
ServicePermission   ..DmtEventListener                    GET
DmtPermission       *                                     *
DmtPrincipalPermission *                                  *
PackagePermission   org.osgi.service.dmt                  EXPORTONLY
PackagePermission   org.osgi.service.dmt.spi              EXPORTONLY
PackagePermission   org.osgi.service.dmt.notification     EXPORTONLY
PackagePermission   org.osgi.service.dmt.notification.spi EXPORTONLY
PackagePermission   org.osgi.service.dmt.registry         EXPORTONLY
PackagePermission   org.osgi.service.dmt.security         EXPORTONLY</programlisting>
      </section>

      <section>
        <title>Dmt Event Listener Service</title>

        <programlisting>ServicePermission   ..DmtEventListener                    REGISTER
PackagePermission   org.osgi.service.dmt                  IMPORT</programlisting>

        <para>Dmt Event Listeners must have the appropriate
        <code>DmtPermission</code> to see the nodes in the events. If they are
        registered with a principal then they also need
        <code>DmtPrincipalPermission</code> for the given principals.</para>
      </section>

      <section>
        <title>Data and Exec Plugin</title>

        <programlisting>ServicePermission   ..NotificationService                 GET
ServicePermission   ..DataPlugin                          REGISTER
ServicePermission   ..ExecPlugin                          REGISTER
PackagePermission   org.osgi.service.dmt                  IMPORT
PackagePermission   org.osgi.service.dmt.notification     IMPORT
PackagePermission   org.osgi.service.dmt.spi              IMPORT
PackagePermission   org.osgi.service.dmt.security         IMPORT</programlisting>

        <para>The plugin is also required to have any permissions to call its
        underlying services.</para>
      </section>

      <section>
        <title>Local Manager</title>

        <programlisting>ServicePermission   ..DmtAdmin                            GET
PackagePermission   org.osgi.service.dmt                  IMPORT
PackagePermission   org.osgi.service.dmt.security         IMPORT
DmtPermission       &lt;scope&gt;                               ...</programlisting>

        <para>Additionally, the Local Manager requires all permissions that
        are needed by the plugins it addresses.</para>
      </section>

      <section>
        <title>Protocol Adapter</title>

        <para>The Protocol Adapter only requires Dmt Principal Permission for
        the instances that it is permitted to manage. The other permissions
        are taken from the security scope of the principal.</para>

        <programlisting>ServicePermission   ..DmtAdmin                            GET
ServicePermission   ..RemoteAlertSender                   REGISTER
PackagePermission   org.osgi.service.dmt                  IMPORT
PackagePermission   org.osgi.service.dmt.notification.spi IMPORT
PackagePermission   org.osgi.service.dmt.notification     IMPORT
DmtPrincipalPermission &lt;scope&gt;</programlisting>
      </section>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.dmt.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.dmt.spi.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.dmt.notification.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.dmt.notification.spi.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.dmt.security.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i2165260"><title>OMA DM-TND v1.2
      draft</title><biblioid class="uri"><link
      xlink:href="https://www.openmobilealliance.org/release/DM/V1_2-20050607-C/OMA-TS-DM-TND-V1_2-20050607-C.pdf"/></biblioid></bibliomixed>

      <bibliomixed><title>OMA DM-RepPro v1.2 draft:</title><biblioid
      class="uri"><link
      xlink:href="https://www.openmobilealliance.org/release/DM/V1_2-20050607-C/OMA-TS-DM-RepPro-V1_2-20050607-C.pdf"/></biblioid></bibliomixed>

      <bibliomixed><title>IETF RFC2578. Structure of Management
      Information</title>Version 2 (SMIv2)<?line-break ?><biblioid
      class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc2578.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1399261"><title>Java™ Management Extensions
      Instrumentation and Agent Specification v1.2, October
      2002,</title><biblioid class="uri"><link
      xlink:href="https://www.oracle.com/java/technologies/javase/javamanagement.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1399277"><title>JSR 9 - Federated Management
      Architecture (FMA) Specification</title>Version 1.0, January
      2000<?line-break ?><biblioid class="uri"><link
      xlink:href="https://www.jcp.org/en/jsr/detail?id=9"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1399342"><title>WBEM Profile Template,
      DSP1000</title>Status: Draft, Version 1.0 Preliminary, March 11,
      2004<?line-break ?><biblioid class="uri"><link
      xlink:href="https://www.dmtf.org/standards/wbem"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1399257"><title>SNMP</title><biblioid
      class="uri"><link
      xlink:href="http://www.wtcs.org/snmp4tpc/snmp_rfc.htm#rfc"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1418110"><title>RFC 2396 Uniform Resource
      Identifiers (URI): Generic Syntax</title><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc2396.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1662528"><title>MIME Media Types</title><biblioid
      class="uri"><link
      xlink:href="https://www.iana.org/assignments/media-types/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1869240"><title>RFC 3548 The Base16, Base32, and
      Base64 Data Encodings</title><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc3548.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1869214"><title>Secure Hash Algorithm
      1</title><biblioid class="uri"><link
      xlink:href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i2409502"><title>TR-069 CPE WAN Management Protocol
      (CWMP)</title>Customer Premises Equipment Wide Area Network Management
      Protocol (CWMP)<?line-break ?><biblioid class="uri"><link
      xlink:href="https://en.wikipedia.org/wiki/TR-069"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i2437549"><title>XML Schema Part 2: Datatypes
      Second Edition</title><biblioid class="uri"><link
      xlink:href="https://www.w3.org/TR/xmlschema-2/"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
