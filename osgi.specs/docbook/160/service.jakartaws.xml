<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->
<chapter label="160" revision="$Id$" version="5.0"
         xml:id="service.jakartaws" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Whiteboard Specification for Jakarta™ XML Web Services</title>

  <titleabbrev>Jakarta™ XML Web Services Whiteboard</titleabbrev>

  <info>
    <releaseinfo>
      <xref endterm="org.osgi.service.jakartaws.whiteboard-version"
            linkend="org.osgi.service.webservice.whiteboard"/>
    </releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>
    Web services are an important part in today's machine-to-machine communication. The <xref linkend="service.jakartaws-i21217577"/> (formerly known as JAX-WS) specification offers a vendor-neutral way of writing and using such services. 
    It defines a standard Java-to-WSDL mapping (see <xref linkend="service.jakartaws-wsdl"/>) which determines how web service operations are bound to Java methods when a SOAP message (see <xref linkend="service.jakartaws-soap-protocol"/>) invokes an action.
    </para>
    
    <para>
    The Jakarta™ XML Web Services specification provides a comprehensive model for SOAP-based web services. It supports both document-oriented and RPC-oriented operations, 
    handles SOAP 1.1 and SOAP 1.2 protocols, and provides a robust handler framework for message processing. 
    The specification defines key concepts such as <emphasis>Service Endpoints</emphasis>, which are the server-side components that process web service requests (see <xref linkend="service.jakartaws-endpoint"/>),
    and <emphasis>Handlers</emphasis>, which are processing units that can intercept and modify SOAP messages as they flow through the system (see <xref linkend="service.jakartaws-handler"/> and <xref linkend="service.jakartaws-handler-types"/>).
    These handlers can be chained together to form a <emphasis>handler chain</emphasis>, allowing for modular cross-cutting concerns such as security, logging, or message transformation.
    The order in which handlers process messages depends on the message direction, as described in <xref linkend="service.jakartaws-handler-execution"/>.
    </para>
    
    <para>
    This specification builds upon the concepts and terminology defined in the <xref linkend="service.jakartaws-i21217577"/>. 
    Users and implementors of this specification are expected to be familiar with the Jakarta™ XML Web Services specification, 
    as this whiteboard specification depends on those foundational concepts and does not redefine them.
    </para>
    
    <para>
    Managing endpoints in a dynamic way with integration to different listeners and transports can be a challenging task. This specification aims to make this task much easier using the well-known <xref linkend="service.jakartaws-whiteboard.pattern.ref" />
    and allow integration with existing transport specifications.
    
    Even though different transports are supported, the most common one is the HTTP transport and also the only one that is mandatory for a <xref linkend="service.jakartaws-i21217577"/> implementation.
    Therefore, this specification also focuses on the HTTP transport only and defines a way to interact with it. Implementations are free to support other kinds of transports as well.
    </para>

    <para>The Whiteboard Specification for Jakarta™ XML Web Services supports:</para>

    <itemizedlist>
      <listitem>
        <para>
            <emphasis>Registering Web Service Implementation</emphasis> - An implementation is an annotated "implementor" of the web service used by an endpoint. An "implementor" is published by an 
            Endpoint that handles the incoming and outgoing messages on the transport level.
        </para>
      </listitem>
      <listitem>
        <para><emphasis>Registering Handlers</emphasis> - A handler can intercept messages when they pass from/to Endpoints and perform actions on them.</para>
      </listitem>

    </itemizedlist>

    <para>Whiteboard Specification for Jakarta™ XML Web Services implementations must support
    at least version 4.0 of the Jakarta™ XML Web Services API and registering endpoints to the protocols provided by the used API implementation, which is HTTP as a minimum.</para>

    <section>
      <title>Entities</title>

      <para>This specification defines the following entities:</para>
      
      <itemizedlist>
        <listitem>
          <para><emphasis><xref linkend="service.jakartaws-handler"/></emphasis> - An object registered in the Service Registry
          responsible for filtering or inspection of messages while they flow through the web service processing.</para>
        </listitem>

        <listitem>
          <para><emphasis>Endpoint Implementor</emphasis> - An implementation that can be used to be registered as an <xref linkend="service.jakartaws-endpoint"/></para>
        </listitem>

        <listitem>
          <para><emphasis>Endpoint Registrar</emphasis> - An implementation that collects <emphasis>Handler</emphasis> and <emphasis>Endpoint Implementor</emphasis> instances and publishes them for a given transport</para>
        </listitem>

      </itemizedlist>
      
      <figure pgwide="1" xml:id="service.jakartaws.whiteboard-overview">
        <title>Jakarta™ XML Web Services Overview Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="3.313in"
                       contentwidth="5.496in" fileref="overall.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
   </section>

   <section xml:id="service.jakartaws.whiteboard">
    <title>Jakarta™ XML Web Services Whiteboard</title>

    <para>The Jakarta™ XML Web Services specification defines the programming model and APIs for web service endpoints and handlers, 
    but does not prescribe how these components should be discovered and managed in a dynamic environment. 
    In a traditional Jakarta EE application server, endpoints are typically deployed as part of a WAR file with static configuration.
    This static deployment model conflicts with OSGi's dynamic nature where bundles can be installed, started, stopped, and uninstalled at any time.</para>
    
    <para>While in a traditional web application the configuration is rather static and known in advance, in OSGi items can come and go anytime and code should be aware of this dynamism.
        Also, registration of listeners must happen before an endpoint is published, and only weak typing makes it hard to handle this correctly manually.
        As a result, the publishing of Web Services in the current state of the specification goes against the loose coupling concept usually provided by OSGi 
        as it requires knowledge about the stakeholders involved.
        </para>
        <para>
         It is therefore the responsibility of the Web Services Whiteboard to handle these cases in a transparent manner so the user can focus on the actual work and 
         use common dependency injection techniques like Declarative Services to inject dependencies.
         The whiteboard pattern allows endpoint implementors and handlers to be registered as OSGi services, and the whiteboard implementation automatically manages their lifecycle,
         publishing and unpublishing endpoints as services come and go.
         </para>
   </section>
   
   <section xml:id="service.jakartars.endpoint.services">
    <title>Registering Endpoint Implementor</title>

    <para>Endpoint Implementors can be registered with the Jakarta™ XML Web Services Whiteboard by registering them as Whiteboard
    services. This means that the endpoint POJO implementations are registered in the Service Registry. As Web Service Endpoints are
    POJOs, they may be registered using <emphasis>any</emphasis> valid service interface, including <code>Object</code>, and use any
    Jakarta™ XML Web Services annotations on the endpoint object, just as they would outside of OSGi. 
    The Jakarta™ XML Web Services specification defines annotations such as <code>@WebService</code>, <code>@WebMethod</code>, and <code>@WebParam</code> 
    to declare web service endpoints and their operations (see <xref linkend="service.jakartaws-i21217577"/> for details on these annotations).</para>

    <para>To be picked up as endpoints, the POJO must be registered with the
    <code>osgi.jakarta.xml.ws.endpoint.implementor</code> service property with a value of
    <code>"true"</code>. This property serves as a marker to the Jakarta™ XML Web Services Whiteboard
    runtime, indicating that this OSGi service should be further processed as an endpoint.</para>
    <para>Besides that, the property <code>osgi.jakarta.xml.ws.endpoint.address</code> can be specified as a way to indicate at what address an Endpoint should be published.
    If given, this must be passed to the <code>Endpoint.publish(String)</code> method as defined in the <xref linkend="service.jakartaws-endpoint-publish"/>. If it is not specified or is empty, it is assumed that
    there is some other property available to allow the Whiteboard runtime to derive the publishing address or context.
    In the scope of this specification, there is the <emphasis>osgi.jakarta.xml.ws.endpoint.http.contextpath</emphasis>
    property that defines that the endpoint should be published to the HTTP transport where <code>/</code> represents the root. What host or port is chosen is defined by the configuration of the implementation. 
    </para>

    <para>The code below shows a simple echo web service Endpoint Implementor. The <code>@WebService</code> and <code>@WebMethod</code> annotations are 
      Jakarta™ XML Web Services annotations that define the service interface and operations; these annotations are processed by the Jakarta™ XML Web Services runtime, not by the Whiteboard runtime.
      The Whiteboard runtime is only responsible for managing the lifecycle and registration of the endpoint:
    </para>

      <programlisting>@WebService
@WhiteboardEndpoint(address = "http://localhost/echo")
@Component(immediate = true, service = WSEcho.class, property = "wstype=echo")
public class WSEcho {

    @WebMethod(operationName = "echo", action = "echo")
    public String echo(@WebParam(name = "textIn") String text) {
        return text;
    }

}</programlisting>
    <para>
     There is no particular order in which Endpoint Implementors are published. They could be registered as soon as the service is visible in the OSGi service registry
     or even delayed in the background. If any particular ordering of publishing is desired, this must be synchronized externally, e.g., by observing the Runtime Service and waiting for a prerequisite
     endpoint to show up. Due to the dynamic nature of OSGi, most systems should be designed in a way that the exact point in time of publishing the endpoint is not required for the system to function correctly.
    </para>
   </section>
   
   <section xml:id="service.jakartaws.handler.services">
    <title>Registering Web Service Handlers</title>

    <para>Web Service Handlers can be registered with the Jakarta™ XML Web Services Whiteboard by registering them as Whiteboard
    services. This means that the handler POJO implementations are registered
    in the Service Registry. Handler Services must be registered using <emphasis>jakarta.xml.ws.handler.Handler</emphasis> 
    as the service interface but may implement any of the valid handler types defined by the Jakarta™ XML Web Services specification, 
    such as <code>SOAPHandler</code> or <code>LogicalHandler</code> (see <xref linkend="service.jakartaws-handler-types"/> for more information).
    Registering any invalid handler will result in an error for the matching endpoints.
    To be recognized by the whiteboard registrar, the service must be registered with a boolean property of 
    <emphasis>osgi.jakarta.xml.ws.handler.extension</emphasis> with a value of <emphasis>true</emphasis>.
    
    </para>

    <para>The code below shows an example of a logging handler that wants to intercept incoming and outgoing messages,
    this handler is targeted to any registered <emphasis>Endpoint Implementor</emphasis>:</para>

      <programlisting>@Component(service = Handler.class)
@XmlWsHandler()
public class SOAPLoggingHandler implements SOAPHandler&lt;SOAPMessageContext&gt; {

     public Set&lt;QName&gt; getHeaders() {
        return null;
    }

    public boolean handleMessage(SOAPMessageContext smc) {
         smc.getMessage().writeTo(System.out);
        return true;
    }

    public boolean handleFault(SOAPMessageContext smc) {
        smc.getMessage().writeTo(System.err);
        return true;
    }

    public void close(MessageContext messageContext) {
    }
    
}</programlisting>
<para>
 Handlers are assembled into a handler chain in service ranking order. This means that Handlers with a higher service ranking will be positioned before those with a lower service ranking in the chain.
 If two handlers have the same ranking they are sorted according to their service id, with handlers registered later being positioned later in the handler chain. 
</para>
<para>
 This handler chain is then passed to the Jakarta™ XML Web Services implementation. It is important to understand that the Jakarta™ XML Web Services runtime processes the handler chain differently depending on the message direction,
 as specified in <xref linkend="service.jakartaws-handler-execution"/>:
 <itemizedlist>
   <listitem>
     <para><emphasis>For outbound messages</emphasis>: Handler processing starts with the first handler in the chain and proceeds in the same order as the handler chain. This means the handler with the highest service ranking is processed first.</para>
   </listitem>
   <listitem>
     <para><emphasis>For inbound messages</emphasis>: The order of processing is reversed. Processing starts with the last handler in the chain and proceeds in the reverse order of the handler chain. This means the handler with the lowest service ranking is processed first.</para>
   </listitem>
 </itemizedlist>
</para>
<para>
 As a result, while handlers are assembled in order of service ranking (highest first), the actual processing order depends on the message direction. Users should be aware of this distinction to avoid confusion about handler execution order.
</para>
<para>
 It is also important to note that when different handler types are used (such as <code>LogicalHandler</code> and <code>SOAPHandler</code>), 
 each type executes as a group in different phases of message processing. This means that ordering cannot be controlled between handlers of different types, 
 as they run in separate processing phases. The detailed rules for handler ordering across different handler types are described in the 
 Jakarta™ XML Web Services specification (see <xref linkend="service.jakartaws-handler-ordering"/>).
</para>

<section xml:id="service.jakartaws.handler.execution.rationale">
<title>Understanding Handler Execution Order</title>

<para>
The Jakarta™ XML Web Services specification defines a specific handler execution model that may initially seem counterintuitive.
Understanding the rationale behind this design is important for correctly implementing handler chains, especially when working with
different Jakarta specifications that have different execution models.
</para>

<section>
<title>Jakarta™ XML Web Services Handler Execution Model</title>

<para>
As specified in <xref linkend="service.jakartaws-handler-execution"/>, the Jakarta™ XML Web Services handler execution follows these rules:
</para>

<itemizedlist>
  <listitem>
    <para><emphasis>Outbound messages</emphasis>: Handler processing starts with the first handler in the chain and proceeds in the same order as the handler chain.</para>
  </listitem>
  <listitem>
    <para><emphasis>Inbound messages</emphasis>: The order of processing is reversed - processing starts with the last handler in the chain and proceeds backwards.</para>
  </listitem>
</itemizedlist>

<para>
This bidirectional processing model is designed to support the layered nature of SOAP message processing. The key insight is that handlers
often work in complementary pairs during request and response processing. Consider these common use cases:
</para>

<orderedlist>
  <listitem>
    <para><emphasis>Security Processing</emphasis>: A security handler might encrypt or sign parts of an outbound SOAP message.
    On the inbound response, the same handler needs to decrypt or verify signatures. The reversed execution order ensures that
    the security handler that processed the outbound request is also the one that processes the corresponding inbound response,
    maintaining proper context and state.</para>
  </listitem>
  <listitem>
    <para><emphasis>Logging and Monitoring</emphasis>: A logging handler positioned early in the chain for outbound messages
    can log the original message before any transformations. For inbound messages, by being processed last (reversed order),
    it logs the final processed response. This creates a symmetrical logging pattern around the entire message flow.</para>
  </listitem>
  <listitem>
    <para><emphasis>Message Transformation</emphasis>: Protocol handlers (SOAPHandler) work at the SOAP message level and need
    to process messages before logical handlers (LogicalHandler) on outbound messages. On inbound messages, the reverse is needed -
    logical handlers should see the message after protocol-level processing is complete. The reversed execution naturally provides
    this layering.</para>
  </listitem>
</orderedlist>

<para>
This model creates a "tunnel" or "onion layer" pattern where each handler wraps the message processing, processing it on the way out
and unwrapping it on the way back in. This is particularly important for SOAP-based web services where message integrity,
security, and proper protocol layering are critical.
</para>

<para>
To illustrate this execution flow, consider a complete request-response cycle between a client and server, where both use a handler chain consisting of handlers A, B, and C (ordered by service ranking with A having the highest rank):
</para>

<figure pgwide="1" xml:id="service.jakartaws.handler-execution-flow">
  <title>Handler Execution Flow: Complete Request-Response Cycle</title>
  
  <mediaobject>
    <imageobject>
      <imagedata align="center" contentdepth="4.0in"
                 contentwidth="6.0in" fileref="handler-execution-flow.svg"/>
    </imageobject>
  </mediaobject>
</figure>

<para>
As shown in <xref linkend="service.jakartaws.handler-execution-flow"/>, the handler chain is traversed in different directions
depending on whether the message is inbound or outbound, and whether it is being processed on the client or server side.
This symmetric execution model ensures that complementary operations (such as encryption/decryption or signing/verification)
are performed by the same handler in the appropriate order.
</para>
</section>

<section>
<title>Comparison with Other Jakarta Specifications</title>

<para>
Understanding how Jakarta™ XML Web Services differs from other Jakarta specifications helps clarify the design rationale.
The key difference is that Jakarta XML Web Services uses a single handler type that processes both outbound and inbound messages,
requiring reversed execution for inbound processing. Other specifications use distinct components for request and response processing.
</para>

<section>
<title>Jakarta™ RESTful Web Services</title>

<para>
Jakarta™ RESTful Web Services (Jakarta REST) uses distinct filter types for requests and responses: <code>ContainerRequestFilter</code>
and <code>ContainerResponseFilter</code> (see <xref linkend="service.jakartaws-jakarta-restful-filters"/>). Each filter type has its own
priority ordering as defined in Section 6.5.1 "Priorities" (see <xref linkend="service.jakartaws-jakarta-restful-priorities"/>).
Since request and response are handled by separate filter types, there is no need for reversed execution - each can be ordered independently.
</para>

<para>
Similar to how Jakarta XML Web Services separates handlers into logical and SOAP handler types for different processing phases,
Jakarta REST uses <code>@PreMatching</code> annotations to divide filters into groups that execute at different stages of the
processing pipeline (see <xref linkend="service.jakartaws-jakarta-restful-pipeline"/>). However, the fundamental difference remains:
Jakarta REST filters can directly wrap the request/response objects, while Jakarta XML Web Services handlers work on a message-based
approach where the response message does not yet exist during outbound processing.
</para>
</section>

<section>
<title>Jakarta™ Servlet</title>

<para>
Jakarta™ Servlet filters (see <xref linkend="service.jakartaws-jakarta-servlet-spec"/>) provide another comparison point.
A servlet filter is called once and processes both request and response in a single invocation by wrapping them.
The filter chain executes in declaration order for request processing, and automatically reverses for response processing
because each filter wraps the next filter in the chain (see <xref linkend="service.jakartaws-jakarta-servlet-filters"/>).
This is conceptually similar to Jakarta XML Web Services' reversed execution, but achieved through the wrapping pattern
rather than explicit handler chain reversal. The difference is that servlet filters can wrap request and response objects
directly, whereas Jakarta XML Web Services handlers must work with messages where the response is not yet available during
outbound processing.
</para>
</section>

<para>
This specification follows the Jakarta™ XML Web Services execution model as defined in
<xref linkend="service.jakartaws-handler-execution"/>. When working across multiple Jakarta specifications, developers should
understand these execution model differences to avoid incorrect assumptions about handler or filter ordering.
</para>
</section>
</section>

</section>
    <section xml:id="service.jakartaws.handler.services.target">
         <title>Targeting specific Endpoint Implementor</title>
         <para>
         If a handler wants to target a specific <emphasis>Endpoint Implementor</emphasis> it can specify the <emphasis>osgi.jakarta.xml.ws.handler.filter</emphasis> service properties
         and will only be installed for such <emphasis>Endpoint Implementor</emphasis> that match the provided filter.
         </para>
             <para>The previous example targeting an <emphasis>Endpoint Implementor</emphasis> registered with a <emphasis>wstype</emphasis> property of <emphasis>echo</emphasis> looks like this:</para>

      <programlisting>@Component(service = Handler.class)
@XmlWsHandler(filter="(wstype=echo)")
public class SOAPLoggingHandler implements SOAPHandler&lt;SOAPMessageContext&gt; {

       ... like before ...
}</programlisting>
     </section>
    </section>
    <section>
        <title>Jakarta™ XML Web Services Whiteboard Implementation</title>
        <para>
            The Jakarta™ XML Web Services Whiteboard implementation is responsible for:
            <itemizedlist>
                <listitem>
                     <para>Tracking any service registered with a service property <emphasis>osgi.jakarta.xml.ws.endpoint.implementor</emphasis> 
                     with the value <emphasis>true</emphasis> and registering an <emphasis>Endpoint</emphasis> with a transport.
                     An implementation might use different techniques to discover a suitable transport and support for different protocols, but at least the publishing using
                     the default endpoint publish as described in the Jakarta™ XML Web Services specification must be supported (see <xref linkend="service.jakartaws-endpoint-publish"/>). 
                     In addition to that, implementations are encouraged to also support publishing to the Http Whiteboard Service (see <xref linkend="service.servlet"/>) using the property <emphasis>osgi.jakarta.xml.ws.endpoint.http.contextpath</emphasis>
                     as described in <emphasis>Registering Endpoint Implementor</emphasis>.
                     </para>
                </listitem>
                <listitem>
                     <para>Tracking all registered <emphasis>jakarta.xml.ws.handler.Handler</emphasis> services with the service property <emphasis>osgi.jakarta.xml.ws.handler.extension</emphasis> 
                     with the value <emphasis>true</emphasis> and attaching them to the target Implementor's <emphasis>Endpoint</emphasis>.</para>
                </listitem>
                <listitem>
                     <para>Publishing a <emphasis>WebserviceServiceRuntime</emphasis> service to the OSGi service registry so interested parties can query the current state.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            As <emphasis>Endpoint</emphasis> instances can only be registered once with a transport and after publishing cannot change their handler chain, special care must be taken when Endpoints are created and published.
            Because of this, an <emphasis>Endpoint Registrar</emphasis> must ensure that each Endpoint will be refreshed when the Implementor or any Handler changes, which possibly leads to the transport not serving requests for a short amount of time.
        </para>
        <section>
            <title>The WebserviceServiceRuntime</title>
             <para>The <xref
                  linkend="org.osgi.service.webservice.runtime.WebserviceServiceRuntime" xrefstyle="hyperlink"/> service represents the runtime state information
                  of a Jakarta XML Web Services Whiteboard instance. This information is provided through Data Transfer Objects (DTOs). The architecture of
                  OSGi DTOs is described in <xref linkend="intro.core.release" xrefstyle="template:%t"/>.</para>
            <para>The <code>WebserviceServiceRuntime</code> provides service registration properties to describe its underlying Jakarta XML Web
                      Services Whiteboard. These service properties can include implementation-specific key-value pairs.
                      They also include the following:</para>

      <table pgwide="1">
        <title>Service properties for the <code>WebserviceServiceRuntime</code> service</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1.9*"/>

          <colspec colnum="2" colwidth="0.7*"/>

          <colspec colnum="3" colwidth="4.2*"/>

          <thead>
            <row>
              <entry>Service Property Name</entry>

              <entry>Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>service.changecount</code></entry>
              <entry><code>Long</code></entry>
              <entry><para>Whenever the DTOs available from the WebserviceServiceRuntime service change, the value
              of this property will increase.</para> <para>This allows
              interested parties to be notified of changes to the DTOs by
              observing Service Events of type <code>MODIFIED</code> for the
              <xref linkend="org.osgi.service.webservice.runtime.WebserviceServiceRuntime"
              xrefstyle="hyperlink"/> service. See <code>org.osgi.framework.Constants.SERVICE_CHANGECOUNT</code> in <xref linkend="intro.core.release" xrefstyle="template:%t"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
        </section>
        <section>
            <title>WebserviceServiceRuntime DTOs</title>
            <para>
                The <xref linkend="org.osgi.service.webservice.runtime.WebserviceServiceRuntime.getRuntimeDTO--" xrefstyle="hyperlink"/> method allows access to the 
                <xref linkend="org.osgi.service.webservice.runtime.dto.RuntimeDTO" xrefstyle="hyperlink" /> that provides a snapshot of the current state of the runtime to gather information about
                <itemizedlist>
                  <listitem>
                    <para>
                     Currently successfully published <xref linkend="org.osgi.service.webservice.runtime.dto.RuntimeDTO.endpoints" xrefstyle="hyperlink" /> or 
                     <xref linkend="org.osgi.service.webservice.runtime.dto.RuntimeDTO.failedEndpoints" xrefstyle="hyperlink" />.
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                     Currently successfully bound <xref linkend="org.osgi.service.webservice.runtime.dto.RuntimeDTO.handlers" xrefstyle="hyperlink" /> as well as
                     <xref linkend="org.osgi.service.webservice.runtime.dto.RuntimeDTO.failedHandlers" xrefstyle="hyperlink" /> that do not match any endpoint.
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                     The <xref linkend="org.osgi.service.webservice.runtime.dto.RuntimeDTO.serviceReference" xrefstyle="hyperlink" /> of the runtime itself.
                    </para>
                  </listitem>
                </itemizedlist>
            </para>
            <para>
               The <xref linkend="org.osgi.service.webservice.runtime.dto.EndpointDTO" xrefstyle="hyperlink" /> provides the following information:
               <itemizedlist>
                  <listitem>
                    <para>
                     The full <xref linkend="org.osgi.service.webservice.runtime.dto.EndpointDTO.address" xrefstyle="hyperlink" /> where this endpoint was
                     published. Depending on the used endpoint transport, this might differ from the value given in the endpoint registration, e.g., if the value is relative to some base directory or was transformed
                     according to rules determined by the implementation (e.g., using a load balancer or URL rewriting).
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                     Currently bound <xref linkend="org.osgi.service.webservice.runtime.dto.EndpointDTO.handlers" xrefstyle="hyperlink" /> that matched the endpoint.
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                     The <xref linkend="org.osgi.service.webservice.runtime.dto.EndpointDTO.implementor" xrefstyle="hyperlink" /> service reference of the endpoint
                     that can be used to gather further properties.
                    </para>
                  </listitem>
               </itemizedlist>
            </para>
            <para>
               The <xref linkend="org.osgi.service.webservice.runtime.dto.FailedDTO" xrefstyle="hyperlink" /> is the base class for the <xref linkend="org.osgi.service.webservice.runtime.dto.FailedEndpointDTO" xrefstyle="hyperlink" />
               and <xref linkend="org.osgi.service.webservice.runtime.dto.FailedEndpointDTO" xrefstyle="hyperlink" /> and provides basic information about a failure:
               <itemizedlist>
                  <listitem>
                    <para>
                     A <xref linkend="org.osgi.service.webservice.runtime.dto.FailedDTO.failureCode" xrefstyle="hyperlink" /> that describes
                     the nature of the failure, see <xref linkend="JaxWsWhiteboardErrorHandling"  xrefstyle="hyperlink"/> for possible values.
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                     A <xref linkend="org.osgi.service.webservice.runtime.dto.FailedDTO.failureMessage" xrefstyle="hyperlink" /> that can contain
                     further details. The content of this field is not specified and might be <code>null</code>.
                    </para>
                  </listitem>
               </itemizedlist>
            </para>
            <para>
               The <xref linkend="org.osgi.service.webservice.runtime.dto.FailedEndpointDTO" xrefstyle="hyperlink" /> extends the
               <xref linkend="org.osgi.service.webservice.runtime.dto.FailedDTO" xrefstyle="hyperlink" /> with additional information specific to endpoints:
               <itemizedlist>
                  <listitem>
                    <para>
                     The service reference of the <xref linkend="org.osgi.service.webservice.runtime.dto.FailedEndpointDTO.implementor" xrefstyle="hyperlink" /> that describes
                     failed to be published as an endpoint.
                    </para>
                  </listitem>
               </itemizedlist>
            </para>
           <para>
               The <xref linkend="org.osgi.service.webservice.runtime.dto.FailedHandlerDTO" xrefstyle="hyperlink" /> extends the
               <xref linkend="org.osgi.service.webservice.runtime.dto.FailedDTO" xrefstyle="hyperlink" /> with additional information specific to handlers:
               <itemizedlist>
                  <listitem>
                    <para>
                     The <xref linkend="org.osgi.service.webservice.runtime.dto.FailedHandlerDTO.serviceReference" xrefstyle="hyperlink" /> 
                     to the handler that failed.
                    </para>
                  </listitem>
               </itemizedlist>
            </para>
        </section>
        <section xreflabel="Whiteboard Error Handling" xml:id="JaxWsWhiteboardErrorHandling">
            <title>Whiteboard Error Handling</title>
        
            <para>
            There are a number of error cases where the Jakarta Web Service
            whiteboard may be unable to correctly register an endpoint or use a given handler.
            All of these cases must result in a failure DTO being created with the
            appropriate error code.
            </para>
            <section>
                <title>General Error Codes</title>
                <itemizedlist>
                  <!-- generic error codes -->    
                  <listitem>
                    <para>
                    <emphasis>Unknown Failure</emphasis> - Outside of the predefined error conditions, there might still be errors occurring during the construction of the objects.
                    The implementation can use the error code <code><xref linkend="org.osgi.service.webservice.runtime.dto.FailedDTO.FAILURE_REASON_UNKNOWN" xrefstyle="hyperlink"/></code> to indicate that.
                    The implementation can use its own error codes, but to prevent clash with codes specified in later specification versions, such an error code must
                    be equal to or larger than <code>1000</code>.
                    In all cases, an additional error message might be used to further describe the nature of the failure and give users of the DTO a hint what's going on.
                    </para>
                  </listitem>
                  <listitem>
                    <para><emphasis>Failure to obtain a service instance</emphasis> - In
                    the case where a published service is unable to be obtained by the
                    Jakarta Web Service whiteboard, then the service is deny-listed by the container. A failure DTO is made available from the
                    WebserviceServiceRuntime representing the deny-listed service
                    object. The error code in this case is <code><xref linkend="org.osgi.service.webservice.runtime.dto.FailedDTO.FAILURE_REASON_SERVICE_NOT_GETTABLE" xrefstyle="hyperlink"/></code>.</para>
                  </listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Handler Error Codes</title>
                <itemizedlist>
                  <listitem>
                    <para><emphasis>No matching endpoints</emphasis> - If a handler is currently not matching any Endpoint Implementor, it is considered failed as it cannot
                    perform its work. The error code in this case is <code><xref linkend="org.osgi.service.webservice.runtime.dto.FailedHandlerDTO.FAILURE_REASON_NO_MATCHING_ENDPOINT" xrefstyle="hyperlink"/></code>.
                    </para>
                  </listitem>
                   <listitem>
                    <para><emphasis>Invalid filter</emphasis> - If a handler specifies an invalid filter, it is considered failed as it cannot be decided if a handler matches or not.
                    The error code in this case is <code><xref linkend="org.osgi.service.webservice.runtime.dto.FailedHandlerDTO.FAILURE_REASON_INVALID_FILTER" xrefstyle="hyperlink"/></code> and the message should include the parsing error.
                    </para>
                  </listitem>
                </itemizedlist>
            </section>
             <section>
                <title>Endpoint Implementor Error Codes</title>
                <itemizedlist>
                  <listitem>
                    <para><emphasis>Endpoint creation failed</emphasis> - An implementation needs to transform the Implementor into a Web Service Endpoint. This endpoint can then be further published
                    with the Jakarta™ XML Web Services API. If this transformation fails, then the Endpoint is considered failed as no further handling is possible.
                    The error code in this case is <code><xref linkend="org.osgi.service.webservice.runtime.dto.FailedEndpointDTO.FAILURE_REASON_CREATE_FAILED" xrefstyle="hyperlink"/></code>.
                    </para>
                  </listitem>
                  <listitem>
                    <para><emphasis>Setting handlers not supported</emphasis> - If there are any matching handlers but setting Handlers for the created Web Service Endpoint is not supported,
                    then the Endpoint is considered failed.
                    The error code in this case is <code><xref linkend="org.osgi.service.webservice.runtime.dto.FailedEndpointDTO.FAILURE_REASON_SET_HANDLER_NOT_SUPPORTED" xrefstyle="hyperlink"/></code>.
                    </para>
                  </listitem>
                     <listitem>
                    <para><emphasis>Setting handlers failed</emphasis> - If there are any matching handlers but using them for the created Web Service Endpoint failed, for example because they are incompatible,
                    then the Endpoint is considered failed.
                    The error code in this case is <code><xref linkend="org.osgi.service.webservice.runtime.dto.FailedEndpointDTO.FAILURE_REASON_SET_HANDLER_FAILED" xrefstyle="hyperlink"/></code>.
                    </para>
                  </listitem>
                  <listitem>
                    <para><emphasis>Publishing failed</emphasis> - After creation and setup of handlers, an Endpoint is finally published with a transport. If this fails,
                    then the Endpoint is considered failed.
                    The error code in this case is <code><xref linkend="org.osgi.service.webservice.runtime.dto.FailedEndpointDTO.FAILURE_REASON_PUBLISH_FAILED" xrefstyle="hyperlink"/></code>.
                    </para>
                  </listitem>
                </itemizedlist>
            </section>
          </section>
                
  <section>
    <title>Capabilities</title>

    <section>
      <title>osgi.implementation Capability</title>

      <para>The Jakarta™ XML Web Services Whiteboard Implementation bundle must provide the <link
      linkend="service.namespaces-osgi.implementation.namespace"><code>osgi.implementation</code></link>
      capability with the name <xref
      linkend="org.osgi.service.webservice.whiteboard.WebserviceWhiteboardConstants.WEBSERVICE_IMPLEMENTATION"
      xrefstyle="hyperlink"/>. This capability can be used by provisioning
      tools and during resolution to ensure that a Web Services Whiteboard implementation
      is present. The capability must also declare a uses constraint for the
      <code>org.osgi.service.webservice</code> package and provide the version
      of this specification:</para>

      <programlisting>Provide-Capability: osgi.implementation;
 osgi.implementation=osgi.webservice";
 uses:="jakarta.xml.ws.handler,jakarta.xml.ws";
 version:Version="<xref endterm="org.osgi.service.webservice-version.number"
          linkend="org.osgi.service.webservice"/>"</programlisting>

      <para>The <xref
      linkend="org.osgi.service.webservice.whiteboard.annotations.RequireWebserviceWhiteboard"
      xrefstyle="hyperlink"/> annotation can be used to require this
      capability.</para>

      <para>This capability must follow the rules defined for the <xref
      linkend="service.namespaces-osgi.implementation.namespace"/>.</para>
    </section>

    <section>
      <title>osgi.service Capability</title>

      <para>The bundle providing the Jakarta™ XML Web Services Whiteboard service must provide
      capabilities in the <link
      linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
      namespace representing the Runtime Service it is required to register. This
      capability must also declare uses constraints for the relevant service
      packages:</para>

      <programlisting>Provide-Capability: osgi.service;
 objectClass:List&lt;String&gt;="org.osgi.service.webservice.runtime.WebserviceServiceRuntime";
 uses:="org.osgi.service.webservice.runtime,org.osgi.service.webservice.runtime.dto"</programlisting>

      <para>This capability must follow the rules defined for the <xref
      linkend="service.namespaces-osgi.service.namespace"/>.</para>
    </section>
  </section>
  
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.webservice.runtime.xml"/>
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.webservice.runtime.dto.xml"/>
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.webservice.whiteboard.xml"/>
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.webservice.whiteboard.annotations.xml"/>
  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.webservice.whiteboard.propertytypes.xml"/>
  
  <section>
    <title>References</title>


    <bibliolist>
      <bibliomixed xml:id="service.jakartaws-i21217577">
        <title>Jakarta™ XML Web Services Specification</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/xml-web-services/4.0/jakarta-xml-ws-spec-4.0.html"/>
        </biblioid>
      </bibliomixed>
      
      <bibliomixed xml:id="service.jakartaws-handler">
        <title>Handler</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/xml-web-services/4.0/apidocs/jakarta.xml.ws/jakarta/xml/ws/handler/handler"/>
        </biblioid>
      </bibliomixed>
      
      <bibliomixed xml:id="service.jakartaws-endpoint">
        <title>Endpoint</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/xml-web-services/4.0/apidocs/jakarta.xml.ws/jakarta/xml/ws/endpoint"/>
        </biblioid>
      </bibliomixed>
      
      <bibliomixed xml:id="service.jakartaws-handler-execution">
        <title>Jakarta™ XML Web Services Handler Execution</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/xml-web-services/4.0/jakarta-xml-ws-spec-4.0#handlerexecution"/>
        </biblioid>
      </bibliomixed>
      
      <bibliomixed xml:id="service.jakartaws-handler-ordering">
        <title>Jakarta™ XML Web Services Handler Ordering</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/xml-web-services/4.0/jakarta-xml-ws-spec-4.0#handlerordering"/>
        </biblioid>
      </bibliomixed>
      
      <bibliomixed xml:id="service.jakartaws-endpoint-publish">
        <title>Jakarta™ XML Web Services Endpoint Publishing</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/xml-web-services/4.0/apidocs/jakarta.xml.ws/jakarta/xml/ws/endpoint#publish(java.lang.String)"/>
        </biblioid>
      </bibliomixed>
      
      <bibliomixed xml:id="service.jakartaws-handler-types">
        <title>Jakarta™ XML Web Services Handler Types</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/xml-web-services/4.0/jakarta-xml-ws-spec-4.0#handlerframework"/>
        </biblioid>
      </bibliomixed>
      
      <bibliomixed xml:id="service.jakartaws-soap-protocol">
        <title>SOAP Protocol</title>

        <biblioid class="uri">
          <link xlink:href="https://www.w3.org/TR/soap/"/>
        </biblioid>
      </bibliomixed>
      
      <bibliomixed xml:id="service.jakartaws-wsdl">
        <title>Web Services Description Language (WSDL)</title>

        <biblioid class="uri">
          <link xlink:href="https://www.w3.org/TR/wsdl20/"/>
        </biblioid>
      </bibliomixed>
      
      

      <bibliomixed xml:id="service.jakartaws-portable.java.contracts.ref">
        <title>Portable Java Contract Definitions</title>

        <biblioid class="uri">
          <link xlink:href="https://docs.osgi.org/reference/portable-java-contracts.html"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-whiteboard.pattern.ref">
        <title>Whiteboard Pattern</title>

        <biblioid class="uri">
          <link xlink:href="https://docs.osgi.org/whitepaper/whiteboard-pattern/"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-iana.media.types">
        <title>IANA Media Type Registrations</title>

        <biblioid class="uri">
          <link xlink:href="https://www.iana.org/assignments/media-types/media-types.xhtml"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-iana.media.type.suffixes">
        <title>IANA Media Type Suffix Registrations</title>

        <biblioid class="uri">
          <link xlink:href="https://www.iana.org/assignments/media-type-structured-suffix/media-type-structured-suffix.xhtml"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-jakarta-restful-spec">
        <title>Jakarta™ RESTful Web Services Specification</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/restful-ws/4.0/jakarta-restful-ws-spec-4.0.html"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-jakarta-restful-priorities">
        <title>Jakarta™ RESTful Web Services Priorities</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/restful-ws/4.0/jakarta-restful-ws-spec-4.0.html#priorities"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-jakarta-restful-filters">
        <title>Jakarta™ RESTful Web Services Filters</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/restful-ws/4.0/jakarta-restful-ws-spec-4.0.html#introduction_filters"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-jakarta-restful-pipeline">
        <title>Jakarta™ RESTful Web Services Processing Pipeline</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/restful-ws/4.0/jakarta-restful-ws-spec-4.0.html#processing_pipeline"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-jakarta-servlet-spec">
        <title>Jakarta™ Servlet Specification</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/servlet/6.1/jakarta-servlet-spec-6.1.html"/>
        </biblioid>
      </bibliomixed>

      <bibliomixed xml:id="service.jakartaws-jakarta-servlet-filters">
        <title>Jakarta™ Servlet Filter Chain</title>

        <biblioid class="uri">
          <link xlink:href="https://jakarta.ee/specifications/servlet/6.1/jakarta-servlet-spec-6.1.html#filter-chain"/>
        </biblioid>
      </bibliomixed>

    </bibliolist>
  </section>
</section>
</chapter>
