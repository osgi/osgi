<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->
<chapter label="151"
         revision="$Id$"
         version="5.0" xml:id="service.jakartars"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Jakarta RESTful Web Services Whiteboard Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.jakartars.whiteboard-version"
    linkend="org.osgi.service.jakartars.whiteboard"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>REpresentational State Transfer (REST) is a simple pattern for
    producing Web Services. RESTful services use URI pattern matching to match
    a particular web resource. Different HTTP verbs, for example
    <code>GET</code> and <code>DELETE</code>, map to different operations on
    that resource. Standard HTTP response codes are used to communicate the
    result of an operation, potentially including a response body if the
    operation returns a result.</para>

    <para>The <xref linkend="service.jakartars-i21217577"/> defines a set of
    annotation mappings which allow Plain Old Java Objects (POJOs) to be
    directly exposed as RESTful web resources; these resources can also be
    grouped together using a Jakarta RESTful Web Services <code>Application</code>. Furthermore the
    specification defines a plugable model for extending the behavior of the
    application and the features of the Jakarta RESTful Web Services container itself. For example
    an extension may define specific error responses that should be sent when
    particular exceptions occur, or an extension may add support for
    serializing responses to a different format. The OSGi Jakarta RESTful Web Services Whiteboard
    Specification provides a light and convenient way of using these POJOs,
    applications and extensions in an OSGi environment through the use of the
    <xref linkend="service.jakartars-whiteboard.pattern.ref"/>.</para>

    <para>The Jakarta RESTful Web Services Whiteboard specification supports:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Registering Resources</emphasis> - Registering a
        Jakarta RESTful Web Services annotated POJO in the Service Registry makes it available to be
        bound to an endpoint and to start responding to incoming
        requests.</para>
      </listitem>

      <listitem>
        <para><emphasis>Registering Applications</emphasis> - Registering a
        Jakarta RESTful Web Services <code>Application</code> in the Service Registry makes it
        available to be bound to an endpoint and to start responding to
        incoming requests.</para>
      </listitem>

      <listitem>
        <para><emphasis>Registering Extensions</emphasis> - The Jakarta RESTful Web Services
        specification defines a variety of plugable extensions. These
        extensions can be registered in the Service Registry to include them
        in the handling pipeline.</para>
      </listitem>

      <listitem>
        <para><emphasis>Requiring Extensions</emphasis> - Sometimes Jakarta RESTful Web Services
        resources, or even Jakarta RESTful Web Services extensions, depend upon the presence of
        another extension. For example a Jakarta RESTful Web Services resource and
        exception mapper may both depend on a JSON serializer. Jakarta RESTful Web Services
        Whiteboard services may define preconditions that must be satisfied
        before they can be bound.</para>
      </listitem>
    </itemizedlist>

    <para>Jakarta RESTful Web Services Whiteboard implementations must support at least version 3.0
    of the Jakarta RESTful Web Services API.</para>

    <section>
      <title>Entities</title>

      <para>This specification defines the following entities:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Jakarta RESTful Web Services Whiteboard service</emphasis> - An object
          registered in the Service Registry providing the necessary
          Whiteboard service properties defined by this specification.
          Whiteboard services may be <emphasis>resource</emphasis>,
          <emphasis>application</emphasis> or <emphasis>extension</emphasis>
          services</para>
        </listitem>

        <listitem>
          <para><emphasis>Jakarta RESTful Web Services Whiteboard implementation</emphasis> - An
          implementation that provides one or more Jakarta RESTful Web Services Whiteboards.</para>
        </listitem>

        <listitem>
          <para><emphasis>Jakarta RESTful Web Services Whiteboard</emphasis> - A runtime instance
          that processes Jakarta RESTful Web Services Whiteboard services. Each Jakarta RESTful Web Services Whiteboard
          service may be processed by multiple Jakarta RESTful Web Services Whiteboards. Different
          Jakarta RESTful Web Services Whiteboards provided by the same Jakarta RESTful Web Services Whiteboard
          implementation may configured differently, for example using
          different ports or root contexts.</para>
        </listitem>

        <listitem>
          <para><emphasis>Jakarta RESTful Web Services Service Runtime service</emphasis> - A
          service providing runtime introspection into a Jakarta RESTful Web Services Whiteboard
          instance.</para>
        </listitem>

        <listitem>
          <para><emphasis>Jakarta RESTful Web Services Resource Service</emphasis> - A service that
          provides one or more RESTful resource methods which map to incoming
          HTTP requests.</para>
        </listitem>

        <listitem>
          <para><emphasis>Jakarta RESTful Web Services Application Service</emphasis> - A service
          that provides a <code>jakarta.ws.rs.core.Application</code> to be
          hosted by a Jakarta RESTful Web Services Whiteboard.</para>
        </listitem>

        <listitem>
          <para><emphasis>Jakarta RESTful Web Services Extension Service</emphasis> - A service that
          extends the functionality of a Jakarta RESTful Web Services Whiteboard.</para>
        </listitem>

        <listitem>
          <para><emphasis>Static Resources</emphasis> - Jakarta RESTful Web Services resources that
          are included programmatically in a Jakarta RESTful Web Services Whiteboard application,
          rather than being added at runtime by the whiteboard.</para>
        </listitem>
      </itemizedlist>

      <figure pgwide="1" xml:id="service.jakartars.whiteboard-overview">
        <title>Jakarta RESTful Web Services Whiteboard Overview Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="3.313in"
                       contentwidth="5.496in" fileref="overall.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <xref linkend="service.jakartars.whiteboard-overview"/> shows an
      OSGi framework running a Jakarta RESTful Web Services Whiteboard Implementation bundle. This
      bundle has been configured to provide two Jakarta RESTful Web Services whiteboards, each of
      which has a corresponding Jakarta RESTful Web Services Service Runtime Service. The various
      Jakarta RESTful Web Services Whiteboard services available in the framework are discovered and
      processed by both whiteboards.</para>
    </section>
  </section>

  <section xml:id="service.jakartars.whiteboard">
    <title>The Jakarta RESTful Web Services Whiteboard</title>

    <para>An important principle of the Jakarta RESTful Web Services Whiteboard specification is
    that an OSGi framework may contain many active Jakarta RESTful Web Services Whiteboards at any
    time, even if there is only a single Jakarta RESTful Web Services Whiteboard implementation
    present in the framework. In addition to providing a web endpoint with
    which to register Whiteboard services, a Jakarta RESTful Web Services Whiteboard provides a
    holder for Jakarta RESTful Web Services Applications.</para>

    <para>All Jakarta RESTful Web Services Whiteboards have a <code>default</code> application which
    is used to register resources that do not target an existing application.
    In this respect a Jakarta RESTful Web Services whiteboard application shares some similarities
    with a Servlet Context in the <xref linkend="service.http.whiteboard"/>.
    Resources registered with a Jakarta RESTful Web Services Whiteboard are always registered as
    part of an application. The generated name of the default application is
    <code>.default</code>, and it is mapped to the root context of the Jakarta RESTful Web Services
    Whiteboard.</para>

    <para>A Jakarta RESTful Web Services Whiteboard implementation must create a Jakarta RESTful Web Services Whiteboard
    instance, however it is expected that most implementations will permit
    multiple Jakarta RESTful Web Services whiteboards to be configured. These instances may differ
    significantly, or may simply offer the same capabilities on a different
    port.</para>

    <para>For details on the association process between Jakarta RESTful Web Services Whiteboard
    services and a Jakarta RESTful Web Services Whiteboard see <xref
    linkend="service.http.whiteboard.common.properties"/>.</para>

    <section>
      <title>The Jakarta RESTful Web Services Service Runtime Service</title>

      <para>The <xref
      linkend="org.osgi.service.jakartars.runtime.JakartarsServiceRuntime"
      xrefstyle="hyperlink"/> service represents the runtime state information
      of a Jakarta RESTful Web Services Whiteboard instance. This information is provided through
      Data Transfer Objects (DTOs). The architecture of OSGi DTOs is described
      in <xref linkend="intro.core.release" xrefstyle="template:%t"/>.</para>

      <para>Each Jakarta RESTful Web Services Whiteboard implementation registers exactly one
      <code>JakartarsServiceRuntime</code> service per Jakarta RESTful Web Services Whiteboard. The
      service properties of the Jakarta RESTful Web Services Service Runtime Service can be used to
      target Jakarta RESTful Web Services Whiteboard services at specific Jakarta RESTful Web Services whiteboards, as
      described by the <code>osgi.jakartars.whiteboard.target</code> property in
      <xref linkend="service.jakartars.common.properties"/>.</para>

      <para>The <code>JakartarsServiceRuntime</code> provides service registration
      properties to declare its underlying Jakarta RESTful Web Services Whiteboard. These service
      properties can include implementation-specific key-value pairs. They
      also include the following:</para>

      <table pgwide="1">
        <title>Service properties for the <code>JakartarsServiceRuntime</code>
        service</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1.9*"/>

          <colspec colnum="2" colwidth="0.7*"/>

          <colspec colnum="3" colwidth="4.2*"/>

          <thead>
            <row>
              <entry>Service Property Name</entry>

              <entry>Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>osgi.jakartars.endpoint</code></entry>

              <entry><code>String+</code></entry>

              <entry><para> Endpoint(s) where this Jakarta RESTful Web Services Whiteboard is
              listening. Registered Whiteboard services are made available
              here. Values could be provided as URLs e.g.
              <code>http://192.168.1.10:8080/</code> or relative paths, e.g.
              <code>/myapp/</code>. Relative paths may be used if the scheme
              and authority parts of the URLs are not known, for example if
              the Jakarta RESTful Web Services Whiteboard is delegating to a bridged Http Service
              implementation. If the Jakarta RESTful Web Services Whiteboard Service is serving the
              root context and scheme and authority are not known, the value
              of the property is <code>/</code>. Each entry must end with a
              slash.</para><para>See <xref
              linkend="org.osgi.service.jakartars.runtime.JakartarsServiceRuntimeConstants.JAKARTA_RS_SERVICE_ENDPOINT"
              xrefstyle="hyperlink"/>.</para></entry>
            </row>

            <row>
              <entry><code>service.changecount</code></entry>

              <entry><code>Long</code></entry>

              <entry><para>Whenever the DTOs available from the Jakarta RESTful Web Services Service
              Runtime service change, the value of this property will
              increase.</para> <para>This allows interested parties to be
              notified of changes to the DTOs by observing Service Events of
              type <code>MODIFIED</code> for the <xref
              linkend="org.osgi.service.jakartars.runtime.JakartarsServiceRuntime"
              xrefstyle="hyperlink"/> service. See
              <code>org.osgi.framework.Constants.SERVICE_CHANGECOUNT</code> in
              <xref linkend="intro.core.release"
              xrefstyle="template:%t"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Inspecting the Runtime DTOs</title>

      <para>The Jakarta RESTful Web Services Service Runtime service provides information about
      registered Whiteboard services through the <xref
      linkend="org.osgi.service.jakartars.runtime.dto.RuntimeDTO"
      xrefstyle="hyperlink"/>.</para>

      <para>The Runtime DTO provides information about services that have been
      successfully registered as well as information about the Jakarta RESTful Web Services
      Whiteboard services that were not successfully registered. Jakarta RESTful Web Services
      Whiteboard services that have the required properties set but cannot be
      processed, are reflected in the failure DTOs. Jakarta RESTful Web Services Whiteboard services
      of interfaces described in this specification that do not have the
      required properties set are ignored and not reflected in the failure
      DTOs.</para>

      <para>The Runtime DTO can be obtained using the <xref
      linkend="org.osgi.service.jakartars.runtime.JakartarsServiceRuntime.getRuntimeDTO--"
      xrefstyle="hyperlink"/> method. The Runtime DTO returned provides a
      snapshot of the state of the Jakarta RESTful Web Services Runtime, including the Jakarta RESTful Web Services
      Whiteboard resources, extensions and applications that are active in
      each registered application. The Runtime DTO also includes information
      about Whiteboard services which could not be activated.</para>

      <section>
        <title>DTO properties</title>

        <para>When whiteboard services are registered with the whiteboard they
        must be introspected and this information reflected in the DTO(s) for
        that service. This introspection will include looking for annotations
        such as <code>@GET</code> and <code>@Path</code> both at a class and
        method level. The values associated with these annotations must then
        be appropriately combined, for example when <code>@Path</code> is
        declared on a type and method level, and recorded in the DTO.</para>
      </section>

      <section>
        <title>Failure DTOs</title>

        <para>There are a variety of reasons that whiteboard services may not
        be able to be used by the whiteboard. For example, if the whiteboard
        service cannot be retrieved from the service registry, or if the
        whiteboard service provides an invalid service property value, such as
        a malformed filter.</para>

        <para>In these cases the failed services are represented in the
        Runtime DTO under one of the failed DTO properties. Depending upon the
        failure reason one or more of the properties of the failed DTO may be
        unavailable. For example if the service cannot be retrieved from the
        service registry then it cannot be introspected for annotations. A
        failure DTO will always contain the service id for the failed service
        and the failure reason. The whiteboard implementation must then fill
        in other DTO properties on a best effort basis.</para>
      </section>
    </section>

    <section>
      <title>Relation to the Servlet Container</title>

      <para>Implementations of this specification will often be backed by
      existing servlet containers, such as the OSGi Http Whiteboard, or a Java
      EE application server. There may also exist implementations which bridge
      into a servlet container into which the OSGi Framework has been deployed
      as a Web Application.</para>

      <para>In bridged situations the Jakarta RESTful Web Services Whiteboard implementation will
      have limited facilities for creating new Jakarta RESTful Web Services whiteboards, and may
      also have limited information about its environment.</para>

      <para>Information about the surrounding Servlet Container, including
      ServletContext information and HttpSession data, is available to Jakarta RESTful Web Services
      Whiteboard resources using standard Jakarta RESTful Web Services injection behavior.</para>

      <programlisting>@GET
@Path("{name}")
public String interrogateSession(@PathParam("name") String name,
         @Context HttpServletRequest req) {
    HttpSession s = req.getSession();
    return String.valueOf(s.getAttribute(name));
}</programlisting>

      <para>A Jakarta RESTful Web Services Whiteboard implementation needs to ensure that Http
      Sessions are not shared amongst different Jakarta RESTful Web Services Whiteboards, or amongst
      different Jakarta RESTful Web Services Whiteboard applications. That is,
      <code>HttpServletRequest.getSession()</code> calls must provide
      different sessions for each whiteboard application with which a Jakarta RESTful Web Services
      whiteboard service is associated.</para>
    </section>

    <section>
      <title>Isolation between Jakarta RESTful Web Services Whiteboards</title>

      <para>Even when they are created by the same Jakarta RESTful Web Services Whiteboard
      implementation, each Jakarta RESTful Web Services Whiteboard instance is separate, and
      isolated from other instances. Importantly, Jakarta RESTful Web Services Whiteboard services
      targeted to one Jakarta RESTful Web Services Whiteboard application must not be visible in any
      other Whiteboard or applications to which they are not targeted.</para>

      <para>This isolation restriction is critical, as it ensures that
      different Jakarta RESTful Web Services Whiteboard applications can be configured with
      different, potentially overlapping, incompatible extension
      features.</para>
    </section>
  </section>

  <section xml:id="service.jakartars.common.properties">
    <title>Common Whiteboard Properties</title>

    <para>Jakarta RESTful Web Services Whiteboard services support common service registration
    properties to associate them with a Jakarta RESTful Web Services Whiteboard. These properties
    apply to whiteboard resources, extensions and applications except where
    explicitly stated otherwise. Each service property has an associated
    Component Property Type annotation that can be used to easily apply the
    property to a Declarative Services Component.</para>

    <table pgwide="1" xml:id="service.jakartars.common.properties.table">
      <title>Common properties</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth="2.2*"/>

        <colspec colnum="2" colwidth="0.7*"/>

        <colspec colnum="3" colwidth="3.9*"/>

        <thead>
          <row>
            <entry>Service Property</entry>

            <entry>Type</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><para><code>osgi.jakartars.name</code></para><para><xref
            linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JakartarsName"
            xrefstyle="hyperlink"/></para></entry>

            <entry><para><code>String</code></para><para><emphasis>optional</emphasis></para></entry>

            <entry><para>A user defined name that can be used to identify a
            Jakarta RESTful Web Services whiteboard service. Names must follow OSGi symbolic name
            rules, and also must not start with the prefixes <code>'.'</code>
            or <code>'osgi.'</code>.</para> <para>If no name is defined for a
            Jakarta RESTful Web Services whiteboard service then one is generated for it. This
            generated name will start with a <code>'.'</code>. The prefix
            <code>osgi.</code> is currently unused, but reserved for future
            versions of this specification. </para> <para>If a Jakarta RESTful Web Services service
            is registered with an illegal name then it is not bound and this
            is reflected in the failure DTOs. If two Jakarta RESTful Web Services services are
            registered with the same name (even if they are advertised as
            different types) then only the first service in ranking order, as
            specified in <code>ServiceReference.compareTo</code>, is bound and
            the lower ranked service(s) are reflected in the failure DTOs. See
            <xref
            linkend="org.osgi.service.jakartars.whiteboard.JakartarsWhiteboardConstants.JAKARTA_RS_NAME"
            xrefstyle="hyperlink"/>.</para></entry>
          </row>

          <row>
            <entry><para><code>osgi.jakartars.application.select</code><emphasis
            role="strong"><superscript>†</superscript></emphasis></para><para><xref
            linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JakartarsApplicationSelect"
            xrefstyle="hyperlink"/></para></entry>

            <entry><para><code>String+</code></para><para><emphasis>optional</emphasis></para></entry>

            <entry><para>One or more LDAP-style filters to select the Jakarta RESTful Web Services
            Application(s) with which this Whiteboard service should be
            associated. Any service property of the Application can be
            filtered on. If these filters are not defined then the default
            Application is used. If multiple filters are defined then each filter
            is used to select target applications. Target applications
            are selected at most once, even if they match more than one filter. 
            The default application can also be
            specifically targeted using the application name
            <code>.default</code>. </para> <para>For example, to select an
            Application with name <code>myApp</code> provide the following
            filter:</para><programlisting>(osgi.jakartars.name=myApp)</programlisting><para>To
            select all Applications in the whiteboard provide the following
            value:</para><programlisting>(osgi.jakartars.name=*)</programlisting><para>If
            no matching application exists this is reflected in the failure
            DTOs. See <xref
            linkend="org.osgi.service.jakartars.whiteboard.JakartarsWhiteboardConstants.JAKARTA_RS_APPLICATION_SELECT"
            xrefstyle="hyperlink"/>.</para> <para>† Note that this property is
            not valid for Jakarta RESTful Web Services Application services.</para></entry>
          </row>

          <row>
            <entry><para><code>osgi.jakartars.extension.select</code></para><para><xref
            linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JakartarsExtensionSelect"
            xrefstyle="hyperlink"/> </para></entry>

            <entry><para><code>String+</code></para><para><emphasis>optional</emphasis></para></entry>

            <entry><para>A set of LDAP-style filters used to express
            dependencies on one or more extension services. If a filter is
            provided then the Jakarta RESTful Web Services Whiteboard attempts to match that filter
            against the service properties of the Whiteboard runtime, the
            service properties of the whiteboard application, and each of the
            extension services currently active in the application. This
            search may occur in any order. If all of the supplied filters are
            matched then the whiteboard service is registered into the Jakarta RESTful Web Services
            Whiteboard application. </para> <para>For example, to require an
            extension which provides JSON serialization advertising property
            name <code>serialize.to</code> with value <code>JSON</code>
            provide the following filter:</para> <programlisting>(serialize.to=JSON)</programlisting>
            <para>A more detailed version of this example is available in
            <xref linkend="service.jakartars.extension.example"/></para> <para>If
            any filter(s) fail to match then this is reflected in the failure
            DTOs. See <xref
            linkend="org.osgi.service.jakartars.whiteboard.JakartarsWhiteboardConstants.JAKARTA_RS_EXTENSION_SELECT"
            xrefstyle="hyperlink"/>.</para></entry>
          </row>

          <row>
            <entry><para> <code>osgi.jakartars.whiteboard.target</code>
            </para><para><xref
            linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JakartarsWhiteboardTarget"
            xrefstyle="hyperlink"/> </para></entry>

            <entry><para><code>String</code></para><para><emphasis>optional</emphasis></para></entry>

            <entry><para>The value of this service property is an LDAP-style
            filter expression to select the Jakarta RESTful Web Services Whiteboard(s) to handle
            this Whiteboard service. The LDAP filter is used to match <xref
            linkend="org.osgi.service.jakartars.runtime.JakartarsServiceRuntime"
            xrefstyle="hyperlink"/> services. Each Jakarta RESTful Web Services Whiteboard exposes
            exactly one <code>JakartarsServiceRuntime</code> service. This
            property is used to associate the Whiteboard service with the
            Jakarta RESTful Web Services Whiteboard that registered the
            <code>JakartarsServiceRuntime</code> service. If this property is not
            specified then the service will target all Jakarta RESTful Web Services Whiteboards. See
            <xref
            linkend="org.osgi.service.jakartars.whiteboard.JakartarsWhiteboardConstants.JAKARTA_RS_WHITEBOARD_TARGET"
            xrefstyle="hyperlink"/>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section xml:id="service.jakartars.resource.services">
    <title>Registering RESTful Resources</title>

    <para>Jakarta RESTful Web Services resources can be registered with the Jakarta RESTful Web Services Whiteboard by
    registering them as Whiteboard services. This means that the resource POJO
    implementations are registered in the Service Registry. As Jakarta RESTful Web Services
    resources are POJOs they may be registered using <emphasis>any</emphasis>
    valid service interface, including <code>Object</code>. The Jakarta RESTful Web Services
    container will then use reflection to discover methods and annotations on
    the resource object, just as it would outside of OSGi.</para>

    <para>As Jakarta RESTful Web Services resources have no common interface type they are instead
    registered with the <code>osgi.jakartars.resource</code> service property with
    a value of <code>"true"</code>. This property serves as a marker to the
    Jakarta RESTful Web Services whiteboard runtime, indicating that this OSGi service should be
    hosted as a Jakarta RESTful Web Services Whiteboard resource.</para>

    <section>
      <title>Jakarta RESTful Web Services Resource mapping</title>

      <para>Jakarta RESTful Web Services resources use the <code>Path</code> annotation to bind
      themselves to particular URIs within the Jakarta RESTful Web Services container. The path
      annotation can be applied to the resource class, and to individual
      resource methods. For example the following Jakarta RESTful Web Services resource:</para>

      <programlisting>@Path("foo")
public class Foo {

    private final List&lt;String&gt; entries = 
        Arrays.asList("fizz", "buzz", "fizzbuzz");
        
    @GET
    public List&lt;String&gt; getFoos() {
        return Collections.unmodifiableList(entries);
    }

    @GET
    @Path("{name}")
    public String getFoo(@PathParam("name") String name) {
        if(entries.contains(name)) {
            return "A foo called " + name;
        }
        throw new IllegalArgumentException(“No foo called “ + name);
    }

}</programlisting>

      <para>This Jakarta RESTful Web Services resource defines two resource methods. The
      <code>Path</code> annotation applied to the class sets the base URI for
      all methods in the resource. The <code>getFoos()</code> method is
      therefore bound to the URI <code>foo</code>. The <code>Path</code>
      annotation on the <code>getFoo()</code> method makes this method a
      sub-resource which captures the next token in the URI. This method is
      therefore bound to URIs of the form <code>foo/buzz</code>.</para>

      <para>When used as an OSGi Jakarta RESTful Web Services Whiteboard service a Jakarta RESTful Web Services resource
      follows the same mapping rules, but the base context(s) it uses are
      determined by the Application(s) to which it is mapped. For example,
      when mapped to the default application of a whiteboard with endpoint
      <code>http://127.0.0.1/</code> the <code>getFoos()</code> method would
      be available at <code>http://127.0.0.1/foo</code>.</para>

      <section xml:id="service.jakartars.resource.services.clashes">
        <title>Clashing resource mappings</title>

        <para>Resource services bound to a Jakarta RESTful Web Services whiteboard application share
        a single URI namespace with other resources in the application
        (including any existing static resources). When Jakarta RESTful Web Services services are
        bound it is possible that one or more methods on these services will
        map to the same URI. This situation is permitted by the Jakarta RESTful Web Services
        specification which defines a detailed selection algorithm.</para>

        <para>When clashes occur in the Jakarta RESTful Web Services whiteboard then resources
        supplied using the service whiteboard must be preferred to static
        resources contained in the application. If two or more whiteboard
        resources exist then they must be ordered using ranking order, as
        specified in <code>ServiceReference.compareTo</code>. Unlike for other
        services in the Jakarta RESTful Web Services whiteboard, whiteboard resource services must
        not be ordered using their natural ordering. Whiteboard resource
        services with the same ranking must be considered equal, following the
        normal resource method selection rules defined in the Jakarta RESTful Web Services
        specification. As per the Core specification, whiteboard services with
        no <code>service.ranking</code> property must be treated as having a
        ranking of <code>0</code>.</para>
      </section>
    </section>

    <section>
      <title>Jakarta RESTful Web Services Whiteboard Resource Lifecycle</title>

      <para>A key tenet of Jakarta RESTful Web Services is that all resource objects are stateless.
      In the Jakarta RESTful Web Services specification resources therefore have one of two scopes,
      they are either singleton, or request-scoped. Singleton resources are
      created once, potentially outside the Jakarta RESTful Web Services container, and
      request-scoped resources are created on-demand for each request, then
      discarded afterwards.</para>

      <para>Typically Jakarta RESTful Web Services developers are encouraged to write request-scoped
      resources, as this makes it difficult to accidentally write stateful
      components. In OSGi, however, it is more common to write singleton
      services. On demand instances of OSGi services can be created, but only
      if the service is registered as a <code>prototype</code> scope.</para>

      <para>The Jakarta RESTful Web Services whiteboard implementation is responsible for managing
      the mismatch between the OSGi service lifecycle model and the Jakarta RESTful Web Services
      resource lifecycle model. If the Jakarta RESTful Web Services whiteboard resource is
      registered as prototype scope then the implementation must treat the
      resources as request-scoped, creating a new service instance for each
      request and releasing it when the request completes. Otherwise the
      Jakarta RESTful Web Services whiteboard service must be registered as a singleton scope
      resource within the application. Singleton scope whiteboard resources
      must be released by the Jakarta RESTful Web Services whiteboard when the application with
      which they have been registered is removed from the whiteboard, even if
      this is only a temporary situation.</para>

      <para>If a failure occurs when getting the resource service this will
      prevent the service from being used, which is reflected using a failure
      DTO. In such a case the system treats the resource as unusable.</para>

      <para>When multiple Jakarta RESTful Web Services Whiteboard implementations are present all of
      them can potentially process the whiteboard resources. In such
      situations it can be useful to associate the servlet with a specific
      whiteboard by specifying the <code>osgi.http.whiteboard.target</code>
      property on the service.</para>

      <section>
        <title>Resource Context Injection</title>

        <para>Jakarta RESTful Web Services resources may have objects injected into them by the
        Jakarta RESTful Web Services container. These objects may be related to an incoming request,
        for example an HTTP header value, or part of the container runtime.
        Injected resources are annotated with a Jakarta RESTful Web Services annotation, for example
        <code>@Context</code>, and may be injected as method parameters, or as
        fields in the object.</para>

        <para>If the Jakarta RESTful Web Services injected objects are passed as method parameters
        then the resource object may be a singleton. If, however, the objects
        are injected into fields by the Jakarta RESTful Web Services container then the resource
        should be declared as a <code>prototype</code> scope. Jakarta RESTful Web Services
        Whiteboard implementations may support field injection for singleton
        resources, however this behavior is non portable, and may lead to
        errors at runtime when using other implementations.</para>
      </section>

      <section>
        <title>Request-Scoped Resources</title>

        <para>Request-scoped resources are created on demand for a request and
        then discarded afterwards. Critically for OSGi services the Jakarta RESTful Web Services
        whiteboard <emphasis>must not</emphasis> release a prototype scope
        service until <emphasis>after</emphasis> the response has completed.
        If the resource makes use of a Jakarta RESTful Web Services <code>AsyncResponse</code>,
        <code>SseEventSink</code> or a <code>StreamingOutput</code> then this
        may be some time after the return of resource method, and potentially
        on a different thread.</para>

        <para>Jakarta RESTful Web Services whiteboard implementations must therefore take special
        care not to release request scoped instances until they are completely
        finished.</para>
      </section>

      <section>
        <title>Asynchronous Responses</title>

        <para>Jakarta RESTful Web Services supports asynchronous responses either for single-valued
        results, or for streams of data.</para>

        <para>Single valued results may be provided by the
        <code>AsyncResponse</code> type which is injected into resource
        methods using the <code>@Suspended</code> annotation. If the resource
        is request scoped then the resource must not be released until after
        the <code>AsyncResponse</code> has completed.</para>

        <para>The following example demonstrates the use of the
        <code>AsyncResponse</code>:</para>

        <programlisting>@Component(service = MyResource.class,
      scope = ServiceScope.PROTOTYPE)
 @JakartarsResource     
 public class MyResource {
  
    @Path(“foo”)
    @GET
    public void getFoo(@Suspended AsyncResponse async) {
        Promise&lt;String&gt; p = doLongRunningTaskAsynchronously();
        p.onSuccess(v -&gt; async.resume(v))
            .onFailure(t -&gt; async.resume(t));
    }
}</programlisting>

        <para>Single valued asynchronous results can also be provided by
        returning a suitable type from the resource method. This can be a
        <code>CompletionStage</code> as described in the Jakarta RESTful Web Services specification,
        or an OSGi <code>Promise</code> type. In this case the response from
        the resource method will be sent once the returned type has completed,
        either successfully or by failing.</para>

        <para>The following example demonstrates the use of an asynchronous
        return value:</para>

        <programlisting>@Component(service = MyResource.class,
      scope = ServiceScope.PROTOTYPE)
 @JakartarsResource     
 public class MyResource {
  
    @Path(“foo”)
    @GET
    public Promise&lt;String&gt; getFoo() {
        Promise&lt;String&gt; p = doLongRunningTaskAsynchronously();
        return p;
    }
}</programlisting>

        <para>Multi-valued results in Jakarta RESTful Web Services are handled using Server Sent
        Events. To send Server Sent Events a Jakarta RESTful Web Services resource must declare its
        produced media type appropriately, and inject its resource method with
        a <code>SseEventSink</code>. The resource must also gain access to a
        <code>Sse</code> to use as a factory for Outbound Server Sent Events.
        If the resource is request scoped then the resource must not be
        released until after the <code>SseEvent</code> has closed.</para>

        <para>The following example demonstrates the use of the Server Sent
        Events:</para>

        <programlisting>@Component(service = MyResource.class,
      scope = ServiceScope.PROTOTYPE)
 @JakartarsResource     
 public class MyResource {
  
    @Context
    Sse sse;

    @GET
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public void getFoo(@Context SseEventSink sink) {
        PushStream&lt;String&gt; p = getStreamOfMessages();
        p.map(sse::newEvent)
            .forEach(e -&gt; sink::send)
            .onResolve(sink::close);
    }
}</programlisting>
      </section>
    </section>

    <section>
      <title>Resource Service Properties</title>

      <para>The following table describes the properties that can be used by
      Jakarta RESTful Web Services resources registered as Whiteboard services. Additionally, the
      common properties listed in <xref
      linkend="service.jakartars.common.properties.table"
      xrefstyle="template:Table %n on page %p"/> are supported.</para>

      <table pgwide="1">
        <title>Service properties for Jakarta RESTful Web Services Whiteboard resource
        services.</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="2.2*"/>

          <colspec colnum="2" colwidth="0.7*"/>

          <colspec colnum="3" colwidth="3.9*"/>

          <thead>
            <row>
              <entry>Service Property</entry>

              <entry>Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><code>osgi.jakartars.resource</code></para><para><xref
              linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JakartarsResource"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para><code>String</code> /
              <code>Boolean</code></para><para><emphasis>required</emphasis></para></entry>

              <entry><para>Declares that this service must be processed by the
              Jakarta RESTful Web Services whiteboard when set to <code>true</code>. See <xref
              linkend="org.osgi.service.jakartars.whiteboard.JakartarsWhiteboardConstants.JAKARTA_RS_RESOURCE"
              xrefstyle="hyperlink"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>A Jakarta RESTful Web Services Whiteboard Resource Example</title>

      <para>The following example code uses Declarative Services annotations
      to register a Jakarta RESTful Web Services Whiteboard service.</para>

      <programlisting>@Component(service = MyResource.class,
      scope = ServiceScope.PROTOTYPE)
 @JakartarsResource     
 public class MyResource {
  
     @GET
     @Path("hello")
     @Produces("text/plain")
     public String sayHello(){
          return "Hello World!";
     }
 }</programlisting>

      <para>This example registers the resource method at:
      <code>/hello</code>. Requests for <code>http://www.acme.com/hello</code>
      map to the resource method, which is called to process the
      request.</para>

      <para>To associate the above example resource with another application
      add the following service property:</para>

      <programlisting>osgi.jakartars.application.select=(osgi.jakartars.name=myApp)</programlisting>

      <para>This can also be added using the property annotation:</para>

      <programlisting>@JakartarsApplicationSelect("(osgi.jakartars.name=myApp)")</programlisting>

      <para>Setting this property requires a Jakarta RESTful Web Services application named
      <code>myApp</code> to be registered:</para>

      <programlisting>@Component(service=Application.class)
@JakartarsName("myApp")
@JakartarsApplicationBase("foo")
public class MyApplication extends Application {}</programlisting>

      <para>Now the whiteboard resource will be available at
      <code>http://www.acme.com/foo/hello</code> as configured by the custom
      Jakarta RESTful Web Services application.</para>
    </section>
  </section>

  <section xml:id="service.jakartars.extension.services">
    <title>Registering Extensions</title>

    <para>Jakarta RESTful Web Services extensions can be registered with the Jakarta RESTful Web Services Whiteboard by
    registering them as Whiteboard services. This means that the extension
    implementations are registered in the Service Registry. It is relatively
    common for a single extension type to provide more than one extension
    interface, for example <code>MessageBodyReader</code> and
    <code>MessageBodyWriter</code> are often provided by a single
    object.</para>

    <para>Extension services must be registered with the Jakarta RESTful Web Services application
    that they target using only the interfaces that they advertise in the OSGi
    service registry. If, for example, an extension service object implements
    <code>MessageBodyReader</code> and <code>ContainerRequestFilter</code> but
    only advertises <code>MessageBodyReader</code> in its service registration
    then it must only be used as a <code>MessageBodyReader</code></para>

    <para>The following Jakarta RESTful Web Services extension interfaces are supported by this
    specification:</para>

    <itemizedlist>
      <listitem>
        <para><code>ContainerRequestFilter</code> and
        <code>ContainerResponseFilter</code> - these extensions are used to
        alter the HTTP request and response parameters.</para>
      </listitem>

      <listitem>
        <para><code>ReaderInterceptor</code> and
        <code>WriterInterceptor</code> - these extensions are used to alter
        the incoming or outgoing objects for the call.</para>
      </listitem>

      <listitem>
        <para><code>MessageBodyReader</code> and
        <code>MessageBodyWriter</code> - these extensions are used to
        deserialize/serialize objects to the wire for a given media type, for
        example <code>application/json</code>.</para>
      </listitem>

      <listitem>
        <para><code>ContextResolver</code> extensions are used to provide
        objects for injection into other Jakarta RESTful Web Services resources and
        extensions.</para>
      </listitem>

      <listitem>
        <para><code>ExceptionMapper</code> extensions are used to map
        exceptions thrown by Jakarta RESTful Web Services resources into responses.</para>
      </listitem>

      <listitem>
        <para><code>ParamConverterProvider</code> extensions are used to map
        rich parameter types to and from String values.</para>
      </listitem>

      <listitem>
        <para><code>Feature</code> and <code>DynamicFeature</code> - these
        extensions are used as a way to register multiple extension types with
        the Jakarta RESTful Web Services container. Dynamic Features further allow the extensions to
        be targeted to specific resources within the Jakarta RESTful Web Services container.</para>
      </listitem>
    </itemizedlist>

    <para>As Jakarta RESTful Web Services extensions have many possible interface types, none of
    which are defined by this specification, they must be registered with the
    <code>osgi.jakartars.extension</code> service property with a value of
    <code>true</code>. This property serves as a marker to the Jakarta RESTful Web Services
    whiteboard runtime, indicating that this OSGi service should be used as a
    Jakarta RESTful Web Services Whiteboard extension.</para>

    <para>If the <code>osgi.jakartars.extension</code> is added to a service which
    does not advertise any of the Jakarta RESTful Web Services extension types then this is an
    error, and must result in a failure DTO being created.</para>

    <section>
      <title>Name Binding and Jakarta RESTful Web Services Extensions</title>

      <para>By default Jakarta RESTful Web Services extensions are applied to every request, however
      sometimes they are only needed for a subset of resource methods. In this
      case a <code>NameBinding</code> annotation can be used to apply the
      extension to a subset of resource methods. The following example
      declares a binding annotation called <code>FizzBuzz</code> and uses it
      to bind an extension which replaces occurrences of "fizz" with
      "fizzbuzz".</para>

      <programlisting>@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@NameBinding
public @interface FizzBuzz{}

@Component
@JakartarsExtension
@FizzBuzz
public class FizzBuzzReplacer implements WriterInterceptor {

    public void aroundWriteTo(WriterInterceptorContext ctx) {
        Object entity = ctx.getEntity();
        
        if(entity != null) {
            ctx.setEntity(entity.toString()
                .replace("fizz", "fizzbuzz"));
        }
        ctx.proceed();
    }
}

@Component(service=FizzResource.class)
@JakartarsResource
@Path("fizzbuzz")
public class FizzResource {

    @GET
    @FizzBuzz
    public String getFoos() {
        return "fizz, buzz, fizzbuzz";
    }
}</programlisting>

      <para>The result of an http request to the <code>fizzbuzz</code> URI
      will be <emphasis>fizzbuzz, buzz, fizzbuzzbuzz</emphasis></para>

      <para>The Jakarta RESTful Web Services whiteboard implementation must support the use of
      <code>NameBinding</code> to limit the scope of applied whiteboard
      extensions.</para>
    </section>

    <section>
      <title>Extension ordering</title>

      <para>Jakarta RESTful Web Services filters can be annotated with <code>@PreMatching</code> to
      indicate that they should be applied before the Jakarta RESTful Web Services container works
      out which resource should be called by the incoming request. These
      filters can therefore change the request such that it maps to a
      different resource than it would have before the filter’s operation.
      Pre-matching filters cannot use <code>NameBinding</code> as no
      corresponding named resource is available to the runtime when they
      operate.</para>

      <para>When used in the OSGi Jakarta RESTful Web Services Whiteboard Jakarta RESTful Web Services extensions follow
      the same ordering rules as defined by the Jakarta RESTful Web Services specification. Where
      more than one extension of a particular type is available then they are
      ordered according to their <code>javax.annotation.Priority</code>. If
      two extensions of the same type have the same priority then the
      whiteboard implementation must break the tie by ordering the extensions
      according to the natural ordering of their service references, as
      specified in <code>ServiceReference.compareTo</code>, with static
      extensions being ranked below all whiteboard services.</para>

      <para>The extension processing flow is as follows:</para>

      <orderedlist>
        <listitem>
          <para>Server receives a request</para>
        </listitem>

        <listitem>
          <para>Pre-matching <code>ContainerRequestFilter</code>s are
          executed. Changes made here can affect which resource method is
          chosen</para>
        </listitem>

        <listitem>
          <para>The Server matches the request to a resource method</para>
        </listitem>

        <listitem>
          <para>Post-matching ContainerRequestFilters are executed. This
          includes execution of all filters which match the incoming path and
          any name-bound filters.</para>
        </listitem>

        <listitem>
          <para>ReaderInterceptors which match the incoming path are applied
          to the incoming request body. If the request has no body then the
          ReaderInterceptors are not called.</para>
        </listitem>

        <listitem>
          <para>The list of <code>MessageBodyReader</code>s applicable to the
          path and incoming content type are tried according to the standard
          ordering rules. The first <code>MessageBodyReader</code> which
          states that it can deserialize the entity “wins” and is used to
          create the entity object. If the incoming request has no body then
          no <code>MessageBodyReader</code>s are called.</para>
        </listitem>

        <listitem>
          <para>If the resource is request scoped then it is instantiated and
          injected with relevant types from any defined
          <code>ContextResolver</code>s. These are queried in order for each
          of the injectable fields.</para>
        </listitem>

        <listitem>
          <para>The resource method is executed, passing any injected
          parameters from the request, and from any
          <code>ContextResolver</code>s. These are queried in turn for each of
          the injectable parameters.</para>
        </listitem>

        <listitem>
          <para><code>ContainerResponseFilter</code>s are executed passing the
          method's response when it is complete. This includes execution of
          all filters, in order, which match the incoming path and any
          name-bound filters. Note that if an <code>AsyncResponse</code> is
          used then the response may not complete on the same thread as the
          incoming request.</para>
        </listitem>

        <listitem>
          <para><code>WriterInterceptor</code>s which match the incoming path
          are applied to the outgoing response stream. If the response has no
          body then the WriterInterceptors are not called.</para>
        </listitem>

        <listitem>
          <para>The list of <code>MessageBodyWriter</code>s applicable to the
          path and outgoing content type are tried according to the standard
          ordering rules. The first writer which states that it can serialize
          the entity “wins” and is used to write out the entity object. If
          there is no response body then no writers are called.</para>
        </listitem>

        <listitem>
          <para>The Server response is flushed and committed. If the resource
          that created the response was request scoped then it must only be
          released once the response is complete. Note that this may be at
          some point in the future, and on a different thread if the resource
          is using an <code>AsyncResponse</code></para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>Extension dependencies</title>

      <para>The <code>osgi.jakartars.extension.select</code> property described in
      <xref linkend="service.jakartars.common.properties"/> applies to extensions
      as well as Jakarta RESTful Web Services resources. This is because one extension may depend on
      another.</para>

      <para>The most common reason for an extension to have a dependency is
      for a context injection dependency. Dependencies are often provided by a
      <code>ContextResolver</code> so that they can be injected into another
      extension. The following example demonstrates a simple dependency on a
      Jackson ObjectMapper.</para>

      <programlisting>@JakartarsExtension
@JakartarsName("configProvider")
@Component
public class ConfigProvider implements ContextResolver {
    
    private ObjectMapper mapper = new ObjectMapper();
    
    public &lt;T&gt; getContext(Class&lt;T&gt; clazz) {
        if(ObjectMapper.class.equals(clazz)) {
            return mapper;
        }
        return null;
    }
}

@JakartarsExtension
@JakartarsExtensionSelect("(osgi.jakartars.name=configProvider)")
@Component(scope=ServiceScope.PROTOTYPE)
public class ConfiguredExtension implements WriterInterceptor {

    @Context
    private Providers providers;

    public void aroundWriteTo(WriterInterceptorContext ctx) {
        Object entity = ctx.getEntity();
        
        if(entity != null) {
            ObjectMapper mapper = providers
                    .getContextResolver(ObjectMapper.class)
                    .getContext(ObjectMapper.class);
                    
            ctx.setEntity(mapper.writeValueAsString(entity));
        }
        ctx.proceed();
    }
}</programlisting>
    </section>

    <section>
      <title>Built in extensions</title>

      <para>Depending on the capabilities of the Jakarta RESTful Web Services whiteboard
      implementation, and any statically defined extensions that make up a
      Jakarta RESTful Web Services Whiteboard application, there may be numerous non standard
      extensions available. These extensions must be represented using service
      properties on the Jakarta RESTful Web Services Service Runtime, or the whiteboard application
      as appropriate. This is why the extension select filters must also be
      matched against the Jakarta RESTful Web Services Service Runtime service and the whiteboard
      application being targeted.</para>
    </section>

    <section>
      <title>Jakarta RESTful Web Services Whiteboard Extension Lifecycle</title>

      <para>Jakarta RESTful Web Services extensions have a different lifecycle from Jakarta RESTful Web Services
      resources, within a single application a Jakarta RESTful Web Services extension always behaves
      as a singleton. If a Jakarta RESTful Web Services whiteboard extension is registered as
      prototype scope then the whiteboard implementation must obtain a
      separate instance for every application to which the extension is
      applied. Whiteboard extension services must be released by the Jakarta RESTful Web Services
      whiteboard when the application with which they have been registered is
      removed from the whiteboard, even if this is only a temporary
      situation.</para>

      <para>Jakarta RESTful Web Services extensions often require configuration, and need to be
      configured differently for different applications. This configuration is
      typically provided by a Jakarta RESTful Web Services <code>ContextResolver</code> and injected
      into fields of the extension by the Jakarta RESTful Web Services container. It is therefore
      highly recommended that Jakarta RESTful Web Services Whiteboard extensions are always
      registered as prototype scope, so that separate instances can be created
      for each whiteboard application.</para>

      <para>If an extension is registered as a singleton service then it
      should not rely on any fields being injected by the Jakarta RESTful Web Services Whiteboard
      implementation. Jakarta RESTful Web Services Whiteboard implementations may support field
      injection for singleton extensions, however this behavior is non
      portable, and may lead to errors at runtime when using other
      implementations.</para>
    </section>

    <section>
      <title>Extension Service Properties</title>

      <para>The following table describes the properties that can be used by
      Jakarta RESTful Web Services extensions registered as Whiteboard services. Additionally, the
      common properties listed in <xref
      linkend="service.jakartars.common.properties.table"
      xrefstyle="template:Table %n on page %p"/> are supported.</para>

      <table pgwide="1">
        <title>Service properties for Jakarta RESTful Web Services Whiteboard extension
        services.</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="2.2*"/>

          <colspec colnum="2" colwidth="0.7*"/>

          <colspec colnum="3" colwidth="3.9*"/>

          <thead>
            <row>
              <entry>Service Property</entry>

              <entry>Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><code>osgi.jakartars.extension</code></para><para><xref
              linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JakartarsExtension"
              xrefstyle="hyperlink"/> </para></entry>

              <entry><para><code>String</code> /
              <code>Boolean</code></para><para><emphasis>required</emphasis></para></entry>

              <entry><para>Declares that this service must be processed by the
              Jakarta RESTful Web Services whiteboard when set to <code>true</code>. See <xref
              linkend="org.osgi.service.jakartars.whiteboard.JakartarsWhiteboardConstants.JAKARTA_RS_EXTENSION"
              xrefstyle="hyperlink"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="service.jakartars.extension.example">
      <title>A Jakarta RESTful Web Services Whiteboard Extension Example</title>

      <para>The following example code uses Declarative Services annotations
      to register a require Jakarta RESTful Web Services Whiteboard extension which provides JSON
      support, and requires the extension from a Jakarta RESTful Web Services whiteboard
      resource.</para>

      <programlisting>@Component(property="serialize.to=JSON")
@JakartarsExtension
public class JsonProvider implements MessageBodyReader,
      MessageBodyWriter {
    ...      
}
 
 @Component(service = Object.class,
      scope = ServiceScope.PROTOTYPE)
 @JakartarsResource
 @JakartarsExtensionSelect("(serialize.to=JSON)")
 public class MyResource {
  
     @GET
     @Path("hello")
     @Produces(MediaType.APPLICATION_JSON)
     public List&lt;String&gt; getList(){
          return Arrays.asList("Hello", "World!");
     }
 }</programlisting>
    </section>
  </section>

  <section xml:id="service.jakartars.application.services">
    <title>Registering RESTful Web Service Applications</title>

    <para>The Jakarta RESTful Web Services specification defines the concept of an
    <code>Application</code>. An application is an object which collects
    together one or more Jakarta RESTful Web Services resources and extensions, and provides them to
    the Jakarta RESTful Web Services container. These resources may be provided as pre-instantiated
    singletons, or as <code>Class</code> objects to be reflectively
    instantiated.</para>

    <para>The OSGi Jakarta RESTful Web Services whiteboard supports direct registration of
    Applications for two reasons:</para>

    <itemizedlist>
      <listitem>
        <para>To support the use of legacy Jakarta RESTful Web Services applications with the
        whiteboard</para>
      </listitem>

      <listitem>
        <para>To provide simple scoping of Jakarta RESTful Web Services resources and extensions
        within a whiteboard, in this scenario it can be desirable to register
        an otherwise empty Application. This application can then be targeted
        by whiteboard services using the
        <code>osgi.jakartars.application.select</code> property.</para>
      </listitem>
    </itemizedlist>

    <para><code>Application</code>s can be registered with the Jakarta RESTful Web Services
    Whiteboard by registering them as Whiteboard services which advertise
    themselves using the Jakarta RESTful Web Services <code>Application</code> type. In addition the
    whiteboard services must provide a
    <code>osgi.jakartars.application.base</code> property. The value of this
    property is the URI path relative to the root whiteboard context at which
    the application will be registered. Note that the value of any
    <code>ApplicationPath</code> annotation will be applied by the container
    in addition to the <code>osgi.jakartars.application.base</code>.</para>

    <para>Each registered Whiteboard Application service is provided as a
    separate application within the whiteboard, and is isolated from other
    applications, including the default application. Whiteboard applications
    may be empty, may include zero or more static resources, and may include
    zero or more static extensions.</para>

    <section>
      <title>Application shadowing</title>

      <para>The base URI for each application within the whiteboard must be
      unique. If two or more applications targeting the same whiteboard are
      registered with the same base URI then only the first in ranking order,
      as specified in <code>ServiceReference.compareTo</code>, will be made
      available. All other application services with that URI will have a
      failure DTO created for them. The same rules also apply to the
      <code>osgi.jakartars.name</code> property, with the highest ranked service
      shadowing other applications with the same name.</para>

      <para>The default application is implicitly created by the whiteboard
      and has the name <code>.default</code>. The default application has a
      lower ranking than all registered services. Therefore an application
      registered with a base of <code>/</code> will shadow a default
      application bound at <code>/</code>.</para>

      <para>A whiteboard application service may set an
      <code>osgi.jakartars.name</code> of <code>.default</code> to replace the
      default application. This technique may be used to rebind the default
      application to a base uri other than <code>/</code>.</para>

      <para>If a whiteboard application fails (for example if the service get
      fails), or cannot be immediately deployed (for example if it has an
      unsatisfied <code>osgi.jakartars.extension.select</code>) then any
      applications that it shadows are still shadowed and relevant failure
      DTOs are created for all of the applications.</para>
    </section>

    <section>
      <title>Application Extension Dependencies</title>

      <para>It is possible for an application to require additional whiteboard
      extensions before it is eligible to be hosted by the whiteboard. When
      making this determination the Whiteboard implementation must perform a
      dry-run validation of the <code>osgi.jakartars.extension.select</code>
      filter, applying all of the whiteboard extensions targeted to the
      application before determining whether the application's requirements
      are met.</para>
    </section>

    <section>
      <title>Application Service Properties</title>

      <para>The following table describes the properties that can be used by
      Jakarta RESTful Web Services applications registered as Whiteboard services. Additionally, the
      common properties listed in <xref
      linkend="service.jakartars.common.properties.table"
      xrefstyle="template:Table %n on page %p"/> are supported, except for the
      <code>osgi.jakartars.application.select</code> property.</para>

      <table pgwide="1">
        <title>Service properties for Jakarta RESTful Web Services Whiteboard application
        services.</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="2.2*"/>

          <colspec colnum="2" colwidth="0.7*"/>

          <colspec colnum="3" colwidth="3.9*"/>

          <thead>
            <row>
              <entry>Service Property</entry>

              <entry>Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><code>osgi.jakartars.application.base</code></para><para><xref
              linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JakartarsApplicationBase"
              xrefstyle="hyperlink"/> </para></entry>

              <entry><para><code>String</code></para><para><emphasis>required</emphasis></para></entry>

              <entry><para>Declares that this service must be processed by the
              Jakarta RESTful Web Services whiteboard, and defines the URI, relative to the root
              context of the whiteboard, at which the Application should be
              registered. See <xref
              linkend="org.osgi.service.jakartars.whiteboard.JakartarsWhiteboardConstants.JAKARTA_RS_APPLICATION_BASE"
              xrefstyle="hyperlink"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Accessing the Application service properties</title>

      <para>In Jakarta RESTful Web Services the <code>@Context</code> annotation may be used to
      inject the <code>Application</code> instance into a resource or
      extension. Application configuration properties can also be injected
      using the <code>Configuration</code> type.</para>

      <para>When using the Jakarta RESTful Web Services Whiteboard it can also be necessary to
      access the service properties associated with the application hosting
      the resource, for example to allow customization of the resource's
      response. To this end, the Jakarta RESTful Web Services whiteboard implementation must make
      the Application service properties available as a <code>Map</code> in
      the configuration. The key used to store this map is
      <code>osgi.jakartars.application.serviceProperties</code>, and it can be
      found in any injected <code>Configuration</code> instance.</para>

      <para>Furthermore, for <code>Feature</code> and
      <code>DynamicFeature</code> extensions the application service
      properties must be visible in the <code>FeatureContext</code> passed to
      the extension when applying it to the application. The
      <code>FeatureContext</code> interface provides programmatic access to
      the <code>Configuration</code> for the application, so this visibility
      is achieved in the same manner as for an injected Configuration
      instance.</para>

      <para>In the case where the hosting application is not an OSGi service,
      for example a Whiteboard implementation may choose to provide its
      default application as an internal detail, then the
      <code>osgi.jakartars.application.serviceProperties</code> map must exist
      containing the <code>osgi.jakartars.name</code> of the application and the
      service properties associated with the JakartarsServiceRuntime
      service.</para>
    </section>

    <section>
      <title>A Jakarta RESTful Web Services Whiteboard Application Example</title>

      <para>The following example code uses Declarative Services annotations
      to register a Jakarta RESTful Web Services Whiteboard application, and shows how to target an
      additional whiteboard resource to that application.</para>

      <programlisting>@Component(service=Application.class)
@JakartarsApplicationBase("example")
@JakartarsName("myApp")
public class MyApplication extends Application {
    public Set&lt;Class&lt;?&gt;&gt; getClasses() {
        return new HashSet&lt;&gt;(Arrays.asList(StaticResource.class));
    }      
}
 
 @Component(service = MyResource.class,
      scope = ServiceScope.PROTOTYPE)
 @JakartarsResource
 @JakartarsApplicationSelect("(osgi.jakartars.name=myApp)")
 public class MyResource {
  
     @GET
     @Path("hello")
     @Produces("text/plain")
     public List&lt;String&gt; getList(){
          return Arrays.asList("Hello", "World!");
     }
 }</programlisting>

      <para>The <code>MyResource</code> service will be available at
      <code>http://www.acme.com/example/hello</code></para>
    </section>
  </section>

  <section>
    <title>Advertising Web Service Endpoints</title>

    <para>All Jakarta RESTful Web Services Whiteboard services may be registered with an optional
    <code>osgi.jakartars.name</code> property. For Whiteboard resources and
    applications (but not extensions), if the registered service has set this
    property then the Jakarta RESTful Web Services container must register a <xref
    linkend="org.osgi.service.jakartars.runtime.JakartarsEndpoint"
    xrefstyle="hyperlink"/> service identifying the URI(s) that can be used to
    access the service.</para>

    <para>The endpoint service must declare the following properties:</para>

    <table pgwide="1">
      <title>Service properties for Jakarta RESTful Web Services Whiteboard application
      services.</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth="2.2*"/>

        <colspec colnum="2" colwidth="0.9*"/>

        <colspec colnum="3" colwidth="3.7*"/>

        <thead>
          <row>
            <entry>Service Property Name</entry>

            <entry>Type</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><para><code>osgi.jakartars.name</code></para></entry>

            <entry><para><code>String</code></para><para><emphasis>required</emphasis></para></entry>

            <entry><para>The name of the Jakarta RESTful Web Services bean or application that has
            been registered.</para></entry>
          </row>

          <row>
            <entry><para><code>osgi.jakartars.uri</code></para></entry>

            <entry><para><code>List&lt;String&gt;</code></para><para><emphasis>required</emphasis></para></entry>

            <entry><para>The URI(s) that can be used to access the Jakarta RESTful Web Services
            resource or application</para></entry>
          </row>

          <row>
            <entry><para><code>service.exported.interfaces</code></para></entry>

            <entry><para><code>String</code></para><para><emphasis>required</emphasis></para></entry>

            <entry><para>Set appropriately to export the Endpoint service
            using OSGi Remote Services.</para></entry>
          </row>

          <row>
            <entry><para><code>osgi.jakartars.bundle.symbolicname</code></para></entry>

            <entry><para><code>String</code></para><para><emphasis>required</emphasis></para></entry>

            <entry><para>Set to the symbolic name of the bundle that provided
            the Jakarta RESTful Web Services whiteboard service.</para></entry>
          </row>

          <row>
            <entry><para><code>osgi.jakartars.bundle.id</code></para></entry>

            <entry><para><code>Long</code></para><para><emphasis>required</emphasis></para></entry>

            <entry><para>Set to the id of the bundle that provided the Jakarta RESTful Web Services
            service</para></entry>
          </row>

          <row>
            <entry><para><code>osgi.jakartars.bundle.version</code></para></entry>

            <entry><para><code>Version</code></para><para><emphasis>required</emphasis></para></entry>

            <entry><para>Set to the version of the bundle that provided the
            Jakarta RESTful Web Services service</para></entry>
          </row>

          <row>
            <entry><para><code>osgi.jakartars.service.id</code></para></entry>

            <entry><para><code>Long</code></para><para><emphasis>required</emphasis></para></entry>

            <entry><para>Set to the service id of the Jakarta RESTful Web Services
            service</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section>
    <title>Whiteboard Error Handling</title>

    <para>There are a number of error cases where the Jakarta RESTful Web Services whiteboard may be
    unable to correctly register a resource. All of these cases must result in
    a failure DTO being created with the appropriate error code.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Failure to obtain a service instance</emphasis> - In
        the case where a published service is unable to be obtained by the
        Jakarta RESTful Web Services whiteboard then the service is deny listed by the container. A
        failure DTO is made available from the JakartarsServiceRuntime
        representing the deny listed service object.</para>
      </listitem>

      <listitem>
        <para><emphasis>Invalid service objects</emphasis> - Jakarta RESTful Web Services extension
        and Application objects are required to advertise certain interfaces,
        or to extend certain types. If a service advertises itself using a
        Jakarta RESTful Web Services whiteboard service property, but fails to advertise an
        appropriate Jakarta RESTful Web Services type, or fails to provide any resource methods then
        this is an error and the service must be deny listed by the container.
        A failure DTO is available from the JakartarsServiceRuntime representing
        the deny listed service object.</para>
      </listitem>

      <listitem>
        <para><emphasis>Overlapping Application mappings</emphasis> - As with
        resources in a single application it is possible that two Jakarta RESTful Web Services
        resources will register for the same path across applications. In this
        case the application with the longer base URI is shadowed, and a
        failure DTO is available from the JakartarsServiceRuntime representing the
        shadowed Application. Note that determining when two Jakarta RESTful Web Services
        applications overlap requires an analysis of the resource paths and
        all of sub-resource paths. If any of these paths clash then the
        entirety of the shadowed application must be unregistered and marked
        as a failure. It is an implementation error for some application
        resource paths to be available while others are shadowed.</para>
      </listitem>

      <listitem>
        <para><emphasis>Class-Space Compatibility</emphasis> - Much of the
        Jakarta RESTful Web Services mapping definition is handled using annotations with runtime
        visibility. As Jakarta RESTful Web Services beans are POJOs there is no guarantee of
        class-space compatibility when the Jakarta RESTful Web Services implementation searches for
        whiteboard services. The Jakarta RESTful Web Services whiteboard must therefore confirm that
        the registered service shares the correct view of the Jakarta RESTful Web Services packages.
        If the class space is not consistent then the Jakarta RESTful Web Services whiteboard
        container must not register the services, but instead should create a
        failure DTO indicating that the Jakarta RESTful Web Services object is unable to be
        registered due to an incompatible class-space.</para>
      </listitem>

      <listitem>
        <para><emphasis>Missing Required Extensions</emphasis> - If a Jakarta RESTful Web Services
        resource or extension requires one or more extensions using a
        <code>osgi.jakartars.extension.select</code> filter then at any given time
        it is possible that the Jakarta RESTful Web Services container will not be able to host the
        resource. At this time a failure DTO must be created for the relevant
        resource or extension service.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>The Jakarta RESTful Web Services Client API</title>

    <para>The Jakarta RESTful Web Services specification includes a client API for making REST
    requests. The normal mechanism for obtaining a <code>Client</code> is to
    use a <code>ClientBuilder</code>, which is instantiated using a static
    factory method. Static factory methods require the reflective loading of
    classes and suffer from significant lifecycle issues, as there is no way
    to force indirectly wired objects to be discarded if the implementation
    bundle is stopped or uninstalled.</para>

    <para>Jakarta RESTful Web Services implementations must therefore register their ClientBuilder
    implementations as OSGi services for bundles to use in making Client
    instances. The ClientBuilder must be registered as a prototype scoped
    service. This allows bundles to configure multiple separate Client
    instances, and ensures that separate bundles will never accidentally
    provide conflicting configuration to the same ClientBuilder
    instance.</para>

    <section>
      <title>Client Filters, Interceptors, Readers and Writers</title>

      <para>While Container extensions can be made available using whiteboard
      services, the same is not true for Clients. There are two main reasons
      for this:</para>

      <orderedlist>
        <listitem>
          <para>There is no simple way to scope the filters and interceptors
          that would be applied to a given client. In a multi-tenant
          environment this could lead to unexpected behaviors.</para>
        </listitem>

        <listitem>
          <para>Clients are not, in general, expected to be extended by third
          parties. The Client model is designed to be used by a bundle when
          making requests from a REST API. If further requests need to be made
          by a different bundle then it should create and configure a separate
          client. This is different from the whiteboard server, where one
          container port may host several distinct sets of resources.</para>
        </listitem>
      </orderedlist>

      <para>In order to add filters, interceptors, readers and writers to the
      Jakarta RESTful Web Services client users should use the <code>ClientBuilder#register()</code>
      method when building their client.</para>
    </section>

    <section>
      <title>Reactive Clients</title>

      <para>The Jakarta RESTful Web Services client API supports both synchronous and asynchronous
      calls. In Jakarta RESTful Web Services 2.1 the asynchronous behavior of the client was
      extended using the <code>RxInvoker</code> (reactive invoker) interface.
      All clients are required to support a reactive invoker which returns
      CompletionStage instances, however in OSGi the common representation of
      an asynchronous return is the <code>Promise</code>. This specification
      therefore provides the <xref
      linkend="org.osgi.service.jakartars.client.PromiseRxInvoker"
      xrefstyle="hyperlink"/> interface which can be used to obtain Promises
      from the Jakarta RESTful Web Services client.</para>

      <para>It is the responsibility of the Jakarta RESTful Web Services whiteboard implementation
      to create instances of <code>PromiseRxInvoker</code>. The exact
      mechanism by which instances are created is undefined, however it is
      possible to register a portable factory to create
      <code>PromiseRxInvoker</code> instances by implementing the
      <code>RxInvokerProvider</code> interface and registering this type with
      the Jakarta RESTful Web Services client. This portable implementation, however, is forced to
      use a blocking model by the underlying Jakarta RESTful Web Services API, and so
      implementations may choose to implement a more optimized non-blocking
      model using internal types.</para>

      <para>Clients of this specification may make use of the
      <code>PromiseRxInvoker</code> using normal Jakarta RESTful Web Services idioms. For
      example:</para>

      <programlisting>Client client = clientBuilder.build();
Promise&lt;String&gt; p = client.target(REST_SERVICE_URL)
    .path("/foo")
    .path("/{name}")
    .resolveTemplate("name", buzz)
    .request()
    .rx(PromiseRxInvoker.class)
    .get(String.class);</programlisting>
    </section>

    <section>
      <title>Consuming Server Sent Events</title>

      <para>In Jakarta RESTful Web Services 2.1 support was added for Server Sent Events. These
      events are consumed by a REST client using the
      <code>SseEventSource</code>. The <code>SseEventSource</code> is not
      created by a Jakarta RESTful Web Services client instance, but is normally created using a
      static factory method, which does not work in a modular environment.
      Therefore the Jakarta RESTful Web Services whiteboard implementation must register a
      <code>SseEventSourceFactory</code> service in the service registry. This
      object serves as a factory for the Jakarta RESTful Web Services SSE types.</para>

      <para>Note that the SseEventSource has no way to register filters or
      message body processors. All of the filters and necessary processors
      must be registered with the Jakarta RESTful Web Services client that is used to create the
      <code>WebTarget</code> used when building the SseEventSource. A client
      may therefore consume Server Sent Events in the following way:</para>

      <programlisting>Client client = clientBuilder.build();

WebTarget target = client.target(REST_SERVICE_URL)
    .path("/foo")
    .path("/{name}")
    .resolveTemplate("name", buzz);

SseEventSource source = sseFactory.newSource(target);
    
source.register(event -&gt; doSomething(event));
    
source.open();</programlisting>

      <para>A <code>SseEventSource</code> may easily be converted into a
      <code>PushEventSource</code> (and consequently a
      <code>PushStream</code>) as follows. Note that the implementation does
      not respond to back-pressure requests and should typically be used with
      a buffer.</para>

      <programlisting>SseEventSource source = sseBuilder.newSource(target);
    
PushEventSource&lt;InboundSseEvent&gt; pes = pec -&gt;
        source.register(e -&gt; {
                                try {
                                    if(pec.accept(PushEvent.data(e)) &lt; 0) {
                                        source.close();
                                    }
                                } catch (Exception e) {
                                    try {
                                        pec.accept(PushEvent.error(e));
                                    } finally {
                                        source.close();
                                    } 
                                }
                            },
                        t -&gt; pec.accept(PushEvent.error(t)),
                        () -&gt; pec.accept(PushEvent.close()));
        source.open();
        return source;
    };</programlisting>
    </section>
  </section>

  <section>
    <title>Portability and Interoperability</title>

    <para>The extensions defined by the Jakarta RESTful Web Services specification make Jakarta RESTful Web Services
    runtimes highly plugable, and it is common to extend the behavior of an
    application using this model. In many cases the custom behaviors are
    specific to a particular use case, for example mapping a specific
    exception into a <code>Response</code>, and there is no need for
    portability. In some common cases, however, there are extensions that can
    be used across a great many applications.</para>

    <para>In order to ensure that a Jakarta RESTful Web Services whiteboard application can make use
    of a common extension service in a portable way this specification defines
    standard service property names that should be registered, as appropriate,
    by whiteboard extension services, whiteboard applications with static
    extensions, and Jakarta RESTful Web Services whiteboard implementations that provide built-in
    extension capabilities.</para>

    <section>
      <title>Media Type support</title>

      <para>A common use of the Jakarta RESTful Web Services extension mechanism is to provide
      support for additional media types, both for consuming incoming requests
      and for producing responses. All Jakarta RESTful Web Services whiteboards must implicitly
      support <code>text/plain</code> and <code>application/xml</code> (using
      JAXB), however commonly used media types, such as
      <code>application/json</code> must be provided as an extension.</para>

      <para>To ensure that whiteboard resources can depend on support for a
      particular media type in a portable way this specification defines the
      <code>osgi.jakartars.media.type</code> property. This property key should be
      registered with one or more media types that are supported, and may be
      provided by:</para>

      <itemizedlist>
        <listitem>
          <para>A Whiteboard extension - if the extension provides general
          purpose support for reading from and writing to a media type then it
          should register this property.</para>
        </listitem>

        <listitem>
          <para>A Whiteboard application - if the application provides general
          purpose support for reading from and writing to a media type using a
          static extension then it should register this property.</para>
        </listitem>

        <listitem>
          <para>A Jakarta RESTful Web Services Whiteboard implementation - if the implementation
          provides general purpose built-in support for reading from and
          writing to a media type then it should register this property. If
          the built-in extension is always available then it should also be
          advertised by the <xref linkend="service.jakartars-service.capability"/>
          for the JakartarsServiceRuntime.</para>
        </listitem>
      </itemizedlist>

      <para>The term general purpose is used to indicate that the media type
      support must not require implementation specific mapping metadata (for
      example annotations) and should, at a minimum, work with the OSGi scalar
      types and DTOs. The property key is available as a constant in <xref
      linkend="org.osgi.service.jakartars.whiteboard.JakartarsWhiteboardConstants.JAKARTA_RS_MEDIA_TYPE"
      xrefstyle="hyperlink"/>.</para>

      <section>
        <title>Media Type names, wildcards and suffixes</title>

        <para>Where possible the value(s) of the
        <code>osgi.jakartars.media.type</code> property should use the IANA
        registered names of the media type(s) supported, for example
        <code>application/json</code>. Officially registered media types are
        available from <xref linkend="service.jakartars-iana.media.types"/>. If
        there is no officially registered media type then a vendor type should
        be used. Personal types may also be used, however due to the lack of
        portability afforded by personal types it is recommended that a
        non-standard property key is used for personal types.</para>

        <para>Wildcard types (containing a <code>*</code>) are often used by
        extensions to indicate that they can create a variety of different
        media types. Rarely this is because the extension can serialize into
        multiple different formats. More typically this is because the
        extension can serialize into a format which has multiple names, or
        multiple formats which use the same basic serialization. Suffixes can
        further modify this behavior, for example VCards may be serialized as
        XML using <code>application/vcard+xml</code> or as JSON using
        <code>application/vcard+json</code>.</para>

        <para>Wildcard types must not be used as values for the
        <code>osgi.jakartars.media.type</code> property as these do not provide
        sufficient information for whiteboard resources to reliably select a
        media type provider. Where a provider wishes to advertise support for
        a general suffix, for example <code>+json</code> or <code>+cbor</code>
        then the provider must advertise the primary media type associated
        with the suffix; in the supplied example these would be
        <code>application/json</code> and <code>application/cbor</code>.
        Clients wishing to use suffixed types should therefore also depend on
        the primary media type, not the suffixed type, if they wish to be
        portable. Where greater specificity is required it is recommended that
        the extension be selected based on additional custom properties. This
        should also be used for suffixes that have no primary type, for
        example <code>+der</code>. Official media type registrations are
        available from <xref
        linkend="service.jakartars-iana.media.type.suffixes"/></para>
      </section>

      <section>
        <title>Media Type Selection Example</title>

        <para>The most commonly required media type for Jakarta RESTful Web Services services is
        <code>application/json</code>. To this end this specification defines
        a Component Property annotation <xref
        linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JSONRequired"
        xrefstyle="hyperlink"/> which can be applied to a Declarative Services
        component to express:</para>

        <itemizedlist>
          <listitem>
            <para>An extension requirement for runtime
            <code>application/json</code> media type support</para>
          </listitem>

          <listitem>
            <para>A requirement for the Jakarta RESTful Web Services whiteboard</para>
          </listitem>

          <listitem>
            <para>An optional active time requirement for
            <code>application/json</code> media type support, for use in
            application resolution/assembly.</para>
          </listitem>
        </itemizedlist>

        <para>Custom third-party annotations can easily be created to support
        additional media types as necessary, and are used as follows:</para>

        <programlisting>@Component(service = MyResource.class,
      scope = ServiceScope.PROTOTYPE)
 @JakartarsResource
 @JSONRequired
 @Produces(MediaType.APPLICATION_JSON)  
 public class MyResource {
  
    @Path(“foo”)
    @GET
    public List&lt;String&gt; getFoos() {
        return Arrays.asList("foo", "bar", "baz");
    }
}</programlisting>

        <para>A corresponding component property type (<xref
        linkend="org.osgi.service.jakartars.whiteboard.propertytypes.JakartarsMediaType"
        xrefstyle="hyperlink"/>) exists for use on a Jakarta RESTful Web Services whiteboard
        extension or application service which provides media type support.
        This can be used to declare that one or more media types are
        supported.</para>

        <programlisting>@Component(scope = ServiceScope.PROTOTYPE)
 @JakartarsExtension
 @JakartarsMediaType(MediaType.APPLICATION_JSON)
 public class MyFeature implements Feature {
  
    public boolean configure(FeatureContext context) {
    		context.register(MyJSONCodec.class);
        return true;
    }
}</programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>Capabilities</title>

    <section>
      <title>osgi.implementation Capability</title>

      <para>The Jakarta RESTful Web Services Whiteboard implementation bundle must provide the <link
      linkend="service.namespaces-osgi.implementation.namespace"><code>osgi.implementation</code></link>
      capability with name <code>osgi.jakartars</code>. This capability can be
      used by provisioning tools and during resolution to ensure that a Jakarta RESTful Web Services
      Whiteboard implementation is present to process the Whiteboard services
      defined in this specification. The capability must also declare a uses
      constraint for the <code>jakarta.ws.rs.*</code> specification packages,
      and for the and OSGi Jakarta RESTful Web Services Whiteboard package. The version of this
      capability must match the version of this specification:</para>

      <programlisting>Provide-Capability: osgi.implementation;
       osgi.implementation="osgi.jakartars";
       uses:="jakarta.ws.rs, jakarta.ws.rs.client, jakarta.ws.rs.container,
              jakarta.ws.rs.core, jakarta.ws.rs.ext, jakarta.ws.rs.sse, 
              org.osgi.service.jakartars.whiteboard";
       version:Version="<xref
          endterm="org.osgi.service.jakartars.whiteboard-version.number"
          linkend="org.osgi.service.jakartars.whiteboard"/>"</programlisting>

      <para>This capability must follow the rules defined for the <xref
      linkend="service.namespaces-osgi.implementation.namespace"/>.</para>
    </section>

    <section>
      <title>osgi.contract Capability</title>

      <para>The Jakarta RESTful Web Services Whiteboard implementation must provide a capability in
      the <link
      linkend="service.namespaces-osgi.contract.namespace"><code>osgi.contract</code></link>
      namespace with name <code>JakartaRest</code> if it exports the Jakarta RESTful Web Services
      specification packages. See <xref
      linkend="service.http.whiteboard-portable.java.contracts.ref"/>.</para>

      <para>Providing the <code>osgi.contract</code> capability enables
      developer to build portable bundles for packages that are not versioned
      under OSGi Semantic Versioning rules. For more details see <xref
      linkend="service.namespaces-osgi.contract.namespace"/>.</para>

      <para>If the Jakarta RESTful Web Services API is provided by another bundle, the Jakarta RESTful Web Services
      Whiteboard implementation must be a consumer of the API and require the
      contract.</para>
    </section>

    <section xml:id="service.jakartars-service.capability">
      <title>osgi.service Capability</title>

      <para>The bundle providing the <xref
      linkend="org.osgi.service.jakartars.runtime.JakartarsServiceRuntime"
      xrefstyle="hyperlink"/> service must provide a capability in the <link
      linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
      namespace representing this service. This capability must also declare a
      uses constraint for the <code>org.osgi.service.jakartars.runtime</code> and
      <code>org.osgi.service.jakartars.runtime.dto</code> packages:</para>

      <programlisting>Provide-Capability: osgi.service;
  objectClass:List&lt;String&gt;="org.osgi.service.jakartars.runtime.JakartarsServiceRuntime";
  uses:="org.osgi.service.jakartars.runtime,org.osgi.service.jakartars.runtime.dto"</programlisting>

      <para>The bundle providing the
      <code>jakarta.ws.rs.client.ClientBuilder</code> service must also provide
      a capability in the <link
      linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
      namespace representing this service. This capability must declare that
      the service is prototype scope, and that there is a uses constraint for
      the <code>jakarta.ws.rs.client</code> package:</para>

      <programlisting>Provide-Capability: osgi.service;
  objectClass:List&lt;String&gt;="jakarta.ws.rs.client.ClientBuilder";
  uses:="jakarta.ws.rs.client,org.osgi.service.jakartars.client";
  service.scope="prototype"</programlisting>

      <para>The bundle providing the
      <code>org.osgi.service.jakartars.client.SseEventSourceFactory</code> service
      must also provide a capability in the <link
      linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
      namespace representing this service. This capability must declare a uses
      constraint for the <code>org.osgi.service.jakartars.client</code>
      package:</para>

      <programlisting>Provide-Capability: osgi.service;
  objectClass:List&lt;String&gt;="org.osgi.service.jakartars.client.SseEventSourceFactory";
  uses:="org.osgi.service.jakartars.client"</programlisting>

      <para>These capabilities must follow the rules defined for the <xref
      linkend="service.namespaces-osgi.service.namespace"/>.</para>
    </section>
  </section>

  <section>
    <title>Security</title>

    <para>This section only applies when executing in an OSGi environment
    which is enforcing Java permissions.</para>

    <section>
      <title>Service Permissions</title>

      <para>Bundles that need to register Jakarta RESTful Web Services Whiteboard services must be
      granted <code>ServicePermission[interfaceName, REGISTER]</code> where
      interface name is the relevant Jakarta RESTful Web Services Whiteboard service interface
      name.</para>

      <para>The Http Whiteboard implementation must be granted
      <code>ServicePermission[*, GET]</code> to retrieve the Jakarta RESTful Web Services Whiteboard
      services from the service registry.</para>
    </section>

    <section>
      <title>Runtime Introspection</title>

      <para>Bundles that need to introspect the state of the Jakarta RESTful Web Services runtime
      will need
      <code>ServicePermission[org.osgi.service.jakartars.runtime.JakartarsServiceRuntime,
      GET]</code> to obtain the Jakarta RESTful Web Services Service Runtime service and access the
      DTO types.</para>
    </section>

    <section>
      <title>Calling Jakarta RESTful Web Services Whiteboard Services</title>

      <para>This specification does not require that the Jakarta RESTful Web Services Whiteboard
      implementation is granted All Permission or wraps calls to the Jakarta RESTful Web Services
      Whiteboard services in a <code>doPrivileged</code> block. Therefore, it
      is the responsibility of the Jakarta RESTful Web Services Whiteboard services to use a
      <code>doPrivileged</code> block when performing privileged
      operations.</para>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.jakartars.client.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.jakartars.runtime.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.jakartars.runtime.dto.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.jakartars.whiteboard.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.jakartars.whiteboard.annotations.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.jakartars.whiteboard.propertytypes.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="service.jakartars-i21217577"><title>Java API for
      RESTful Web Services Specification</title><biblioid class="uri"><link
      xlink:href="https://jcp.org/en/jsr/detail?id=370"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.jakartars-portable.java.contracts.ref"><title>Portable Java
      Contract Definitions</title><biblioid class="uri"><link
      xlink:href="https://docs.osgi.org/reference/portable-java-contracts.html"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.jakartars-whiteboard.pattern.ref"><title>Whiteboard
      Pattern</title><biblioid class="uri"><link
      xlink:href="https://docs.osgi.org/whitepaper/whiteboard-pattern/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.jakartars-iana.media.types"><title>IANA Media
      Type Registrations</title><biblioid class="uri"><link
      xlink:href="https://www.iana.org/assignments/media-types/media-types.xhtml"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.jakartars-iana.media.type.suffixes"><title>IANA
      Media Type Suffix Registrations</title><biblioid class="uri"><link
      xlink:href="https://www.iana.org/assignments/media-type-structured-suffix/media-type-structured-suffix.xhtml"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
