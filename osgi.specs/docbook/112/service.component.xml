<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->
<chapter label="112"
         revision="$Id$"
         version="5.0" xml:id="service.component"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Declarative Services Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.component-version"
    linkend="org.osgi.service.component"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The OSGi Framework contains a procedural service model which
    provides a publish/find/bind model for using
    <emphasis>services</emphasis>. This model is elegant and powerful, it
    enables the building of applications out of bundles that communicate and
    collaborate using these services.</para>

    <para>This specification addresses some of the complications that arise
    when the OSGi service model is used for larger systems and wider
    deployments, such as:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Startup Time</emphasis> - The procedural service model
        requires a bundle to actively register and acquire its services. This
        is normally done at startup time, requiring all present bundles to be
        initialized with a Bundle Activator. In larger systems, this quickly
        results in unacceptably long startup times.</para>
      </listitem>

      <listitem>
        <para><emphasis>Memory Footprint</emphasis> - A service registered
        with the Framework implies that the implementation, and related
        classes and objects, are loaded in memory. If the service is never
        used, this memory is unnecessarily occupied. The creation of a class
        loader may therefore cause significant overhead.</para>
      </listitem>

      <listitem>
        <para><emphasis>Complexity</emphasis> - Service can come and go at any
        time. This dynamic behavior makes the service programming model more
        complex than more traditional models. This complexity negatively
        influences the adoption of the OSGi service model as well as the
        robustness and reliability of applications because these applications
        do not always handle the dynamicity correctly.</para>
      </listitem>
    </itemizedlist>

    <para>The <emphasis>service component</emphasis> model uses a declarative
    model for publishing, finding and binding to OSGi services. This model
    simplifies the task of authoring OSGi services by performing the work of
    registering the service and handling service dependencies. This minimizes
    the amount of code a programmer has to write; it also allows service
    components to be loaded only when they are needed. As a result, bundles
    need not provide a <code>BundleActivator</code> class to collaborate with
    others through the service registry.</para>

    <para>From a system perspective, the service component model means reduced
    startup time and potentially a reduction of the memory footprint. From a
    programmer's point of view the service component model provides a
    simplified programming model.</para>

    <para>The Service Component model makes use of concepts described in <xref
    linkend="i1550732"/>.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Backward Compatibility</emphasis> - The service
          component model must operate seamlessly with the existing service
          model.</para>
        </listitem>

        <listitem>
          <para><emphasis>Size Constraints</emphasis> - The service component
          model must not require memory and performance intensive subsystems.
          The model must also be applicable on resource constrained
          devices.</para>
        </listitem>

        <listitem>
          <para><emphasis>Delayed Activation</emphasis> - The service
          component model must allow delayed activation of a service
          component. Delayed activation allows for delayed class loading and
          object creation until needed, thereby reducing the overall memory
          footprint.</para>
        </listitem>

        <listitem>
          <para><emphasis>Simplicity</emphasis> - The programming model for
          using declarative services must be very simple and not require the
          programmer to learn a complicated API or XML sub-language.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dependency Injection</emphasis> - The programming
          model for using declarative services supports three types of
          dependency injection: method injection, field injection, and
          constructor injection.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reactive</emphasis> - It must be possible to react
          to changes in the external dependencies with different
          policies.</para>
        </listitem>

        <listitem>
          <para><emphasis>Annotations</emphasis> - Annotations must be
          provided that can leverage the type information to create the XML
          descriptor.</para>
        </listitem>

        <listitem>
          <para><emphasis>Introspection</emphasis> - It must be possible to
          introspect the service components.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Service Component</emphasis> - A service component
          contains a description that is interpreted at run time to create and
          dispose objects depending on the availability of other services, the
          need for such an object, and available configuration data. Such
          objects can optionally provide a service. This specification also
          uses the generic term <emphasis>component</emphasis> to refer to a
          service component.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Component Runtime (SCR)</emphasis> - The
          actor that manages the components and their life cycle and allows
          introspection of the components.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Description</emphasis> - The declaration
          of a service component. It is contained within an XML document in a
          bundle.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Properties</emphasis> - A set of
          properties which can be specified by the component description,
          Configuration Admin service and from the component factory.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Property Type</emphasis> - A user defined
          annotation type which defines component properties and is
          implemented by SCR to provide type safe access to the defined
          component properties.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Configuration</emphasis> - A component
          configuration represents a component description parameterized by
          component properties. It is the entity that tracks the component
          dependencies and manages a component instance. An activated
          component configuration has a component context.</para>
        </listitem>

        <listitem>
          <para><emphasis>Component Instance</emphasis> - An instance of the
          component implementation class. A component instance is created when
          a component configuration is activated and discarded when the
          component configuration is deactivated. A component instance is
          associated with exactly one component configuration.</para>
        </listitem>

        <listitem>
          <para><emphasis>Delayed Component</emphasis> - A component whose
          component configurations are activated when their service is
          requested.</para>
        </listitem>

        <listitem>
          <para><emphasis>Immediate Component</emphasis> - A component whose
          component configurations are activated immediately upon becoming
          satisfied.</para>
        </listitem>

        <listitem>
          <para><emphasis>Factory Component</emphasis> - A component whose
          component configurations are created and activated through the
          component's component factory.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reference</emphasis> - A specified dependency of a
          component on a set of target services.</para>
        </listitem>

        <listitem>
          <para><emphasis>Target Services</emphasis> - The set of services
          that is defined by the reference interface and target property
          filter.</para>
        </listitem>

        <listitem>
          <para><emphasis>Bound Services</emphasis> - The set of target
          services that are bound to a component configuration.</para>
        </listitem>

        <listitem>
          <para><emphasis>Event methods</emphasis> - The bind, updated, and
          unbind methods associated with a Reference.</para>
        </listitem>
      </itemizedlist>

      <figure pgwide="1">
        <title>Service Component Runtime, org.osgi.service.component
        package</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.876in"
                       contentwidth="7.000in" fileref="component-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Synopsis</title>

      <para>The Service Component Runtime reads component descriptions from
      started bundles. These descriptions are in the form of XML documents
      which define a set of components for a bundle. A component can refer to
      a number of services that must be available before a component
      configuration becomes satisfied. These dependencies are defined in the
      descriptions and the specific target services can be influenced by
      configuration information in the Configuration Admin service. After a
      component configuration becomes satisfied, a number of different
      scenarios can take place depending on the component type:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Immediate Component</emphasis> - The component
          configuration of an immediate component must be activated
          immediately after becoming satisfied. Immediate components may
          provide a service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Delayed Component</emphasis> - When a component
          configuration of a delayed component becomes satisfied, SCR will
          register the service specified by the <code>service</code> element
          without activating the component configuration. If this service is
          requested, SCR must activate the component configuration creating an
          instance of the component implementation class that will be returned
          as the service object. If the <code>scope</code> attribute of the
          <code>service</code> element is <code>bundle</code>, then, for each
          distinct bundle that requests the service object, a different
          component configuration is created and activated and a new instance
          of the component implementation class is returned as the service
          object. If the <code>scope</code> attribute of the
          <code>service</code> element is <code>prototype</code>, then, for
          each distinct request for the service object, such as via
          <code>ServiceObjects</code>, a different component configuration is
          created and activated and a new instance of the component
          implementation class is returned as the service object.</para>
        </listitem>

        <listitem>
          <para><emphasis>Factory Component</emphasis> - If a component's
          description specifies the <code>factory</code> attribute of the
          <code>component</code> element, SCR will register a Component
          Factory service. This service allows client bundles to create and
          activate multiple component configurations and dispose of them. If
          the component's description also specifies a <code>service</code>
          element, then as each component configuration is activated, SCR will
          register it as a service.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Readers</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Architects</emphasis> - The chapter, <xref
          linkend="service.component-components"/>, gives a comprehensive
          introduction to the capabilities of the component model. It explains
          the model with a number of examples. The section about <xref
          linkend="service.component-component.lifecycle"/> provides some
          deeper insight in the life cycle of components.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Programmers</emphasis> - Service programmers
          should read <xref linkend="service.component-components"/>. This
          chapter should suffice for the most common cases. For the more
          advanced possibilities, they should consult <xref
          linkend="service.component-component.description"/> for the details
          of the XML grammar for component descriptions.</para>
        </listitem>

        <listitem>
          <para><emphasis>Deployers</emphasis> - Deployers should consult
          <xref linkend="service.component-deployment"/>.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="service.component-components">
    <title>Components</title>

    <para>A component is a normal Java class contained within a bundle. The
    distinguishing aspect of a component is that it is
    <emphasis>declared</emphasis> in an XML document. Component configurations
    are activated and deactivated under the full control of SCR. SCR bases its
    decisions on the information in the component's description. This
    information consists of basic component information like the name and
    type, optional services that are implemented by the component, and
    <emphasis>references</emphasis>. References are dependencies that the
    component has on other services.</para>

    <para>SCR must <emphasis>activate</emphasis> a component configuration
    when the component is enabled and the component configuration is satisfied
    and a component configuration is needed. During the life time of a
    component configuration, SCR can notify the component of changes in its
    bound references.</para>

    <para>SCR will <emphasis>deactivate</emphasis> a previously activated
    component configuration when the component becomes disabled, the component
    configuration becomes unsatisfied, or the component configuration is no
    longer needed.</para>

    <para>If an activated component configuration's configuration properties
    change, SCR must either notify the component configuration of the change,
    if the component description specifies a method to be notified of such
    changes, or deactivate the component configuration and then attempt to
    reactivate the component configuration using the new configuration
    information.</para>

    <section>
      <title>Declaring a Component</title>

      <para>A component requires the following artifacts in the bundle:</para>

      <itemizedlist>
        <listitem>
          <para>An XML document that contains the component
          description.</para>
        </listitem>

        <listitem>
          <para>The <code>Service-Component</code> manifest header which names
          the XML documents that contain the component descriptions.</para>
        </listitem>

        <listitem>
          <para>An implementation class that is specified in the component
          description.</para>
        </listitem>
      </itemizedlist>

      <para>The elements in the component's description are defined in <xref
      linkend="service.component-component.description"/>. The XML grammar for
      the component declaration is defined by the XML Schema, see <xref
      linkend="service.component-schema"/>.</para>
    </section>

    <section>
      <title>Immediate Component</title>

      <para>An <emphasis>immediate component</emphasis> is activated as soon
      as its dependencies are satisfied. If an immediate component has no
      dependencies, it is activated immediately. A component is an immediate
      component if it is not a factory component and either does not specify a
      service or specifies a service and the <code>immediate</code> attribute
      of the <code>component</code> element set to <code>true</code>. If an
      immediate component configuration is satisfied and specifies a service,
      SCR must register the component configuration as a service in the
      service registry and then activate the component configuration.</para>

      <para>For example, the bundle entry <code>/OSGI-INF/activator.xml</code>
      contains:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.activator"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.Activator"/&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The manifest header <code>Service-Component</code> must also be
      specified in the bundle manifest. For example:</para>

      <programlisting>Service-Component: OSGI-INF/activator.xml</programlisting>

      <para>An example class for this component could look like:</para>

      <programlisting>public class Activator {
    public Activator() {...}
    private void activate(BundleContext context) {...}
    private void deactivate() {...}  
}</programlisting>

      <para>This example component is virtually identical to a Bundle
      Activator. It has no references to other services so it will be
      satisfied immediately. It publishes no service so SCR will activate a
      component configuration immediately.</para>

      <para>The <code>activate</code> method is called when SCR activates the
      component configuration and the <code>deactivate</code> method is called
      when SCR deactivates the component configuration. If the
      <code>activate</code> method throws an Exception, then the component
      configuration is not activated and will be discarded.</para>
    </section>

    <section>
      <title>Delayed Component</title>

      <para>A <emphasis>delayed component</emphasis> specifies a service, is
      not specified to be a factory component and does not have the
      <code>immediate</code> attribute of the <code>component</code> element
      set to <code>true</code>. If a delayed component configuration is
      satisfied, SCR must register the component configuration as a service in
      the service registry but the activation of the component configuration
      is delayed until the registered service is requested. The registered
      service of a delayed component looks like a normal registered service
      but does not incur the overhead of an ordinarily registered service that
      require a service's bundle to be initialized to register the
      service.</para>

      <para>For example, a bundle needs to see events of a specific topic. The
      Event Admin uses the white board pattern, receiving the events is
      therefore as simple as registering a Event Handler service. The example
      XML for the delayed component looks like:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.handler"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.HandlerImpl"/&gt;
    &lt;property name="event.topics"&gt;some/topic&lt;/property&gt;
    &lt;service&gt; 
        &lt;provide interface="org.osgi.service.event.EventHandler"/&gt; 
    &lt;/service&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The associated component class looks like:</para>

      <programlisting>public class HandlerImpl implements EventHandler{
    public void handleEvent(Event evt ) {
        ...
  }
}</programlisting>

      <para>The component configuration will only be activated once the Event
      Admin service requires the service because it has an event to deliver on
      the topic to which the component subscribed.</para>
    </section>

    <section xml:id="service.component-factorycomponent">
      <title>Factory Component</title>

      <para>Certain software patterns require the creation of component
      configurations on demand. For example, a component could represent an
      application that can be launched multiple times and each application
      instance can then quit independently. Such a pattern requires a factory
      that creates the instances. This pattern is supported with a
      <emphasis>factory component</emphasis>. A factory component is used if
      the <code>factory</code> attribute of the <code>component</code> element
      is set to a <emphasis>factory identifier</emphasis>. This identifier can
      be used by a bundle to associate the factory with externally defined
      information.</para>

      <para>SCR must register a Component Factory service on behalf of the
      component as soon as the component factory is satisfied. The service
      properties for the Component Factory service are the <emphasis>factory
      properties</emphasis> as specified by the <code>factory-property</code>
      and <code>factory-properties</code> elements of the component
      description. See <xref
      linkend="service.component-factoryproperty.factoryproperties.elements"/>.
      The service properties of the Component Factory service must not include
      the component properties. SCR always adds the following factory
      properties, which cannot be overridden:</para>

      <itemizedlist>
        <listitem>
          <para><code>component.name</code> - The name of the
          component.</para>
        </listitem>

        <listitem>
          <para><code>component.factory</code> - The factory
          identifier.</para>
        </listitem>
      </itemizedlist>

      <para>New configurations of the component can be created and activated
      by calling the <code>newInstance</code> method on this Component Factory
      service. The <xref
      linkend="org.osgi.service.component.ComponentFactory.newInstance-Dictionary-"
      xrefstyle="hyperlink"/> method has a <code>Dictionary</code> object as a
      parameter. This Dictionary object is merged with the component
      properties as described in <xref
      linkend="service.component-component.properties"/>. If the component
      specifies a service, then the service is registered after the created
      component configuration is satisfied with the component properties. Then
      the component configuration is activated.</para>

      <para>For example, a component can provide a connection to a USB device.
      Such a connection should normally not be shared and should be created
      each time such a service is needed. The component description to
      implement this pattern looks like:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.factory"
    factory="usb.connection"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.USBConnectionImpl"/&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component class looks like:</para>

      <programlisting>public class USBConnectionImpl {
    private void activate(Map&lt;String, ?&gt; properties) {
     ...
    }
}</programlisting>

      <para>A factory component can be associated with a service. In that
      case, such a service is registered for each component configuration. For
      example, the previous example could provide a USB Connection
      service.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.factory"    
    factory="usb.connection"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.USBConnectionImpl"/&gt;
    <emphasis role="underline">&lt;service&gt;</emphasis>
        &lt;provide interface="com.acme.usb.USBConnection"/&gt;
    &lt;/service&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The associated component class looks like:</para>

      <programlisting>public class USBConnectionImpl implements USBConnection {
    private void activate(Map&lt;String, ?&gt; properties) {...}
    public void connect() { ... }
    ...
    public void close() { ... }
}</programlisting>

      <para>A new service will be registered each time a new component
      configuration is created and activated with the <code>newInstance</code>
      method. This allows a bundle other than the one creating the component
      configuration to utilize the service. If the component configuration is
      deactivated, the service must be unregistered.</para>
    </section>
  </section>

  <section>
    <title>References to Services</title>

    <para>Most bundles will require access to other services from the service
    registry. The dynamics of the service registry require care and attention
    of the programmer because referenced services, once acquired, could be
    unregistered at any moment. The component model simplifies the handling of
    these service dependencies significantly.</para>

    <para>The services that are selected by a reference are called the
    <emphasis>target services</emphasis>. These are the services selected by
    the <code>BundleContext.getServiceReferences</code> method where the first
    argument is the reference's interface and the second argument is the
    reference's target property, which must be a valid filter.</para>

    <para>A component configuration becomes <emphasis>satisfied</emphasis>
    when each specified reference is satisfied. A reference is
    <emphasis>satisfied</emphasis> if it specifies optional cardinality or
    when the number of target services is equal to or more than the minimum
    cardinality of the reference. An activated component configuration that
    becomes <emphasis>unsatisfied</emphasis> must be deactivated.</para>

    <para>During the activation of a component configuration, SCR must bind
    some or all of the target services of a reference to the component
    configuration. Any target service that is bound to the component
    configuration is called a <emphasis>bound</emphasis> service. See <xref
    linkend="service.component-bound.services"/>.</para>

    <section xml:id="service.component-accessing.services">
      <title>Accessing Services</title>

      <para>A component instance must be able to use the services that are
      referenced by the component configuration, that is, the bound services
      of the references. The following techniques are available for a
      component instance to acquire these bound services:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Method injection</emphasis> - SCR calls a method on
          the component instance when a service becomes bound, when a service
          becomes unbound, or when its properties are updated. These methods
          are the bind, updated, and unbind methods specified by the
          reference. Method injection is useful if the component needs to be
          notified of changes to the bound services for a dynamic
          reference.</para>
        </listitem>

        <listitem>
          <para><emphasis>Field injection</emphasis> - SCR modifies a field in
          the component instance when a service becomes bound, when a service
          becomes unbound, or when its properties are updated.</para>
        </listitem>

        <listitem>
          <para><emphasis>Constructor injection</emphasis> - When SCR
          activates a component instance, the component instance must be
          constructed and constructor injection occurs. Bound services and
          activation objects can be parameters to the constructor.</para>
        </listitem>

        <listitem>
          <para><emphasis>Lookup strategy</emphasis> - A component instance
          can use one of the <code>locateService</code> methods of its <xref
          linkend="org.osgi.service.component.ComponentContext"
          xrefstyle="hyperlink"/> to locate a bound service. These methods
          take the <code>name</code> of the reference as a parameter. If the
          reference has a dynamic policy, it is important to not store
          returned service objects but look them up every time they are
          needed.</para>
        </listitem>
      </itemizedlist>

      <para>A component may use multiple strategies to access the bound
      services of a reference.</para>
    </section>

    <section xml:id="service.component-method.injection">
      <title>Method Injection</title>

      <para>When using method injection, SCR must call the component instance
      at the appropriate time. SCR must call on the following events:</para>

      <itemizedlist>
        <listitem>
          <para><code>bind</code> - The bind method, if specified, is called
          to bind a new service to the component that matches the selection
          criteria. If the <code>policy</code> is <code>dynamic</code> then
          the bind method of a replacement service can be called before its
          corresponding unbind method.</para>
        </listitem>

        <listitem>
          <para><code>updated</code> - The updated method, if specified, is
          called when the service properties of a bound services are modified
          and the resulting properties do not cause the service to become
          unbound because it is no longer selected by the target
          property.</para>
        </listitem>

        <listitem>
          <para><code>unbind</code> - The unbind method, if specified, is
          called when SCR needs to unbind the service.</para>
        </listitem>
      </itemizedlist>

      <para>Each event is associated with an <emphasis>event
      method</emphasis>.</para>

      <para>An event method can take one or more parameters. Each parameter
      must be of one of the following types:</para>

      <itemizedlist>
        <listitem>
          <para><code>&lt;service-type&gt;</code> - The bound service
          object.</para>
        </listitem>

        <listitem>
          <para><code>ServiceReference</code> - A Service Reference for the
          bound service. This Service Reference may later be passed to the
          <xref
          linkend="org.osgi.service.component.ComponentContext.locateService-String-ServiceReference-"
          xrefstyle="hyperlink"/> method to obtain the actual service object.
          This approach is useful when the service properties need to be
          examined before accessing the service object. It also allows for the
          delayed activation of bound services when using method
          injection.</para>
        </listitem>

        <listitem>
          <para><code>ComponentServiceObjects</code> - A Component Service
          Objects for the bound service. This Component Service Objects can be
          used to obtain the actual service object or objects. This approach
          is useful when the referenced service has prototype service scope
          and the component instance needs multiple service objects for the
          service.</para>
        </listitem>

        <listitem>
          <para><code>Map</code> - An unmodifiable Map containing the service
          properties of the bound service. This Map must additionally
          implement <code>Comparable</code> with the <code>compareTo</code>
          method comparing service property maps using an ordering which is
          the same as the natural ordering of <code>ServiceReference</code>s
          as specified in <code>ServiceReference.compareTo</code>.</para>
        </listitem>
      </itemizedlist>

      <para>A suitable method is selected using the following priority. If the
      type specified by the reference's <code>interface</code> attribute is
      <code>org.osgi.service.component.AnyService</code>, then the parameter
      type must be <code>java.lang.Object</code> to match.</para>

      <orderedlist>
        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>org.osgi.framework.ServiceReference</code>. This
          method will receive a Service Reference for the bound
          service.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <xref
          linkend="org.osgi.service.component.ComponentServiceObjects"
          xrefstyle="hyperlink"/>. This method will receive a Component
          Service Objects for the bound service.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is the type specified by the reference's
          <code>interface</code> attribute. This method will receive the bound
          service object.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is assignable from the type specified by the reference's
          <code>interface</code> attribute. If multiple methods match this
          rule, this implies the method name is overloaded and SCR may choose
          any of the methods to call. This method will receive the bound
          service object.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>java.util.Map</code>. This method will receive an
          unmodifiable Map containing the service properties of the bound
          service.</para>
        </listitem>

        <listitem>
          <para>The method takes two or more parameters and the types of the
          parameters must be one of: the type specified by the reference's
          <code>interface</code> attribute, a type assignable from the type
          specified by the reference's <code>interface</code> attribute,
          <code>org.osgi.framework.ServiceReference</code>, <xref
          linkend="org.osgi.service.component.ComponentServiceObjects"
          xrefstyle="hyperlink"/>, or <code>java.util.Map</code>. If multiple
          methods match this rule, this implies the method name is overloaded
          and SCR may choose any of the methods to call. In the case where the
          type specified by the reference's <code>interface</code> attribute
          is <code>org.osgi.framework.ServiceReference</code>, <xref
          linkend="org.osgi.service.component.ComponentServiceObjects"
          xrefstyle="hyperlink"/>, or <code>java.util.Map</code>, the first
          parameter of that type will receive the bound service object. If
          selected event method has more than one parameter of that type, the
          remaining parameters of that type will receive a Service Reference
          for the bound service, a Service Objects for the bound service, or
          an unmodifiable Map containing the service properties of the bound
          service.</para>
        </listitem>
      </orderedlist>

      <para>When searching for an event method to call, SCR must locate a
      suitable method as specified in <xref
      linkend="service.component-locating.members"/>. If no suitable method is
      located, SCR must log an error message with the Log Service, if present,
      and there will be no bind, updated, or unbind notification.</para>

      <para>The bind and unbind methods must be called once for each bound
      service. This implies that if the reference has multiple cardinality,
      then the methods may be called multiple times. The updated method can be
      called multiple times per service.</para>

      <para>In the following examples, a component requires the Logger Factory
      service. The first example uses the lookup strategy. The reference is
      declared without any bind, updated, and unbind methods:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.LogLookupImpl"/&gt;
    &lt;reference name="LOG"
        interface="org.osgi.service.log.LoggerFactory"/&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component implementation class must now lookup the service.
      This looks like:</para>

      <programlisting>public class LogLookupImpl {
    private void activate(ComponentContext ctxt) {
        LoggerFactory lf = ctxt.locateService("LOG");
        lf.getLogger(LogLookupImpl.class).info("Hello Components!");
    }
}</programlisting>

      <para>Alternatively, the component could use method injection and ask to
      be notified with the Logger Factory service by declaring bind, updated,
      and unbind methods.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.LogEventImpl"/&gt;
    &lt;reference name="LOG"
        interface="org.osgi.service.log.LoggerFactory"
        bind="setLog"
        updated="updatedLog"
        unbind="unsetLog"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component implementation class looks like:</para>

      <programlisting>public class LogEventImpl {
    LoggerFactory lf;
    Integer    level;
    void setLog( LoggerFactory l, Map&lt;String,?&gt; ref ) {
        lf = l;
        updatedLog(l, ref);
    }
    void updatedLog( LoggerFactory l, Map&lt;String,?&gt; ref) {
        level = (Integer) ref.get("level");
    }
    void unsetLog( LoggerFactory l ) { lf = null; }
    private void activate() {
        lf.getLogger(LogEventImpl.class).info("Hello Components!");
    }
}</programlisting>

      <para>Event methods can be declared private in the component class but
      are only looked up in the inheritance chain when they are protected,
      public, or have default access. See <xref
      linkend="service.component-locating.members"/>.</para>
    </section>

    <section xml:id="service.component-field.injection">
      <title>Field Injection</title>

      <para>When using field injection, SCR must modify fields in the
      component instance at the appropriate time. SCR must modify the fields
      on the following events:</para>

      <itemizedlist>
        <listitem>
          <para><code>bind</code> - The field is modified to bind a new
          service to the component that matches the selection criteria.</para>
        </listitem>

        <listitem>
          <para><code>updated</code> - For certain field types, the field is
          modified when the service properties of a bound services are
          modified and the resulting properties do not cause the service to
          become unbound because it is no longer selected by the target
          property.</para>
        </listitem>

        <listitem>
          <para><code>unbind</code> - The field is modified when SCR needs to
          unbind the service.</para>
        </listitem>
      </itemizedlist>

      <para>For a reference with unary cardinality, a field must be of one of
      the following types:</para>

      <itemizedlist>
        <listitem>
          <para><code>&lt;service-type&gt;</code> - The bound service object.
          The type of the field can be the actual service type or it can be a
          type that is assignable from the actual service type. If the type
          specified by the reference's <code>interface</code> attribute is
          <code>org.osgi.service.component.AnyService</code>, then the actual
          service type is considered to be
          <code>java.lang.Object</code>.</para>
        </listitem>

        <listitem>
          <para><code>ServiceReference</code> - A Service Reference for the
          bound service. This Service Reference may later be passed to the
          <xref
          linkend="org.osgi.service.component.ComponentContext.locateService-String-ServiceReference-"
          xrefstyle="hyperlink"/> method to obtain the actual service object.
          This approach is useful when the service properties need to be
          examined before accessing the service object. It also allows for the
          delayed activation of bound services when using field
          injection.</para>
        </listitem>

        <listitem>
          <para><code>ComponentServiceObjects</code> - A Component Service
          Objects for the bound service. This Component Service Objects can be
          used to obtain the actual service object or objects. This approach
          is useful when the referenced service has prototype service scope
          and the component instance needs multiple service objects for the
          service.</para>
        </listitem>

        <listitem>
          <para><code>Map</code> - An unmodifiable Map containing the service
          properties of the bound service. This Map must additionally
          implement <code>Comparable</code> with the <code>compareTo</code>
          method comparing service property maps using an ordering which is
          the same as the natural ordering of <code>ServiceReference</code>s
          as specified in <code>ServiceReference.compareTo</code>.</para>
        </listitem>

        <listitem>
          <para><code>Map.Entry</code> - An unmodifiable Map.Entry whose key
          is an unmodifiable Map containing the service properties of the
          bound service, as above, and whose value is the bound service
          object. This Map.Entry must additionally implement
          <code>Comparable</code> with the <code>compareTo</code> method
          comparing the service property map key using an ordering which is
          the same as the natural ordering of <code>ServiceReference</code>s
          as specified in <code>ServiceReference.compareTo</code>.</para>
        </listitem>

        <listitem>
          <para><code>Optional</code> - An Optional holding one of the above
          types. The type of object held in the Optional is specified by the
          <code>field-collection-type</code> attribute in the component
          description. The Optional must be empty for an optional reference
          with no bound service.</para>
        </listitem>
      </itemizedlist>

      <para>If the actual service type is one of
      <code>ServiceReference</code>, <code>ComponentServiceObjects</code>,
      <code>Map</code>, <code>Map.Entry</code>, or <code>Optional</code> the
      field will be set to the service object rather than the object about the
      service.</para>

      <para>For a reference with multiple cardinality, a field must be a
      collection of one of the following types:</para>

      <itemizedlist>
        <listitem>
          <para><code>Collection</code></para>
        </listitem>

        <listitem>
          <para><code>List</code></para>
        </listitem>

        <listitem>
          <para>A subtype of <code>Collection</code> - This type can only be
          used for dynamic references using the <code>update</code> reference
          field option. The component instance must initialize the field to a
          collection object in its constructor.</para>
        </listitem>
      </itemizedlist>

      <para>The type of objects set in the collection or the type of object
      held in the Optional is specified by the
      <code>field-collection-type</code> attribute in the component
      description:</para>

      <itemizedlist>
        <listitem>
          <para><code>service</code> - The bound service object. This is the
          default field collection type.</para>
        </listitem>

        <listitem>
          <para><code>reference</code> - A Service Reference for the bound
          service.</para>
        </listitem>

        <listitem>
          <para><code>serviceobjects</code> - A Component Service Objects for
          the bound service.</para>
        </listitem>

        <listitem>
          <para><code>properties</code> - An unmodifiable Map containing the
          service properties of the bound service. This Map must implement
          <code>Comparable</code>, as above.</para>
        </listitem>

        <listitem>
          <para><code>tuple</code> - An unmodifiable Map.Entry whose key is an
          unmodifiable Map containing the service properties of the bound
          service, as above, and whose value is the bound service object. This
          Map.Entry must implement <code>Comparable</code>, as above.</para>
        </listitem>
      </itemizedlist>

      <para>Only instance fields of the field types above are supported. If a
      referenced field is declared with the <code>static</code> modifier or
      has a type other than one of the above, SCR must log an error message
      with the Log Service, if present, and the field must not be modified.
      SCR must locate a suitable field as specified in <xref
      linkend="service.component-locating.members"/>. If no suitable field is
      located, SCR must log an error message with the Log Service, if present,
      and no field will be modified for the reference. If the bound
      service cannot be assigned to the field because the type is
      unassignable, SCR must log an error message containing the exception
      with the Log Service, if present, and no field will be modified for
      the reference.</para>

      <para>Care must be taken by the component implementation regarding the
      field. SCR has no way to know if the component implementation itself may
      alter the field value. The component implementation should not alter the
      field value and allow SCR to manage it. SCR must treat the field as if
      the component implementation does not alter the field value so SCR may
      retain its own copy of the value set in the field.</para>

      <para>In the following examples, a component requires the Logger Factory
      service.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.LogEventImpl"/&gt;
    &lt;reference name="LOG"
        interface="org.osgi.service.log.LoggerFactory"
        field="lf"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component implementation class looks like:</para>

      <programlisting>public class LogEventImpl {
    LoggerFactory lf;
    private void activate() {
        lf.getLogger(LogEventImpl.class).info("Hello Components!");
    }
}</programlisting>

      <para>Fields can be declared private in the component class but are only
      looked up in the inheritance chain when they are protected, public, or
      have default access. See <xref
      linkend="service.component-locating.members"/>.</para>
    </section>

    <section xml:id="service.component-constructor.injection">
      <title>Constructor Injection</title>

      <para>When using constructor injection, SCR must construct the component
      instance using the appropriate constructor passing activation objects
      and bound services as parameters. Since a component instance is only
      constructed once, constructor parameters for references must be for
      static references.</para>

      <para>A suitable constructor is selected using the following
      steps:</para>

      <orderedlist>
        <listitem>
          <para>If the constructor is not public, then the constructor must
          not be considered.</para>
        </listitem>

        <listitem>
          <para>If the constructor has a parameter count that does not match
          the value of the <code>init</code> attribute in the
          <code>component</code> element, then the constructor must not be
          considered. If the value of the <code>init</code> attribute is 0,
          the default value, then the public no-parameter constructor must be
          used.</para>
        </listitem>

        <listitem>
          <para>For the constructor parameters associated with a reference,
          that is, there is a reference with a <code>parameter</code>
          attribute whose value matches the zero-based parameter number of the
          constructor parameter, if the parameter type is not one of the types
          supported for field injection for a static reference, then the
          constructor must not be considered. See <xref
          linkend="service.component-field.injection"/> for information on
          types supported for field injection.</para>
        </listitem>

        <listitem>
          <para>For the constructor parameters not associated with a
          reference, if the parameter type is not assignable from one of the
          activation object types, then the constructor must not be
          considered. See <xref
          linkend="service.component-activation.objects"/> for information on
          activation object types.</para>
        </listitem>

        <listitem>
          <para>If only a single constructor remains, this constructor must be
          used to construct the component instance.</para>
        </listitem>

        <listitem>
          <para>If more than one constructor remains, this implies the
          constructor is overloaded and SCR may choose any of the remaining
          constructors to construct the component instance.</para>
        </listitem>
      </orderedlist>

      <para>When searching for the constructor to call, SCR must use
      reflection on the implementation class. If no suitable constructor is
      located, SCR must log an error message with the Log Service, if present,
      and the component configuration is not activated.</para>

      <para>If the constructor throws an exception, SCR must log an error
      message containing the exception with the Log Service, if present, and
      the component configuration is not activated. If the bound service
      cannot be assigned to the constructor parameter because the type is
      unassignable, SCR must log an error message containing the exception
      with the Log Service, if present, and the component configuration is not
      activated.</para>

      <para>If the constructor parameter is associated with a reference having
      cardinality of <code>0..1</code> and there is no bound service for the
      reference, then the value <code>null</code> will be supplied as the
      constructor parameter.</para>

      <para>In the following examples, a component requires the Logger Factory
      service.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen" init="1"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.LogEventImpl"/&gt;
    &lt;reference name="LOG"
        interface="org.osgi.service.log.LoggerFactory"
        parameter="0"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component implementation class looks like:</para>

      <programlisting>public class LogEventImpl {
    public LogEventImpl(LoggerFactory lf) {
        lf.getLogger(LogEventImpl.class).info("Hello Components!");
    }
}</programlisting>
    </section>

    <section xml:id="service.component-reference.cardinality">
      <title>Reference Cardinality</title>

      <para>A component implementation is always written with a certain
      <emphasis>cardinality</emphasis> for each reference in mind. The
      cardinality represents two important concepts:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Multiplicity</emphasis> - Does the component
          implementation assume a single service or does it explicitly handle
          multiple services? For example, when a component uses the Logger
          Factory service, it only needs to bind to one Logger Factory service
          to function correctly. Alternatively, when the Configuration Admin
          uses the Configuration Listener services it needs to bind to all
          target services present in the service registry to dispatch its
          events correctly.</para>
        </listitem>

        <listitem>
          <para><emphasis>Optionality</emphasis> - Can the component function
          without any bound service present? Some components can still perform
          useful tasks even when no service is available; other components
          must bind to at least one service before they can be useful. For
          example, the Configuration Admin in the previous example must still
          provide its functionality even if there are no Configuration
          Listener services present. Alternatively, an application that
          registers a Servlet with the Http Service has little to do when the
          Http Service is not present, it should therefore use a reference
          with a mandatory cardinality.</para>
        </listitem>
      </itemizedlist>

      <para>The cardinality is expressed with the following syntax:</para>

      <programlisting>cardinality  ::= optionality '..' multiplicity
optionality  ::= '0' | '1'
multiplicity ::= '1' | 'n'</programlisting>

      <para>The cardinality for a reference can be specified as one of four
      choices:</para>

      <itemizedlist>
        <listitem>
          <para><code>0..1</code> - Optional and unary.</para>
        </listitem>

        <listitem>
          <para><code>1..1</code> - Mandatory and unary (Default) .</para>
        </listitem>

        <listitem>
          <para><code>0..n</code> - Optional and multiple.</para>
        </listitem>

        <listitem>
          <para><code>1..n</code> - Mandatory and multiple.</para>
        </listitem>
      </itemizedlist>

      <para>The <emphasis>minimum cardinality</emphasis> is specified by the
      optionality part of the cardinality. This is either <code>0</code> or
      <code>1</code>. A minimum cardinality property can be used to raise the
      minimum cardinality of a reference from this initial value. For example,
      a <code>0..n</code> cardinality in the component description can be
      raised into a <code>3..n</code> cardinality at runtime by setting the
      minimum cardinality property for the reference to <code>3</code>. This
      would typically be done by a deployer setting the minimum cardinality
      property in a configuration for the component. The minimum cardinality
      for a unary cardinality cannot exceed <code>1</code>. See <xref
      linkend="service.component-minimum.cardinality.property"/> for more
      information.</para>

      <para>A reference is <emphasis>satisfied</emphasis> if the number of
      target services is equal to or more than the minimum cardinality. The
      <code>multiplicity</code> is irrelevant for the satisfaction of the
      reference. The <code>multiplicity</code> only specifies if the component
      implementation is written to handle being bound to multiple services
      (<code>n</code>) or requires SCR to select and bind to a single service
      (<code>1</code>).</para>

      <para>When a satisfied component configuration is activated, there must
      be at most one bound service for each reference with a unary cardinality
      and at least as many bound services as the minimum cardinality for each
      reference. If the cardinality constraints cannot be maintained after a
      component configuration is activated, that is the reference becomes
      unsatisfied, the component configuration must be deactivated. If the
      reference has a unary cardinality and there is more than one target
      service for the reference, then the bound service must be the target
      service whose <code>ServiceReference</code> is first in the ranking
      order as specified in <code>ServiceReference.compareTo</code>.</para>

      <para>In the following example, a component wants to register a resource
      with all Http Services that are available. Such a scenario has the
      cardinality of <code>0..n</code>. The code must be prepared to handle
      multiple calls to the bind method for each Http Service in such a case.
      In this example, the code uses the <code>registerResources</code> method
      to register a directory for external access.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.HttpResourceImpl"/&gt;
    &lt;reference name="HTTP"
        interface="org.osgi.service.http.HttpService"
        cardinality="0..n"
        bind="setPage"
        unbind="unsetPage"
    /&gt;
&lt;/scr:component&gt;

public class HttpResourceImpl {
    private void setPage(HttpService http) {
        http.registerResources("/scr", "scr", null );
    }
    private void unsetPage(HttpService http) {
        http.unregister("/scr");
    }
}</programlisting>
    </section>

    <section xml:id="service.component-reference.scope">
      <title>Reference Scope</title>

      <para>A component implementation must be written to understand the
      service scope of referenced services. The <emphasis>reference
      scope</emphasis> defines whether the component expects the bundle to be
      exposed to a single service object for a bound service or to potentially
      multiple services objects. The following reference scopes are
      available:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>bundle</emphasis> - For all references to a given
          bound service, all activated component instances within a bundle
          must use the same service object. That is, for a given bound
          service, all component instances within a bundle will be using the
          same service object. This is the default reference scope.</para>
        </listitem>

        <listitem>
          <para><emphasis>prototype</emphasis> - For all references to a given
          bound service, each activated component instance may use a single,
          distinct service object. That is, for a given bound service, each
          component instance may use a distinct service object but within a
          component instance all references to the bound service will use the
          same service object.</para>
        </listitem>

        <listitem>
          <para><emphasis>prototype_required</emphasis> - For all references
          to a given bound service, each activated component instance must use
          a single, distinct service object. That is, for a given bound
          service, each component instance will use a distinct service object
          but within a component instance all references to the bound service
          will use the same service object.</para>
        </listitem>
      </itemizedlist>

      <para>For a bound service of a reference with bundle reference scope,
      SCR must get the service object from the OSGi Framework's service
      registry using the <code>getService</code> method on the component's
      Bundle Context. If the service object for a bound service has been
      obtained and the service becomes unbound, SCR must unget the service
      object using the <code>ungetService</code> method on the component's
      Bundle Context and discard all references to the service object. This
      ensures that the bundle will only be exposed to a single instance of the
      service object at any given time.</para>

      <para>For a bound service of a reference with prototype or
      prototype_required reference scope, SCR must use a Service Objects
      object obtained from the OSGi Framework's service registry using the
      component's Bundle Context to get any service objects. If service
      objects for a bound service have been obtained and the service becomes
      unbound, SCR must unget any unreleased service objects using the Service
      Objects object obtained from the OSGi Framework's service registry using
      the component's Bundle Context. This means that if a component instance
      used a Component Service Objects object to obtain service objects, SCR
      must track those service objects so that when the service becomes
      unbound, SCR can unget any unreleased service objects.</para>

      <para>Additionally, for a reference with prototype_required reference
      scope, only services registered with prototype service scope can be
      considered as target services. This ensures that each component instance
      can be exposed to a single, distinct instance of the service object.
      Using prototype_required reference scope effectively adds
      <code>service.scope=prototype</code> to the target property for the
      reference. A service that does not use prototype service scope cannot be
      used as a bound service for a reference with prototype_required
      reference scope since the service cannot provide a distinct service
      object for each component instance.</para>
    </section>

    <section xml:id="service.component-reference.policy">
      <title>Reference Policy</title>

      <para>Once all the references of a component are satisfied, a component
      configuration can be activated and therefore bound to target services.
      However, the dynamic nature of the OSGi service registry makes it likely
      that services are registered, modified and unregistered after target
      services are bound. These changes in the service registry could make one
      or more bound services no longer a target service thereby making
      obsolete any object references that the component has to these service
      objects. Components therefore must specify a <emphasis>policy</emphasis>
      how to handle these changes in the set of bound services. A
      <emphasis>policy-option</emphasis> can further refine how changes affect
      bound services.</para>

      <section>
        <title>Static Reference Policy</title>

        <para>The <emphasis>static policy</emphasis> is the most simple policy
        and is the default policy. A reference with a static policy is called
        a <emphasis>static reference</emphasis>. A component instance never
        sees any of the dynamics of the static reference. The bind method is
        called and/or the field is set before the component instance is
        activated. Static references can also be used for parameters for
        constructor injection. Component configurations are deactivated before
        any bound service for the static reference becomes unavailable. If a
        target service is available to replace the bound service which became
        unavailable, the component configuration must be reactivated and the
        replacement service is bound to the new component instance.</para>

        <para>If the <code>policy-option</code> is <code>reluctant</code> then
        the registration of an additional target service for a reference must
        not result in deactivating and reactivating a component configuration.
        If the <code>policy-option</code> is <code>greedy</code> then the
        component configuration must be reactivated when new applicable
        services become available. See <xref
        linkend="service.component-policy.option.action"
        xrefstyle="template:Table %n on page %p"/>.</para>

        <para>If a static reference specifies an updated method and the bound
        service's properties change, SCR must call the updated method.</para>

        <para>The static policy can be very expensive if it depends on
        services that frequently unregister and re-register or if the cost of
        activating and deactivating a component configuration is high. Static
        policy is usually also not applicable if the cardinality specifies
        multiple bound services.</para>
      </section>

      <section>
        <title>Dynamic Reference Policy</title>

        <para>The <emphasis>dynamic policy</emphasis> is slightly more complex
        since the component implementation must properly handle changes in the
        set of bound services that can occur on any thread at any time after
        the component instance is created. A reference with a dynamic policy
        is called a <emphasis>dynamic reference</emphasis>. With a dynamic
        reference, SCR can change the set of bound services without
        deactivating a component configuration. If the component uses method
        injection to access services, then the component instance will be
        notified of changes in the set of bound services by calls to the bind,
        updated, and unbind methods.</para>

        <para>If the <code>policy-option</code> is <code>reluctant</code> then
        a bound reference is not rebound even if a more suitable service
        becomes available for a 1..1 or 0..1 reference. If the
        <code>policy-option</code> is <code>greedy</code> then the component
        must be unbound and rebound for that reference. See <xref
        linkend="service.component-policy.option.action"
        xrefstyle="template:Table %n on page %p"/>.</para>

        <para>The previous example with the registering of a resource
        directory used a static policy. This implied that the component
        configurations are deactivated when there is a change in the bound set
        of Http Services. The code in the example can be seen to easily handle
        the dynamics of Http Services that come and go. The component
        description can therefore be updated to:</para>

        <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.HttpResourceImpl"/&gt;
    &lt;reference name="HTTP"
        interface="org.osgi.service.http.HttpService"
        cardinality="0..n"
        <emphasis role="underline">policy="dynamic"</emphasis>
        bind="setPage"
        unbind="unsetPage"
    /&gt;
&lt;/scr:component&gt;</programlisting>

        <para>The code is identical to the previous example.</para>
      </section>
    </section>

    <section>
      <title>Reference Policy Option</title>

      <para>The reference policy option defines how eager the reference is to
      rebind when a new, potentially a higher ranking, target service becomes
      available. The reference policy option can have the following
      values:</para>

      <itemizedlist>
        <listitem>
          <para><code>reluctant</code> - Minimize rebinding and reactivating.
          This is the default reference policy option.</para>
        </listitem>

        <listitem>
          <para><code>greedy</code> - Maximize the use of the best service by
          deactivating static references or rebinding dynamic
          references.</para>
        </listitem>
      </itemizedlist>

      <para><xref linkend="service.component-policy.option.action"/> defines
      the actions that are taken when a <emphasis>better</emphasis> target
      service becomes available. In this context, better is when the reference
      is not bound or when the new target service has a higher ranking than
      the bound service.</para>

      <table pgwide="1" xml:id="service.component-policy.option.action">
        <title>Action taken for policy-option when a new or higher ranking
        service becomes available</title>

        <tgroup cols="5">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="2*"/>

          <colspec colnum="3" colwidth="2*"/>

          <colspec colnum="4" colwidth="2*"/>

          <colspec colnum="5" colwidth="2*"/>

          <thead>
            <row>
              <entry>Cardinality</entry>

              <entry>static reluctant</entry>

              <entry>static greedy</entry>

              <entry>dynamic reluctant</entry>

              <entry>dynamic greedy</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>0..1</code></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Reactivate to bind the better target
              service.</para></entry>

              <entry><para>If no service is bound, bind to new target service.
              Otherwise, ignore new target service.</para></entry>

              <entry><para>If no service is bound, bind to better target
              service. Otherwise, unbind the bound service and bind the better
              target service.</para></entry>
            </row>

            <row>
              <entry><code>1..1</code></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Reactivate to bind the better target
              service.</para></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Unbind the bound service, then bind the new
              service.</para></entry>
            </row>

            <row>
              <entry><code>0..n</code></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Reactivate</para></entry>

              <entry><para>Bind new target service</para></entry>

              <entry><para>Bind new target service</para></entry>
            </row>

            <row>
              <entry><code>1..n</code></entry>

              <entry><para>Ignore</para></entry>

              <entry><para>Reactivate</para></entry>

              <entry><para>Bind new target service</para></entry>

              <entry><para>Bind new target service</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="service.component-reference.field.option">
      <title>Reference Field Option</title>

      <para>For a reference using field injection, the reference field option
      defines how SCR must manage the field value. The reference field option
      can have the following values:</para>

      <itemizedlist>
        <listitem>
          <para><code>replace</code> - SCR must set the field value. Any field
          value set by the constructor of the component instance is
          overwritten. This is the default reference field option.</para>
        </listitem>

        <listitem>
          <para><code>update</code> - SCR must update the collection set in
          the field. This collection can be set by the constructor of the
          component instance. This reference field option can only be used for
          a dynamic reference with multiple cardinality.</para>
        </listitem>
      </itemizedlist>

      <para>For a static reference, the replace option must be used.</para>

      <para>For a dynamic reference, the choice of reference field option is
      influenced by the cardinality of the reference. For unary cardinality,
      the replace option must be used. For multiple cardinality, either the
      replace or update option can be used.</para>

      <para>If the update option is used when not permitted, SCR must log an
      error message with the Log Service, if present, and the field must not
      be modified.</para>

      <section>
        <title>Replace Field Option</title>

        <para>If the field is declared with the <code>final</code> modifier,
        SCR must log an error message with the Log Service, if present, and
        the field must not be modified.</para>

        <para>For a static reference, SCR must set the field value before the
        component instance is activated and must not change the field while
        the component is active. This means there is a
        <emphasis>happens-before</emphasis> relationship between setting the
        field and activating the component instance, so the active component
        can safely read the field.</para>

        <para>For a dynamic reference, the field must be declared with the
        <code>volatile</code> modifier so that field value changes made by SCR
        are visible to other threads. If the field is not declared with the
        <code>volatile</code> modifier, SCR must log an error message with the
        Log Service, if present, and the field must not be modified.</para>

        <para>For a reference with unary cardinality, SCR must set the field
        value with initial bound service, if any, before the component
        instance is activated. If the reference has optional cardinality and
        there is no bound service, SCR must set the field value to
        <code>null</code>. If the reference is dynamic, when there is a new
        bound service or the service properties of the bound service are
        modified and the field holds service properties, SCR must replace the
        field value. If the reference has optional cardinality and there is no
        bound service, SCR must set the field value to
        <code>null</code>.</para>

        <para>For a reference with multiple cardinality, the type of the field
        must be <code>Collection</code> or <code>List</code>. If the field has
        a different type, SCR must log an error message with the Log Service,
        if present, and the field must not be modified. Before the component
        instance is activated, SCR must set the field value with a new mutable
        collection that must contain the initial set of bound services sorted
        using an ordering which is the same as the natural ordering of
        <code>ServiceReference</code>s as specified in
        <code>ServiceReference.compareTo</code>. The collection may be empty
        if the reference has optional cardinality and there are no bound
        services. If the reference is dynamic, when there is a change in the
        set of bound services or the service properties of a bound service are
        modified and the collection holds service properties, SCR must replace
        the field value with a new mutable collection that must contain the
        updated set of bound services sorted using an ordering which is the
        same as the natural ordering of <code>ServiceReference</code>s as
        specified in <code>ServiceReference.compareTo</code>. The new
        collection may be empty if the reference has optional cardinality and
        there are no bound services.</para>
      </section>

      <section>
        <title>Update Field Option</title>

        <para>The update option can only be used for a dynamic reference with
        multiple cardinality. The component's constructor can set the field
        with its choice of collection implementation. In this case, the field
        can be declared with the <code>final</code> modifier. The collection
        implementation used by the component should use identity rather than
        <code>equals</code> or <code>hashCode</code> to manage the elements of
        the collection. The collection implementation should also be
        thread-safe since SCR may update the collection from threads different
        than those used by the component instance.</para>

        <para>After constructing the component instance, if the field value is
        <code>null</code>:</para>

        <itemizedlist>
          <listitem>
            <para>If the type of the field is <code>Collection</code> or
            <code>List</code>, SCR will set the field value to a new mutable
            empty collection or list object, respectively. If the field is
            declared with the <code>final</code> modifier, SCR must log an
            error message with the Log Service, if present, and the field must
            not be modified.</para>
          </listitem>

          <listitem>
            <para>Otherwise, SCR must log an error message with the Log
            Service, if present, and the field must not be modified.</para>
          </listitem>
        </itemizedlist>

        <para>SCR must not change the field value while the component is
        active and only update the contents of the collection. SCR must update
        the collection before the component instance is activated by calling
        <code>Collection.add</code> for each bound service. When there is a
        change to the set of bound services:</para>

        <itemizedlist>
          <listitem>
            <para>SCR must call <code>Collection.add</code> for a newly bound
            service.</para>
          </listitem>

          <listitem>
            <para>SCR must call <code>Collection.remove</code> for an unbound
            service.</para>
          </listitem>

          <listitem>
            <para>If the service properties of a bound service are modified
            and the collection holds service properties, SCR must call
            <code>Collection.add</code> for the replacement element followed
            by <code>Collection.remove</code> for the old element.</para>
          </listitem>
        </itemizedlist>

        <para>The collection may be empty if the reference has optional
        cardinality and there are no bound services.</para>
      </section>
    </section>

    <section xml:id="service.component-selecting.target.services">
      <title>Selecting Target Services</title>

      <para>The target services for a reference are constrained by the
      reference's interface name and target property. By specifying a filter
      in the target property, the programmer and deployer can constrain the
      set of services that should be part of the target services.</para>

      <para>For example, a component wants to track all Component Factory
      services that have a factory identification of
      <code>acme.application</code>. The following component description shows
      how this can be done.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.listen"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.FactoryTracker"/&gt;
    &lt;reference name="FACTORY"
        interface=
            "org.osgi.service.component.ComponentFactory"
        target="(component.factory=acme.application)"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The filter is manifested as a component property called the
      <emphasis>target property</emphasis>. The target property can also be
      set by <code>property</code> and <code>properties</code> elements, see
      <xref linkend="service.component-property.properties.elements"/>. The
      deployer can also set the target property by establishing a
      configuration for the component which sets the value of the target
      property. This allows the deployer to override the target property in
      the component description. See <xref
      linkend="service.component-target.property"/> for more
      information.</para>

      <section xml:id="service.component-anyservice">
        <title>Any Service Type</title>

        <para>A special exception to the selecting of target services is the
        use of the special interface name
        <code>org.osgi.service.component.AnyService</code>. This means that a
        service type is not used to select the target services and just the
        target property is used to select the target services. When the
        special interface name of
        <code>org.osgi.service.component.AnyService</code> is used, a target
        property must be present to constrain the target services to some
        subset of all available services. If no target property is present,
        SCR must log an error message with the Log Service, if present, and
        the reference cannot be satisfied. Note that there may be performance
        impacts resulting from a target property matching too broad a set of
        target services. A target property of <code>(service.id=*)</code> is
        valid but will match all services in the service registry which will
        likely be neither very useful nor performant.</para>

        <para>The reference member or parameter must have a service type of
        <code>java.lang.Object</code> to allow SCR to provide any service
        object.</para>

        <para>For example, a component wants to track all Jakarta RESTful Web
        Services Extension services. Jakarta RESTful Web Services Extension
        services can be registered under many different service types but must
        be registered with the service property
        <code>osgi.jakartars.extension=true</code>. The following component
        description shows how this can be done.</para>

        <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="jakartars.extension.listener"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.ExtensionListener"/&gt;
    &lt;reference name="EXTENSIONS"
        interface=
            "org.osgi.service.component.AnyService"
        target="(osgi.jakartars.extension=true)"
        cardinality="0..n"
    /&gt;
&lt;/scr:component&gt;</programlisting>
      </section>
    </section>

    <section xml:id="service.component-circular.references">
      <title>Circular References</title>

      <para>It is possible for a set of component descriptions to create a
      circular dependency. For example, if component <code>A</code> references
      a service provided by component <code>B</code> and component
      <code>B</code> references a service provided by component <code>A</code>
      then a component configuration of one component cannot be satisfied
      without accessing a partially activated component instance of the other
      component. SCR must ensure that a component instance is never accessible
      to another component instance or as a service until it has been fully
      activated, that is it has returned from its <code>activate</code> method
      if it has one.</para>

      <para>Circular references must be detected by SCR when it attempts to
      satisfy component configurations and SCR must fail to satisfy the
      references involved in the cycle and log an error message with the Log
      Service, if present. However, if one of the references in the cycle has
      optional cardinality SCR must break the cycle. The reference with the
      optional cardinality can be satisfied and bound to zero target services.
      Therefore the cycle is broken and the other references may be
      satisfied.</para>
    </section>

    <section xml:id="service.component-logger.support">
      <title>Logger Support</title>

      <para>SCR provides special support for components having references to
      the Logger Factory from the Log Service specification. If the reference
      uses method, field or constructor injection, the referenced service is
      of type <code>org.osgi.service.log.LoggerFactory</code>, and the type of
      the parameter or field to receive the service object is of type
      <code>org.osgi.service.log.Logger</code> or
      <code>org.osgi.service.log.FormatterLogger</code>, then SCR must obtain
      the proper type of Logger from the bound Logger Factory service and use
      the obtained Logger as the service object rather than the service object
      for the bound Logger Factory service.</para>

      <para>To obtain the Logger object to use as the service object, SCR must
      call the <code>LoggerFactory.getLogger(Bundle bundle, String name, Class
      loggerType)</code> method passing the bundle declaring the component as
      the first argument, the fully qualified name of the component
      implementation class as the second argument, and the type of the
      parameter or field, <code>org.osgi.service.log.Logger</code> or
      <code>org.osgi.service.log.FormatterLogger</code>, as the third
      argument.</para>

      <para>For example, the following code will have the <code>logger</code>
      field set to a Logger object created by SCR from the bound Logger
      Factory service.</para>

      <programlisting>@Component
public class MyComponent {
  @Reference(service=LoggerFactory.class)
  private Logger logger;
  @Activate
  void activate(ComponentContext context) {
    logger.trace(“activating component id {}”,
      context.getProperties().get(“component.id”));
  }
}</programlisting>
    </section>

    <section xml:id="service.component-satisfying.condition">
      <title>Satisfying Condition</title>

      <para>The <emphasis>Condition Service Specification</emphasis> in <xref
      linkend="intro.core.release" xrefstyle="template:%t"/> defines
      <emphasis>Condition</emphasis> services representing a particular state
      at runtime and requires the OSGi Framework to always register the
      <emphasis>True Condition</emphasis> service.</para>

      <para>Every component description is defined to have a reference to a
      <emphasis>satisfying condition</emphasis>. The name of this reference
      must be <code>osgi.ds.satisfying.condition</code>. If a component
      description does not explicitly declare a reference with the name
      <code>osgi.ds.satisfying.condition</code>, SCR must augment the
      component description to add the following implicit reference as the
      last reference:</para>

      <programlisting>&lt;reference name="osgi.ds.satisfying.condition"
    interface="org.osgi.service.condition.Condition"
    target="(osgi.condition.id=true)"
    policy="dynamic"
/&gt;</programlisting>

      <para>The implicit reference is handled in the same manner as any
      explicit reference in the component description, including handling
      reference properties. See <xref
      linkend="service.component-reference.properties"/>. In order for a
      component configuration to be satisfied, the reference for the
      satisfying condition, like all other references, must be satisfied. The
      target property for the reference to the satisfying condition,
      <code>osgi.ds.satisfying.condition.target</code>, can be used to select
      the satisfying condition. This allows a component configuration to be
      configured to select which Condition service is the satisfying
      condition. The implicit reference defaults to the target property value
      of <code>(osgi.condition.id=true)</code> which targets the True
      Condition, that is always registered by the OSGi Framework, and thus the
      implicit reference, using the default target property value, can always
      be satisfied.</para>

      <para>For example, you can use the <xref
      linkend="org.osgi.service.component.propertytypes.SatisfyingConditionTarget"
      xrefstyle="hyperlink"/> component property type to set the target
      property for the reference to the satisfying condition to select a
      condition indicating that some subsystem needed by the component is
      ready.</para>

      <programlisting>@Component
@SatisfyingConditionTarget("(osgi.condition.id=my.subsystem.ready)")
public class MyComponent {
  ...
}</programlisting>

      <para>A component's satisfying condition can be used as a way to
      control, via the configuration of component properties, whether a
      component configuration can be satisfied. That is, it can be a way to
      "enable" or "disable" a component configuration through its
      configuration. See <emphasis>Condition Service Specification</emphasis>
      of <xref linkend="intro.core.release" xrefstyle="template:%t"/> for
      additional information on Conditions.</para>

      <para>SCR must support the satisfying condition for all components even
      those with component descriptions in older namespaces.</para>
    </section>
  </section>

  <section xml:id="service.component-component.description">
    <title>Component Description</title>

    <para>Component descriptions are defined in XML documents contained in a
    bundle and any attached fragments.</para>

    <para>If SCR detects an error when processing a component description, it
    must log an error message with the Log Service, if present, and ignore the
    component description. Errors can include XML parsing errors and
    ill-formed component descriptions.</para>

    <section>
      <title>Annotations</title>

      <para>A number of <code>CLASS</code> retention annotations have been
      provided to allow tools to construct the component description XML from
      the Java class files. These annotations will be discussed with the
      appropriate elements and attributes. Since the naming rules between XML
      and Java differ, some name changes are necessary.</para>

      <para>Multi-word element and attribute names that use a minus sign
      (<code>'-' \u002D</code>) are changed to camel case. For example, the
      <code>configuration-pid</code> attribute in the <code>component</code>
      element is the <code>configurationPid</code> member in the
      <code>@Component</code> annotation. The annotation class that
      corresponds to an element starts with an upper case letter. For example
      the <code>component</code> element is represented by the
      <code>@Component</code> annotation.</para>

      <para>Some elements do not have a corresponding annotation since the
      annotations can be parameterized by the type information in the Java
      class. For example, the <code>@Component</code> annotation synthesizes
      the <code>implement</code> element's <code>class</code> attribute from
      the type it is applied to.</para>

      <para>See <xref linkend="service.component-component.annotations"/> for
      more information.</para>
    </section>

    <section>
      <title>Service Component Header</title>

      <para>XML documents containing component descriptions must be specified
      by the Service-Component header in the manifest. The value of the header
      is a comma separated list of paths to XML entries within the
      bundle.</para>

      <programlisting>Service-Component ::= header // See Common Header Syntax in Core</programlisting>

      <para>The Service-Component header has no architected directives or
      properties. The header can be left empty.</para>

      <para>The last component of each path in the Service-Component header
      may use wildcards so that <code>Bundle.findEntries</code> can be used to
      locate the XML document within the bundle and its fragments. For
      example:</para>

      <programlisting>Service-Component: OSGI-INF/*.xml</programlisting>

      <para>A Service-Component manifest header specified in a fragment is
      ignored by SCR. However, XML documents referenced by a bundle's
      Service-Component manifest header may be contained in attached
      fragments.</para>

      <para>SCR must process each XML document specified in this header. If an
      XML document specified by the header cannot be located in the bundle and
      its attached fragments, SCR must log an error message with the Log
      Service, if present, and continue.</para>
    </section>

    <section>
      <title>Component Activation Policy Header</title>

      <para>A Bundle might specify the Bundle-ActivationPolicy header with a value of 'lazy' to indicate it want delay its activation and possible execution of the BundleActivator.
      In such a case an additional Component-ActivationPolicy might be specified to control how the Component Runtime should handle components declared in such a bundle.</para>

      <programlisting>Component-ActivationPolicy ::= (eager | reluctant | ignore )</programlisting>

      <para>The Component-ActivationPolicy header has no architected directives or
      properties. If the header is not specified eager policy is assumed.</para>
      
      <itemizedlist>
        <listitem>
          <para><code>eager</code> - The component runtime will eagerly activate components whenever they become satisfied what might lead to class loading and final activation of the lazy bundle.</para>
        </listitem>
        <listitem>
          <para><code>reluctant</code> - The component runtime only activates such components that provide at laest one service so these can be found in the service registry, 
          what then might lead to class loading and final activation of the lazy bundle, any other component is only activated once the bundle becomes active.</para>
        </listitem>
        <listitem>
          <para><code>ignore</code> - The component runtime never activate any components unless the bundle becomes active and therefore never trigger any clasloads before that point.</para>
        </listitem>
      </itemizedlist>
      <para>The main purpose of this header is to control the point where a bundle becomes actively participating in the OSGi system, while 'eager' is the most common one it could easily defeat the purpose of
       the lazy bundle activation because any immediate component will always fully activate the bundle. But even with 'reluctant' this might happen if the bundle implements a service that is collected as part
        of the whiteboardpattern because there will always be a demand on that service from the extender. For this purpose the 'ignore' policy is a good choice what will only let the bundle start participating
        as soon as some other party access the bundles classes and from now on wants to make its services available, this is mostly an equivalent to registering the services in an Activator and can therefore
        act as a migration strategy as well unless a system reaches a full dynamic state where bundle activation is no longer a concern.
      </para>
      <para>
        Another usual case for this is in the context of an UI framework. Such a framework will most probably delay the loading of its view classes until to the point where the user shows a view.
        Such view bundle wants to use lazy bundle activation policy to not participate unless it has something to show, but might want to get notified about changes e.g. by some whiteboard listener pattern.
        A view itself might even want to collect additional services what can trigger other bundles/components to activate as well,
        therefore it has the demand to delay its interaction to the latest possible time and therefore the 'reluctant' or 'ignore' policy is to be used here depending on the use-case.
      </para>
    </section>
    <section>
      <title>XML Document</title>

      <para>A component description must be in a well-formed XML document,
      <xref linkend="i1636361"/>, stored in a <code>UTF-8</code> encoded
      bundle entry. The namespace for component descriptions is:</para>

      <programlisting>http://www.osgi.org/xmlns/scr/v1.5.0</programlisting>

      <para>The recommended prefix for this namespace is <code>scr</code>.
      This prefix is used by examples in this specification. XML documents
      containing component descriptions may contain a single, root
      <code>component</code> element or one or more <code>component</code>
      elements embedded in a larger document. Use of the namespace for
      component descriptions is mandatory. The attributes and sub-elements of
      a <code>component</code> element are always unqualified.</para>

      <para>If an XML document contains a single, root <code>component</code>
      element which does not specify a namespace, then the
      <code>http://www.osgi.org/xmlns/scr/v1.0.0</code> namespace is assumed.
      Component descriptions using the
      <code>http://www.osgi.org/xmlns/scr/v1.0.0</code> namespace must be
      treated according to version 1.0 of this specification.</para>

      <para>SCR must parse all <code>component</code> elements in the
      namespace. Elements not in this namespace must be ignored. Ignoring
      elements that are not recognized allows component descriptions to be
      embedded in any XML document. For example, an entry can provide
      additional information about components. These additional elements are
      parsed by another sub-system.</para>

      <para>See <xref linkend="service.component-schema"/> for component
      description schema.</para>
    </section>

    <section xml:id="service.component-component.element">
      <title>Component Element</title>

      <para>The component element specifies the component description. The
      following text defines the structure of the XML grammar using a form
      that is similar to the normal grammar used in OSGi specifications. In
      this case the grammar should be mapped to XML elements:</para>

      <programlisting>&lt;component&gt; ::= (&lt;property&gt; | &lt;properties&gt;)*
                &lt;service&gt;?
                &lt;reference&gt;*
                &lt;implementation&gt;</programlisting>

      <para>SCR must not require component descriptions to specify the
      elements in the order listed above and as required by the XML schema.
      SCR must allow other orderings since arbitrary orderings of these
      elements do not affect the meaning of the component description. Only
      the relative ordering of <code>property</code> and
      <code>properties</code> elements and of <code>reference</code> elements
      have meaning.</para>

      <para>The <code>component</code> element has the attributes and
      <code>@Component</code> annotations defined in the following
      table.</para>

      <table pgwide="1">
        <title>Component Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>name</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Component.name--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The <emphasis>name</emphasis> of a component must
              be unique within a bundle. The component name is used as a PID
              to retrieve component properties from the OSGi Configuration
              Admin service if present, unless a
              <code>configuration-pid</code> attribute has been defined. See
              <xref linkend="service.component-deployment"/> for more
              information. If the component name is used as a PID then it
              should be unique within the framework. The XML schema allows the
              use of component names which are not valid PIDs. Care must be
              taken to use a valid PID for a component name if the component
              should be configured by the Configuration Admin service. This
              attribute is optional. The default value of this attribute is
              the value of the <code>class</code> attribute of the nested
              <code>implementation</code> element. If multiple
              <code>component</code> elements in a bundle use the same value
              for the <code>class</code> attribute of their nested
              <code>implementation</code> element, then using the default
              value for this attribute will result in duplicate component
              names. In this case, this attribute must be specified with a
              unique value.</para></entry>
            </row>

            <row>
              <entry><code>enabled</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Component.enabled--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Controls whether the component is
              <emphasis>enabled</emphasis> when the bundle is started. The
              default value is <code>true</code>. If <code>enabled</code> is
              set to <code>false</code>, the component is disabled until the
              method <code>enableComponent</code> is called on the
              <code>ComponentContext</code> object. This allows some
              initialization to be performed by some other component in the
              bundle before this component can become satisfied. See <xref
              linkend="service.component-enabled"/>.</para></entry>
            </row>

            <row>
              <entry><code>factory</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Component.factory--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>If set to a non-empty string, it indicates that
              this component is a <emphasis>factory component</emphasis>. SCR
              must register a Component Factory service for each factory
              component. See <xref
              linkend="service.component-factorycomponent"/>.</para></entry>
            </row>

            <row>
              <entry><code>immediate</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Component.immediate--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Controls whether component configurations must be
              immediately activated after becoming satisfied or whether
              activation should be delayed. The default value is
              <code>false</code> if the <code>factory</code> attribute or if
              the <code>service</code> element is specified and
              <code>true</code> otherwise. If this attribute is specified, its
              value must be <code>false</code> if the <code>factory</code>
              attribute is also specified or must be <code>true</code> unless
              the <code>service</code> element is also
              specified.</para></entry>
            </row>

            <row>
              <entry><code>configuration-policy</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Component.configurationPolicy--"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.ConfigurationPolicy.OPTIONAL"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.ConfigurationPolicy.REQUIRE"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.ConfigurationPolicy.IGNORE"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Controls whether component configurations must be
              satisfied depending on the presence of a corresponding
              <code>Configuration</code> object in the OSGi Configuration
              Admin service. A corresponding configuration is a
              <code>Configuration</code> object where the PID is the name of
              the component.</para><itemizedlist>
                  <listitem>
                    <para><code>optional</code> - (default) Use the
                    corresponding <code>Configuration</code> object if present
                    but allow the component to be satisfied even if the
                    corresponding <code>Configuration</code> object is not
                    present.</para>
                  </listitem>

                  <listitem>
                    <para><code>require</code> - There must be a corresponding
                    <code>Configuration</code> object for the component
                    configuration to become satisfied.</para>
                  </listitem>

                  <listitem>
                    <para><code>ignore</code> - Always allow the component
                    configuration to be satisfied and do not use the
                    corresponding <code>Configuration</code> object even if it
                    is present.</para>
                  </listitem>
                </itemizedlist></entry>
            </row>

            <row>
              <entry><code>configuration-pid</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Component.configurationPid--"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The configuration PIDs to be used for the component
              in conjunction with Configuration Admin. Multiple configuration
              PIDs can be specified by using a whitespace separated list in
              the attribute. The default value for this attribute is the name
              of the component.</para><para>The annotation uses a
              <code>String[]</code> to specify multiple configuration PIDs.
              The order in which configuration PIDs are specified must be
              preserved in the generated component description. The annotation
              can also use the special configuration PID name <link
              linkend="org.osgi.service.component.annotations.Component.NAME"
              xrefstyle="hyperlink">"$"</link> to specify the name of the
              component. This special name must be replaced with the actual
              name of the component in the generated component
              description.</para></entry>
            </row>

            <row>
              <entry><code>activate</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Activate"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Specifies the name of the method to call when a
              component configuration is activated. The default value of this
              attribute is <code>activate</code>. See <xref
              linkend="service.component-activate.method"/> for more
              information.</para><para>The <xref
              linkend="org.osgi.service.component.annotations.Activate"
              xrefstyle="hyperlink"/> annotation must be applied to at most
              one method which is to be used as the activate
              method.</para></entry>
            </row>

            <row>
              <entry><code>activation-fields</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Activate"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Specifies the whitespace separated list of the
              names of the fields to hold activation objects. The fields are
              set once after the constructor has been called and before
              calling any other method on the fully constructed component
              instance such as the <code>activate</code> method. See <xref
              linkend="service.component-activation.objects"/> for more
              information.</para><para>The <xref
              linkend="org.osgi.service.component.annotations.Activate"
              xrefstyle="hyperlink"/> annotation will use the name of the
              field to which it is applied as the activation field
              name.</para></entry>
            </row>

            <row>
              <entry><code>init</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Activate"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Specifies the number of arguments of the public
              constructor to use. The default is 0 which represents the public
              no-parameter constructor. See <xref
              linkend="service.component-constructor.injection"/> for more
              information.</para><para>The <xref
              linkend="org.osgi.service.component.annotations.Activate"
              xrefstyle="hyperlink"/> annotation must be applied to at most
              one constructor which is to be used as the constructor for
              component instances.</para></entry>
            </row>

            <row>
              <entry><code>deactivate</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Deactivate"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Specifies the name of the method to call when a
              component configuration is deactivated. The default value of
              this attribute is <code>deactivate</code>. See <xref
              linkend="service.component-deactivate.method"/> for more
              information.</para><para>The <xref
              linkend="org.osgi.service.component.annotations.Deactivate"
              xrefstyle="hyperlink"/> annotation must be applied to at most
              one method which is to be used as the deactivate
              method.</para></entry>
            </row>

            <row>
              <entry><code>modified</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Modified"
              xrefstyle="hyperlink"/></entry>

              <entry><para>Specifies the name of the method to call when the
              configuration properties for a component configuration is using
              a <code>Configuration</code> object from the Configuration Admin
              service and that <code>Configuration</code> object is modified
              without causing the component configuration to become
              unsatisfied. If this attribute is not specified, then the
              component configuration will become unsatisfied if its
              configuration properties use a <code>Configuration</code> object
              that is modified in any way. See <xref
              linkend="service.component-modified.method"/> for more
              information.</para><para>The <xref
              linkend="org.osgi.service.component.annotations.Modified"
              xrefstyle="hyperlink"/> annotation must be applied to at most
              one method which is to be used as the modified
              method.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Implementation Element</title>

      <para>The <code>implementation</code> element is required and defines
      the name of the component implementation class. The single attribute is
      defined in the following table.</para>

      <table pgwide="1">
        <title>Implementation Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>class</code></entry>

              <entry><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/></entry>

              <entry><para>The Java fully qualified name of the implementation
              class.</para><para>The component <xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> annotation will define the
              <code>implementation</code> element automatically from the type
              it is applied to.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The class is retrieved with the <code>loadClass</code> method of
      the component's bundle. The class must have a public constructor with
      the correct parameter count and types which will be used to construct
      the component instance.</para>

      <para>If the component description specifies a service, the class must
      implement all interfaces that are provided by the service.</para>
    </section>

    <section xml:id="service.component-property.properties.elements">
      <title>Property and Properties Elements</title>

      <para>A component description can define a number of properties. These
      can be defined inline or from a resource in the bundle. The
      <code>property</code> and <code>properties</code> elements can occur
      multiple times and they can be interleaved. This interleaving is
      relevant because the properties are processed from top to bottom. Later
      properties override earlier properties that have the same name.</para>

      <para>Properties can also be overridden by a Configuration Admin
      service's <code>Configuration</code> object before they are exposed to
      the component or used as service properties. This is described in <xref
      linkend="service.component-component.properties"/> and <xref
      linkend="service.component-deployment"/>.</para>

      <para>The <code>property</code> element has the attributes and
      annotations defined in the following table.</para>

      <table pgwide="1">
        <title>Property Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>name</code></entry>

              <entry><para><code><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.property--"
              xrefstyle="hyperlink"/></code></para></entry>

              <entry><para>The name of the property.</para></entry>
            </row>

            <row>
              <entry><code>value</code></entry>

              <entry><para/></entry>

              <entry><para>The value of the property. This value is parsed
              according to the property type. If the value attribute is
              specified, the body of the element is ignored. If the type of
              the property is not <code>String</code>, parsing of the value is
              done by the static <code>valueOf(String)</code> method in the
              given type. For <code>Character</code> types, the conversion
              must be handled by <code>Integer.valueOf</code> method, a
              Character is always represented by its Unicode
              value.</para></entry>
            </row>

            <row>
              <entry><code>type</code></entry>

              <entry><para/></entry>

              <entry><para>The type of the property. Defines how to interpret
              the value. The type must be one of the following Java
              types:</para><itemizedlist>
                  <listitem>
                    <para><code>String</code> (default)</para>
                  </listitem>

                  <listitem>
                    <para><code>Long</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Double</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Float</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Integer</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Byte</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Character</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Boolean</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Short</code></para>
                  </listitem>
                </itemizedlist></entry>
            </row>

            <row>
              <entry><code>&lt;body&gt;</code></entry>

              <entry><para/></entry>

              <entry><para>If the <code>value</code> attribute is not
              specified, the body of the property element must contain one or
              more values. The value of the property is then an array of the
              specified type. The result will be translated to an array of
              primitives or <code>String</code>s. For example, if the type
              attribute specifies <code>Integer</code>, then the resulting
              array must be <code>int[]</code>.</para><para>Values must be
              placed one per line and blank lines are ignored. Parsing of each
              value is done by the <code>parse</code> methods in the class
              identified by the type, after trimming the line of any beginning
              and ending white space. Each <code>String</code> value is also
              trimmed of beginning and ending white space.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, a component that needs an array of hosts can use the
      following property definition:</para>

      <programlisting>&lt;property name="hosts"&gt;
        www.acme.com
        backup.acme.com
&lt;/property&gt;</programlisting>

      <para>This property declaration results in the property hosts, with a
      value of <code>String[] { "www.acme.com", "backup.acme.com"
      }</code>.</para>

      <para>A property can also be set with the <xref
      linkend="org.osgi.service.component.annotations.Component.property--"
      xrefstyle="hyperlink"/> annotation element of <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/>. This element is an array of strings that must
      follow the following syntax:</para>

      <programlisting>property ::= name ( ':' type )? '=' value</programlisting>

      <para>In this case <code>name</code>, <code>type</code>, and
      <code>value</code> parts map to the attributes of the
      <code>property</code> element. If multiple values must be specified then
      the same name can be repeated multiple times. For example:</para>

      <programlisting>@Component(property={"foo:Integer=1","foo:Integer=2","foo:Integer=3"})
public class FooImpl {
  ...
}</programlisting>

      <para>The <code>properties</code> element references an entry in the
      bundle whose contents conform to a standard <xref
      linkend="i1567926"/>.</para>

      <para>At runtime, SCR reads the entry to obtain the properties and their
      values. The properties element attributes are defined in the following
      table.</para>

      <table pgwide="1">
        <title>Properties Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>entry</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.properties--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The entry path relative to the root of the
              bundle</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, to include vendor identification properties that are
      stored in the OSGI-INF directory, the following definition could be
      used:</para>

      <programlisting>&lt;properties entry="OSGI-INF/vendor.properties"/&gt;</programlisting>

      <para>The <xref
      linkend="org.osgi.service.component.annotations.Component.properties--"
      xrefstyle="hyperlink"/> annotation element of <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> can be used to provide the same information.
      This element consists of an array of strings where each string defines
      an entry. The order within the array is the order that must be used for
      the XML. However, the annotations do not support interleaving of the
      generated <code>property</code> and <code>properties</code>
      elements.</para>

      <para>For example:</para>

      <programlisting>@Component(properties="OSGI-INF/vendor.properties")</programlisting>

      <para>See <xref
      linkend="service.component-ordering.generated.properties"/> for more
      information on the ordering of generated properties when using
      annotations.</para>
    </section>

    <section xml:id="service.component-service.element">
      <title>Service Element</title>

      <para>The <code>service</code> element is optional. It describes the
      service information to be used when a component configuration is to be
      registered as a service.</para>

      <para>A service element has the following attribute defined in the
      following table.</para>

      <table pgwide="1">
        <title>Service Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>scope</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.scope--"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.ServiceScope.SINGLETON"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.ServiceScope.BUNDLE"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.ServiceScope.PROTOTYPE"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Controls the scope of the provided service. If set
              to <code>singleton</code>, when the component is registered as a
              service, it must be registered as a bundle scope service but
              only a single component configuration must be created and
              activated and a new instance of the component implementation
              class of the component must be used for all bundles using the
              service. If set to <code>bundle</code>, when the component is
              registered as a service, it must be registered as a bundle scope
              service and a different component configuration is created and
              activated and a new instance of the component implementation
              class must be created for each bundle using the service. If set
              to <code>prototype</code>, when the component is registered as a
              service, it must be registered as a prototype scope service and
              a different component configuration is created and activated and
              a new instance of the component implementation class must be
              created for each distinct request for the service, such as via
              <code>ServiceObjects</code>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <code>scope</code> attribute must be <code>singleton</code> if
      the component is a factory component or an immediate component. This is
      because SCR is not free to create component configurations as necessary
      to support non-singleton scoped services. A component description is
      ill-formed if it specifies that the component is a factory component or
      an immediate component and <code>scope</code> is not
      <code>singleton</code>.</para>

      <para>The <code>service</code> element must have one or more
      <code>provide</code> elements that define the service interfaces. The
      <code>provide</code> element has the attribute defined in the following
      table.</para>

      <table pgwide="1">
        <title>Provide Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>interface</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.service--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The name of the interface that this service is
              registered under. This name must be the fully qualified name of
              a Java class. For example,
              <code>org.osgi.service.eventadmin.EventHandler</code>. The
              specified Java class should be an interface rather than a class,
              however specifying a class is supported. The component
              implementation class must implement all the specified service
              interfaces.</para><para>The Component annotation can specify the
              provided services, if this element is not specified all directly
              implemented interfaces on the component's type are defined as
              service interfaces. Specifying an empty array indicates that no
              service should be registered.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, a component implements an Event Handler
      service.</para>

      <programlisting>&lt;service&gt;
    &lt;provide interface=
        "org.osgi.service.eventadmin.EventHandler"/&gt;
&lt;/service&gt;</programlisting>

      <para>This previous example can be generated with the following
      annotation:</para>

      <programlisting>@Component
public class Foo implements EventHandler { ... }</programlisting>
    </section>

    <section xml:id="service.component-reference.element">
      <title>Reference Element</title>

      <para>A <emphasis>reference</emphasis> declares a dependency that a
      component has on a set of target services. A component configuration is
      not satisfied, unless all its references are satisfied. A reference
      specifies target services by specifying their interface and an optional
      target property.</para>

      <para>A <code>reference</code> element has the attributes defined in the
      following table.</para>

      <table pgwide="1">
        <title>Reference Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>name</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.name--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The name of the reference. This name is local to
              the component and can be used to locate a bound service of this
              reference with one of the <code>locateService</code> methods of
              <xref linkend="org.osgi.service.component.ComponentContext"
              xrefstyle="hyperlink"/>. Each <code>reference</code> element
              within the component must have a unique name. This
              <code>name</code> attribute is optional. The default value of
              this attribute is the value of the <code>interface</code>
              attribute of this element. If multiple <code>reference</code>
              elements in the component use the same interface name, then
              using the default value for this attribute will result in
              duplicate reference names. In this case, this attribute must be
              specified with a unique name for the reference to avoid an
              error.</para><para>The <code>Reference</code> annotation will
              use the name of the annotated method, field, or parameter as the
              default reference name. If the method name begins with
              <code>bind</code>, <code>set</code> or <code>add</code>, that
              prefix is removed.</para></entry>
            </row>

            <row>
              <entry><code>interface</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.service--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Fully qualified name of the class that is used by
              the component to access the service. The service provided to the
              component must be type compatible with this class. That is, the
              component must be able to cast the service object to this class.
              A service must be registered under this name to be considered
              for the set of target services.</para><para>The
              <code>Reference</code> annotation will use the type of the first
              parameter of the annotated method or the type of the annotated
              parameter or field to determine the <code>service</code>
              value.</para><para>The special
              <code>org.osgi.service.component.AnyService</code> service name
              can be used to indicate that the service type name is not used
              to select target services. Only the target property is used to
              select target services. When using this special service name,
              the reference field or parameter must be of type
              <code>java.lang.Object</code> so that any service object can be
              provided. See <xref
              linkend="service.component-anyservice"/>.</para></entry>
            </row>

            <row>
              <entry><code>cardinality</code></entry>

              <entry><para> <xref
              linkend="org.osgi.service.component.annotations.Reference.cardinality--"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferenceCardinality.MANDATORY"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferenceCardinality.OPTIONAL"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferenceCardinality.MULTIPLE"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferenceCardinality.AT_LEAST_ONE"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para> Specifies if the reference is optional and if the
              component implementation support a single bound service or
              multiple bound services. See <xref
              linkend="service.component-reference.cardinality"/>.</para></entry>
            </row>

            <row>
              <entry><code>policy</code></entry>

              <entry><para> <xref
              linkend="org.osgi.service.component.annotations.Reference.policy--"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicy.STATIC"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicy.DYNAMIC"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The policy declares the assumption of the component
              about dynamicity. See <xref
              linkend="service.component-reference.policy"/>.</para></entry>
            </row>

            <row>
              <entry><code>policy-option</code></entry>

              <entry><para> <xref
              linkend="org.osgi.service.component.annotations.Reference.policyOption--"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicyOption.RELUCTANT"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicyOption.GREEDY"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Defines the policy when a better service becomes
              available. See <xref
              linkend="service.component-reference.policy"/>.</para></entry>
            </row>

            <row>
              <entry><code>target</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.target--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>An optional OSGi Framework filter expression that
              further constrains the set of target services. The default is no
              filter, limiting the set of matched services to all service
              registered under the given reference interface. The value of
              this attribute is used for the value of the target property of
              the reference. See <xref
              linkend="service.component-target.property"/>.</para></entry>
            </row>

            <row>
              <entry><code>scope</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.scope--"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.ReferenceScope.BUNDLE"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.ReferenceScope.PROTOTYPE"
              xrefstyle="hyperlink"/></para><para><link
              linkend="org.osgi.service.component.annotations.ReferenceScope.PROTOTYPE_REQUIRED"
              xrefstyle="hyperlink">PROTOTYPE_</link></para><para>&#160;<link
              linkend="org.osgi.service.component.annotations.ReferenceScope.PROTOTYPE_REQUIRED"
              xrefstyle="hyperlink">REQUIRED</link></para></entry>

              <entry><para>The reference scope for this reference. See <xref
              linkend="service.component-reference.scope"/>.</para></entry>
            </row>

            <row>
              <entry><code>bind</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.Reference.bind--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The name of a method in the component
              implementation class that is used to notify that a service is
              bound to the component configuration. For static references,
              this method is only called before the <code>activate</code>
              method. For dynamic references, this method can also be called
              while the component configuration is active. See <xref
              linkend="service.component-accessing.services"/>.</para><para>The
              <code>Reference</code> annotation will use the name of the
              method it is applied to as the bind method name.</para></entry>
            </row>

            <row>
              <entry><code>updated</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.updated--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para> The name of a method in the component
              implementation class that is used to notify that a bound service
              has modified its properties.</para></entry>
            </row>

            <row>
              <entry><code>unbind</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.unbind--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Same as bind, but is used to notify the component
              configuration that the service is unbound. For static
              references, the method is only called after the
              <code>deactivate</code> method. For dynamic references, this
              method can also be called while the component configuration is
              active. See <xref
              linkend="service.component-accessing.services"/>.</para></entry>
            </row>

            <row>
              <entry><code>field</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.Reference.field--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The name of a field in the component implementation
              class that is used to hold service(s) that are bound to the
              component configuration. For static references, this field is
              set once after the constructor has been called and before
              calling the <code>activate</code> method. For dynamic
              references, this field can modified while the component
              configuration is active. See <xref
              linkend="service.component-accessing.services"/>.</para><para>The
              <code>Reference</code> annotation will use the name of the field
              it is applied to as the field name.</para></entry>
            </row>

            <row>
              <entry><code>field-option</code></entry>

              <entry><para> <xref
              linkend="org.osgi.service.component.annotations.Reference.fieldOption--"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.FieldOption.REPLACE"
              xrefstyle="hyperlink"/></para><para> <xref
              linkend="org.osgi.service.component.annotations.FieldOption.UPDATE"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Defines how the field value must be managed. This
              is ignored if the <code>field</code> attribute is not set. See
              <xref
              linkend="service.component-reference.field.option"/>.</para></entry>
            </row>

            <row>
              <entry><code>field-collection-type</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference.collectionType--"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.CollectionType.SERVICE"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.CollectionType.REFERENCE"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.CollectionType.SERVICEOBJECTS"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.CollectionType.PROPERTIES"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.CollectionType.TUPLE"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>Defines the types of elements in the collection or
              Optional referenced by the field value or constructor parameter.
              This is ignored if the <code>field</code> attribute or
              <code>parameter</code> attribute is not set. It is also ignored
              when the <code>field</code> attribute or <code>parameter</code>
              attribute is set, the cardinality is unary, and the field or
              constructor parameter type is not Optional. See <xref
              linkend="service.component-field.injection"/> for more
              information.</para><para>The <code>Reference</code> annotation
              can generally infer the value of the collection elements from
              the generic type information of the annotated field or
              constructor parameter but it can be explicitly defined if
              needed.</para></entry>
            </row>

            <row>
              <entry><code>parameter</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Reference"
              xrefstyle="hyperlink"/></para><para><xref
              linkend="org.osgi.service.component.annotations.Reference.parameter--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The zero-based parameter number of a parameter in
              the constructor of the component that is used to receive
              service(s) that are bound to the component configuration. If
              this attribute is set and the <code>policy</code> attribute is
              set to <xref
              linkend="org.osgi.service.component.annotations.ReferencePolicy.DYNAMIC"
              xrefstyle="hyperlink"/>, this attribute must be ignored and SCR
              must log an error message with the Log Service, if present. See
              <xref
              linkend="service.component-accessing.services"/>.</para><para>The
              <code>Reference</code> annotation will use the zero-based
              parameter number of the parameter it is applied to as the
              parameter number.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In the generated component description, the reference elements
      must be ordered in ascending lexicographical order, using
      <code>String.compareTo</code>, of the <xref
      linkend="org.osgi.service.component.annotations.Reference.name--"
      xrefstyle="hyperlink"/>s of the references.</para>

      <para>The following code demonstrates the use of the <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation for method injection.</para>

      <programlisting>@Component
public class FooImpl implements Foo {
  @Reference( 
    policy = DYNAMIC, 
    policyOption = GREEDY,
    cardinality = MANDATORY )
  void setLog( LoggerFactory lf ) { ... }
  void unsetLog( LoggerFactory lf ) { ... }
  void updatedLog( Map&lt;String,?&gt; ref ) { ... }

  @Activate
  void open() { ... }
  @Deactivate
  void close() { ... }
}</programlisting>

      <para>The following code demonstrates the use of the <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation for field injection.</para>

      <programlisting>@Component
public class FooImpl implements Foo {
  @Reference
  volatile LoggerFactory lf;

  @Activate
  void open() { lf.getLogger(FooImpl.class).info("activated"); }
  @Deactivate
  void close() { lf.getLogger(FooImpl.class).info("deactivated"); }
}</programlisting>

      <para>The following code demonstrates the use of the <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation for constructor injection.</para>

      <programlisting>@Component
public class FooImpl implements Foo {
  private final Logger logger;

  @Activate
  public FooImpl( @Reference LoggerFactory lf ) {
    logger = lf.getLogger(FooImpl.class);
  }

  @Activate
  void open() { logger.info("activated"); }
  @Deactivate
  void close() { logger.info("deactivated"); }
}</programlisting>

      <para>For a reference to be used with the lookup strategy, there are no
      bind methods or fields to annotate with the <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation. Instead <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotations can be specified in the <xref
      linkend="org.osgi.service.component.annotations.Component.reference--"
      xrefstyle="hyperlink"/> element of the <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> annotation. When used in this way, the <xref
      linkend="org.osgi.service.component.annotations.Reference.name--"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.component.annotations.Reference.service--"
      xrefstyle="hyperlink"/> elements must be specified since there is no
      annotated member from which the name or service can be determined. The
      following code demonstrates the use of the <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation for the lookup strategy.</para>

      <programlisting>@Component( reference = 
  @Reference( name = "log", service = LoggerFactory.class )
)
public class FooImpl implements Foo {
  @Activate
  void open( ComponentContext context ) {
    LoggerFactory lf = context.locateService( "log" );
    ...
  }
  @Deactivate
  void close() { ... }
}</programlisting>
    </section>

    <section xml:id="service.component-factoryproperty.factoryproperties.elements">
      <title>Factory Property and Factory Properties Elements</title>

      <para>If the component is a factory component, see <xref
      linkend="service.component-factorycomponent"/>, the component
      description can define a number of factory properties. These can be
      defined inline or from a resource in the bundle. The
      <code>factory-property</code> and <code>factory-properties</code>
      elements can occur multiple times and they can be interleaved. This
      interleaving is relevant because the factory properties are processed
      from top to bottom. Later factory properties override earlier factory
      properties that have the same name.</para>

      <para>The <code>factory-property</code> element has the attributes and
      annotations defined in the following table.</para>

      <table pgwide="1">
        <title>Factory Property Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>name</code></entry>

              <entry><para><code><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.factoryProperty--"
              xrefstyle="hyperlink"/></code></para></entry>

              <entry><para>The name of the factory property.</para></entry>
            </row>

            <row>
              <entry><code>value</code></entry>

              <entry><para/></entry>

              <entry><para>The value of the factory property. This value is
              parsed according to the property type. If the value attribute is
              specified, the body of the element is ignored. If the type of
              the factory property is not <code>String</code>, parsing of the
              value is done by the static <code>valueOf(String)</code> method
              in the given type. For <code>Character</code> types, the
              conversion must be handled by <code>Integer.valueOf</code>
              method, a Character is always represented by its Unicode
              value.</para></entry>
            </row>

            <row>
              <entry><code>type</code></entry>

              <entry><para/></entry>

              <entry><para>The type of the factory property. Defines how to
              interpret the value. The type must be one of the following Java
              types:</para><itemizedlist>
                  <listitem>
                    <para><code>String</code> (default)</para>
                  </listitem>

                  <listitem>
                    <para><code>Long</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Double</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Float</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Integer</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Byte</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Character</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Boolean</code></para>
                  </listitem>

                  <listitem>
                    <para><code>Short</code></para>
                  </listitem>
                </itemizedlist></entry>
            </row>

            <row>
              <entry><code>&lt;body&gt;</code></entry>

              <entry><para/></entry>

              <entry><para>If the <code>value</code> attribute is not
              specified, the body of the factory-property element must contain
              one or more values. The value of the factory property is then an
              array of the specified type. The result will be translated to an
              array of primitives or <code>String</code>s. For example, if the
              type attribute specifies <code>Integer</code>, then the
              resulting array must be <code>int[]</code>.</para><para>Values
              must be placed one per line and blank lines are ignored. Parsing
              of each value is done by the <code>parse</code> methods in the
              class identified by the type, after trimming the line of any
              beginning and ending white space. Each <code>String</code> value
              is also trimmed of beginning and ending white
              space.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>A factory property can also be set with the <xref
      linkend="org.osgi.service.component.annotations.Component.factoryProperty--"
      xrefstyle="hyperlink"/> annotation element of <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/>. This element is an array of strings that must
      follow the following syntax:</para>

      <programlisting>factory-property ::= name ( ':' type )? '=' value</programlisting>

      <para>In this case <code>name</code>, <code>type</code>, and
      <code>value</code> parts map to the attributes of the
      <code>factory-property</code> element. If multiple values must be
      specified then the same name can be repeated multiple times.</para>

      <para>The <code>factory-properties</code> element references an entry in
      the bundle whose contents conform to a standard <xref
      linkend="i1567926"/>.</para>

      <para>At runtime, SCR reads the entry to obtain the factory properties
      and their values. The <code>factory-properties</code> element attributes
      are defined in the following table.</para>

      <table pgwide="1">
        <title>Factory Properties Element and Annotations</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="4*"/>

          <thead>
            <row>
              <entry>Attribute</entry>

              <entry>Annotation</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>entry</code></entry>

              <entry><para><xref
              linkend="org.osgi.service.component.annotations.Component"
              xrefstyle="hyperlink"/> <xref
              linkend="org.osgi.service.component.annotations.Component.factoryProperties--"
              xrefstyle="hyperlink"/></para></entry>

              <entry><para>The entry path relative to the root of the
              bundle</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, to include properties that are stored in the OSGI-INF
      directory, the following definition could be used:</para>

      <programlisting>&lt;<code>factory-properties</code> entry="OSGI-INF/factory.properties"/&gt;</programlisting>

      <para>The <xref
      linkend="org.osgi.service.component.annotations.Component.factoryProperties--"
      xrefstyle="hyperlink"/> annotation element of <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> can be used to provide the same information.
      This element consists of an array of strings where each string defines
      an entry. The order within the array is the order that must be used for
      the XML. However, the annotations do not support interleaving of the
      generated <code>factory-property</code> and
      <code>factory-properties</code> elements.</para>

      <para>For example:</para>

      <programlisting>@Component(factoryProperties="OSGI-INF/factory.properties")</programlisting>

      <para>When using annotation elements to specify factory properties, a
      tool processing the Component annotations must write the defined factory
      properties into the generated component description in the following
      order.</para>

      <orderedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.component.annotations.Component.factoryProperty--"
          xrefstyle="hyperlink"/> element of the <xref
          linkend="org.osgi.service.component.annotations.Component"
          xrefstyle="hyperlink"/> annotation.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.annotations.Component.factoryProperties--"
          xrefstyle="hyperlink"/> element of the <xref
          linkend="org.osgi.service.component.annotations.Component"
          xrefstyle="hyperlink"/> annotation.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section xml:id="service.component-component.lifecycle">
    <title>Component Life Cycle</title>

    <section xml:id="service.component-enabled">
      <title>Enabled</title>

      <para>A component must first be <emphasis>enabled</emphasis> before it
      can be used. A component cannot be enabled unless the component's bundle
      is started. See <emphasis>Starting Bundles</emphasis> in <xref
      linkend="intro.core.release" xrefstyle="template:%t"/>. All components
      in a bundle become disabled when the bundle is stopped. So the life
      cycle of a component is contained within the life cycle of its
      bundle.</para>

      <para>Every component can be enabled or disabled. The initial enabled
      state of a component is specified in the component description via the
      <code>enabled</code> attribute of the <code>component</code> element.
      See <xref linkend="service.component-component.element"/>. Component
      configurations can be created, satisfied and activated only when the
      component is enabled.</para>

      <para>The enabled state of a component can be controlled with the
      Component Context <xref
      linkend="org.osgi.service.component.ComponentContext.enableComponent-String-"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.component.ComponentContext.disableComponent-String-"
      xrefstyle="hyperlink"/> methods. The purpose of later enabling a
      component is to be able to decide programmatically when a component can
      become enabled. For example, an immediate component can perform some
      initialization work before other components in the bundle are enabled.
      The component descriptions of all other components in the bundle can be
      disabled by having <code>enabled</code> set to <code>false</code> in
      their component descriptions. After any necessary initialization work is
      complete, the immediate component can call <code>enableComponent</code>
      to enable the remaining components.</para>

      <para>The <code>enableComponent</code> and <code>disableComponent</code>
      methods must return after changing the enabled state of the named
      component. Any actions that result from this, such as activating or
      deactivating a component configuration, must occur asynchronously to the
      method call. Therefore a component can disable itself.</para>

      <para>All components in a bundle can be enabled by passing a
      <code>null</code> as the argument to
      <code>enableComponent</code>.</para>
    </section>

    <section>
      <title>Satisfied</title>

      <para>Component configurations can only be activated when the component
      configuration is <emphasis>satisfied</emphasis>. A component
      configuration becomes satisfied when the following conditions are all
      satisfied:</para>

      <itemizedlist>
        <listitem>
          <para>The component is <emphasis>enabled</emphasis>.</para>
        </listitem>

        <listitem>
          <para>If the component description specifies
          <code>configuration-policy=required</code>, then a
          <code>Configuration</code> object for the component is present in
          the Configuration Admin service.</para>
        </listitem>

        <listitem>
          <para>Using the component properties of the component configuration,
          all the component's references are satisfied. A reference is
          satisfied when the reference specifies optional cardinality or the
          number of target services is equal to or more than the minimum
          cardinality of the reference.</para>
        </listitem>
      </itemizedlist>

      <para>Once any of the listed conditions are no longer true, the
      component configuration becomes <emphasis>unsatisfied</emphasis>. An
      activated component configuration that becomes unsatisfied must be
      deactivated.</para>
    </section>

    <section>
      <title>Immediate Component</title>

      <para>A component is an immediate component when it must be activated as
      soon as its dependencies are satisfied. Once the component configuration
      becomes unsatisfied, the component configuration must be deactivated. If
      an immediate component configuration is satisfied and specifies a
      service, SCR must register the component configuration as a service in
      the service registry and then activate the component configuration. The
      service properties for this registration consist of the component
      properties as defined in <xref
      linkend="service.component-service.properties"/>.</para>

      <para>The state diagram is shown in <xref linkend="i1445265"/>.</para>

      <figure xml:id="i1445265">
        <title>Immediate Component Configuration</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.443in"
                       contentwidth="7.000in"
                       fileref="immediate-configuration.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="service.component-delayed.component">
      <title>Delayed Component</title>

      <para>A key attribute of a delayed component is the delaying of class
      loading and object creation. Therefore, the activation of a delayed
      component configuration does not occur until there is an actual request
      for a service object. A component is a delayed component when it
      specifies a service but it is not a factory component and does not have
      the <code>immediate</code> attribute of the <code>component</code>
      element set to <code>true</code>.</para>

      <para>SCR must register a service after the component configuration
      becomes satisfied. The registration of this service must look to
      observers of the service registry as if the component's bundle actually
      registered this service. This makes it possible to register services
      without creating a class loader for the bundle and loading classes,
      thereby allowing reduction in initialization time and a delay in memory
      footprint.</para>

      <para>When SCR registers the service on behalf of a component
      configuration, it must avoid causing a class load to occur from the
      component's bundle. SCR can ensure this by registering a
      <code>ServiceFactory</code> object with the Framework for that service.
      By registering a <code>ServiceFactory</code> object, the actual service
      object is not needed until the <code>ServiceFactory</code> is called to
      provide the service object. The service properties for this registration
      consist of the component properties as defined in <xref
      linkend="service.component-service.properties"/>.</para>

      <para>The activation of a component configuration must be delayed until
      its service is requested. When the service is requested, if the service
      has the <code>scope</code> attribute set to <code>bundle</code>, SCR
      must create and activate a unique component configuration for each
      bundle requesting the service. If the service has the <code>scope</code>
      attribute set to <code>prototype</code>, SCR must create and activate a
      unique component configuration for each distinct request for the
      service. Otherwise, if the service has the <code>scope</code> attribute
      set to <code>singleton</code>, SCR must activate a single component
      configuration which is used by all requests for the service. A component
      instance can determine the bundle it was activated for by calling the
      <xref
      linkend="org.osgi.service.component.ComponentContext.getUsingBundle--"
      xrefstyle="hyperlink"/> method on the Component Context.</para>

      <para>The activation of delayed components is depicted in a state
      diagram in <xref linkend="i1462979"/>. Notice that multiple component
      configurations can be created from the <code>REGISTERED</code> state if
      a delayed component specifies a service <code>scope</code> set to a
      value other than <code>singleton</code>.</para>

      <para>If the service has the <code>scope</code> attribute set to
      <code>prototype</code>, SCR must deactivate a component configuration
      when it stops being used as a service object since the component
      configuration must not be reused as a service object. If the service has
      the <code>scope</code> attribute set to <code>singleton</code> or
      <code>bundle</code>, SCR must deactivate a component configuration when
      it stops being used as a service object after a delay since the
      component configuration may be reused as a service object in the near
      future. This allows SCR implementations to reclaim component
      configurations not in use while attempting to avoid deactivating a
      component configuration only to have to quickly activate a new component
      configuration for a new service request. The delay amount is
      implementation specific and may be zero.</para>

      <figure xml:id="i1462979">
        <title>Delayed Component Configuration</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.979in"
                       contentwidth="7.000in"
                       fileref="delayed-configuration.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Factory Component</title>

      <para>SCR must register a Component Factory service as soon as the
      <emphasis>component factory</emphasis> becomes satisfied. The component
      factory is satisfied when the following conditions are all
      satisfied:</para>

      <itemizedlist>
        <listitem>
          <para>The component is enabled.</para>
        </listitem>

        <listitem>
          <para>Using the component properties specified by the component
          description, all the component's references are satisfied. A
          reference is satisfied when the reference specifies optional
          cardinality or there is at least one target service for the
          reference.</para>
        </listitem>
      </itemizedlist>

      <para>The component factory, however, does not use any of the target
      services and does not bind to them.</para>

      <para>Once any of the listed conditions are no longer true, the
      component factory becomes unsatisfied and the Component Factory service
      must be unregistered. Any component configurations activated via the
      component factory are unaffected by the unregistration of the Component
      Factory service, but may themselves become unsatisfied for the same
      reason.</para>

      <para>The Component Factory service must be registered under the name
      <code>org.osgi.service.component.ComponentFactory</code> with the
      following service properties:</para>

      <itemizedlist>
        <listitem>
          <para><code>component.name</code> - The name of the
          component.</para>
        </listitem>

        <listitem>
          <para><code>component.factory</code> - The value of the
          <code>factory</code> attribute.</para>
        </listitem>
      </itemizedlist>

      <para>The service properties of the Component Factory service must not
      include the component properties.</para>

      <para>New component configurations are created and activated when the
      <code>newInstance</code> method of the Component Factory service is
      called. If the component description specifies a service, the component
      configuration is registered as a service under the provided interfaces.
      The service properties for this registration consist of the component
      properties as defined in <xref
      linkend="service.component-service.properties"/>. The service
      registration must take place before the component configuration is
      activated. Service unregistration must take place before the component
      configuration is deactivated.</para>

      <figure>
        <title>Factory Component</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.929in"
                       contentwidth="7.000in" fileref="factory-component.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A Component Factory service has a single method: <xref
      linkend="org.osgi.service.component.ComponentFactory.newInstance-Dictionary-"
      xrefstyle="hyperlink"/>. This method must create, satisfy and activate a
      new component configuration and register its component instance as a
      service if the component description specifies a service. It must then
      return a <xref linkend="org.osgi.service.component.ComponentInstance"
      xrefstyle="hyperlink"/> object. This <xref
      linkend="org.osgi.service.component.ComponentInstance"
      xrefstyle="hyperlink"/> object can be used to get the component instance
      with the <xref
      linkend="org.osgi.service.component.ComponentInstance.getInstance--"
      xrefstyle="hyperlink"/> method.</para>

      <para>SCR must attempt to satisfy the component configuration created by
      <code>newInstance</code> before activating it. If SCR is unable to
      satisfy the component configuration given the component properties and
      the Dictionary argument to <code>newInstance</code>, the
      <code>newInstance</code> method must throw a
      <code>ComponentException</code>.</para>

      <para>The client of the Component Factory service can also deactivate a
      component configuration with the <xref
      linkend="org.osgi.service.component.ComponentInstance.dispose--"
      xrefstyle="hyperlink"/> method on the <xref
      linkend="org.osgi.service.component.ComponentInstance"
      xrefstyle="hyperlink"/> object. If the component configuration is
      already deactivated, or is being deactivated, then this method is
      ignored. Also, if the component configuration becomes unsatisfied for
      any reason, it must be deactivated by SCR.</para>

      <para>Once a component configuration created by the Component Factory
      has been deactivated, that component configuration will not be
      reactivated or used again.</para>
    </section>

    <section xml:id="service.component-activation">
      <title>Activation</title>

      <para>Activating a component configuration consists of the following
      steps:</para>

      <orderedlist>
        <listitem>
          <para>Load the component implementation class.</para>
        </listitem>

        <listitem>
          <para>Compute the bound services. See <xref
          linkend="service.component-bound.services"/>.</para>
        </listitem>

        <listitem>
          <para>Create the component context. See <xref
          linkend="service.component-component.context"/>.</para>
        </listitem>

        <listitem>
          <para>Construct the component instance. See <xref
          linkend="service.component-constructor.injection"/>.</para>
        </listitem>

        <listitem>
          <para>Set the activation fields, if any. See <xref
          linkend="service.component-activation.objects"/>.</para>
        </listitem>

        <listitem>
          <para>Bind the bound services. See <xref
          linkend="service.component-binding.services"/>.</para>
        </listitem>

        <listitem>
          <para>Call the <code>activate</code> method, if any. See <xref
          linkend="service.component-activate.method"/>. Calling the
          <code>activate</code> method signals the completion of activating
          the component instance.</para>
        </listitem>
      </orderedlist>

      <para>Component instances must never be reused. Each time a component
      configuration is activated, SCR must create a new component instance to
      use with the activated component configuration. A component instance
      must complete activation before it can be deactivated. Once the
      component configuration is deactivated or fails to activate due to an
      exception, SCR must unbind all the component's bound services and
      discard all references to the component instance associated with the
      activation.</para>
    </section>

    <section xml:id="service.component-bound.services">
      <title>Bound Services</title>

      <para>When a component configuration's reference is satisfied, there is
      a set of zero or more target services for that reference. When the
      component configuration is activated, a subset of the target services
      for each reference are bound to the component configuration. The subset
      is chosen by the cardinality of the reference. See <xref
      linkend="service.component-reference.cardinality"/>.</para>

      <para>Obtaining the service object for a bound service may result in
      activating a component configuration of the bound service which could
      result in an exception. If the loss of the bound service due to the
      exception causes the reference's cardinality constraint to be violated,
      then activation of this component configuration will fail. Otherwise the
      bound service which failed to activate will be considered
      unbound.</para>
    </section>

    <section xml:id="service.component-component.context">
      <title>Component Context</title>

      <para>The Component Context can be made available to a component
      instance during activation, modification, and deactivation. It provides
      the interface to the execution context of the component, much like the
      Bundle Context provides a bundle the interface to the Framework. A
      Component Context should therefore be regarded as a capability and not
      shared with other components or bundles.</para>

      <para>Each distinct component instance receives a unique Component
      Context. Component Contexts are not reused and must be discarded when
      the component configuration is deactivated.</para>
    </section>

    <section xml:id="service.component-activation.objects">
      <title>Activation Objects</title>

      <para>A component can have an <code>activate</code> method, activation
      fields, and also receive activation objects via its constructor.</para>

      <para>The following <emphasis>activation object</emphasis> types are
      supported:</para>

      <itemizedlist>
        <listitem>
          <para><code>ComponentContext</code> - The Component Context for the
          component configuration.</para>
        </listitem>

        <listitem>
          <para><code>BundleContext</code> - The Bundle Context of the
          component's bundle.</para>
        </listitem>

        <listitem>
          <para><code>Map</code> - An unmodifiable Map containing the
          component properties.</para>
        </listitem>

        <listitem>
          <para>A component property type - An instance of the component
          property type which allows type safe access to component properties
          defined by the component property type. See <xref
          linkend="service.component-component.property.types"/>.</para>
        </listitem>
      </itemizedlist>

      <para>For activation fields, only instance fields of the activation
      object types above are supported. If an activation field is declared
      with the <code>static</code> modifier or has a type other than one of
      the above, SCR must log an error message with the Log Service, if
      present, and the field must not be modified. SCR must locate a suitable
      field as specified in <xref
      linkend="service.component-locating.members"/>. If no suitable field is
      located for an activation field name, SCR must log an error message with
      the Log Service, if present.</para>
    </section>

    <section xml:id="service.component-binding.services">
      <title>Binding Services</title>

      <para>When binding services, the references are processed in the order
      in which they are specified in the component description. That is,
      target services from the first specified reference are bound before
      services from the next specified reference.</para>

      <para>If the reference uses field injection, the field must be set.
      Then, if the reference uses method injection, the bind method must be
      called for each bound service of that reference. If a bind method throws
      an exception, SCR must log an error message containing the exception
      with the Log Service, if present, but the activation of the component
      configuration does not fail.</para>
    </section>

    <section xml:id="service.component-activate.method">
      <title>Activate Method</title>

      <para>A component can have an <code>activate</code> method. The name of
      the <code>activate</code> method can be specified by the
      <code>activate</code> attribute. If the <code>activate</code> attribute
      is not specified, the default method name of <code>activate</code> is
      used. See <xref linkend="service.component-component.element"/>.</para>

      <para>The activate method can take zero or more parameters. Each
      parameter must be assignable from one of the activation object types. A
      suitable method is selected using the following priority:</para>

      <orderedlist>
        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is
          <code>org.osgi.service.component.ComponentContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>org.osgi.framework.BundleContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is a component property type.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>java.util.Map</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes two or more parameters and the type of each
          parameter must be one of the activation object types. If multiple
          methods match this rule, this implies the method name is overloaded
          and SCR may choose any of the methods to call.</para>
        </listitem>

        <listitem>
          <para>The method takes zero parameters.</para>
        </listitem>
      </orderedlist>

      <para>When searching for the activate method to call, SCR must locate a
      suitable method as specified in <xref
      linkend="service.component-locating.members"/>. If the
      <code>activate</code> attribute is specified and no suitable method is
      located, SCR must log an error message with the Log Service, if present,
      and the component configuration is not activated.</para>

      <para>If an activate method is located, SCR must call this method to
      complete the activation of the component configuration. If the activate
      method throws an exception, SCR must log an error message containing the
      exception with the Log Service, if present, and the component
      configuration is not activated.</para>
    </section>

    <section xml:id="service.component-bound.service.replacement">
      <title>Bound Service Replacement</title>

      <para>If an active component configuration has a dynamic reference with
      unary cardinality and the bound service is modified or unregistered and
      ceases to be a target service, or the <code>policy-option</code> is
      <code>greedy</code> and a better target service becomes available then
      SCR must attempt to replace the bound service with a new bound
      service.</para>

      <para>If the reference uses field injection, the field must be set for
      the replacement bound service. Then, if the reference uses method
      injection, SCR must first bind the new bound service and then unbind the
      outgoing service. This reversed order allows the component to not have
      to handle the inevitable gap between the unbind and bind methods.
      However, this means that in the unbind method care must be taken to not
      overwrite the newly bound service. For example, the following code
      handles the associated concurrency issues and simplify handling the
      reverse order.</para>

      <programlisting>final AtomicReference&lt;LogService&gt; log = new AtomicReference&lt;LogService&gt;();

void setLogService( LogService log ) {
    this.log.set(log);
}
void unsetLogService( LogService log ) {
    this.log.compareAndSet(log, null);
}</programlisting>

      <para>If the dynamic reference falls below the minimum cardinality, the
      component configuration must be deactivated because the cardinality
      constraints will be violated.</para>

      <para>If a component configuration has a static reference and a bound
      service is modified or unregistered and ceases to be a target service,
      or the <code>policy-option</code> is <code>greedy</code> and a better
      target service becomes available then SCR must deactivate the component
      configuration. Afterwards, SCR must attempt to activate the component
      configuration again if another target service can be used as a
      replacement for the outgoing service.</para>
    </section>

    <section>
      <title>Updated</title>

      <para>If an active component is bound to a service that modifies its
      service properties then the component can be updated. If the reference
      uses field injection and the field holds the service properties, the
      field must be set for the updated bound service. Then, if the reference
      uses method injection and specifies an updated method, the updated
      method must be called.</para>
    </section>

    <section xml:id="service.component-modification">
      <title>Modification</title>

      <para>Modifying a component configuration can occur if the component
      description specifies the <code>modified</code> attribute and the
      component properties of the component configuration use a
      <code>Configuration</code> object from the Configuration Admin service
      and that <code>Configuration</code> object is modified without causing
      the component configuration to become unsatisfied. If this occurs, the
      component instance will be notified of the change in the component
      properties.</para>

      <para>If the <code>modified</code> attribute is not specified, then the
      component configuration will become unsatisfied if its component
      properties use a <code>Configuration</code> object and that
      Configuration object is modified in any way.</para>

      <para>Modifying a component configuration consists of the following
      steps:</para>

      <orderedlist>
        <listitem>
          <para>Update the component context for the component configuration
          with the modified configuration properties.</para>
        </listitem>

        <listitem>
          <para>Call the modified method. See <xref
          linkend="service.component-modified.method"/>.</para>
        </listitem>

        <listitem>
          <para>Modify the bound services for the dynamic references if the
          set of target services changed due to changes in the target
          properties. See <xref
          linkend="service.component-bound.service.replacement"/>.</para>
        </listitem>

        <listitem>
          <para>If the component configuration is registered as a service,
          modify the service properties.</para>
        </listitem>
      </orderedlist>

      <para>A component instance must complete activation, or a previous
      modification, before it can be modified.</para>

      <para>See <xref linkend="service.component-configuration.changes"/> for
      more information.</para>
    </section>

    <section xml:id="service.component-modified.method">
      <title>Modified Method</title>

      <para>The name of the modified method is specified by the
      <code>modified</code> attribute. See <xref
      linkend="service.component-component.element"/>.</para>

      <para>The modified method can take zero or more parameters. Each
      parameter must be assignable from one of the activation object types. A
      suitable method is selected using the following priority:</para>

      <orderedlist>
        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is
          <code>org.osgi.service.component.ComponentContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>org.osgi.framework.BundleContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is a component property type.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>java.util.Map</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes two or more parameters and the type of each
          parameter must be one of the activation object types. If multiple
          methods match this rule, this implies the method name is overloaded
          and SCR may choose any of the methods to call.</para>
        </listitem>

        <listitem>
          <para>The method takes zero parameters.</para>
        </listitem>
      </orderedlist>

      <para>SCR must locate a suitable method as specified in <xref
      linkend="service.component-locating.members"/>. If the
      <code>modified</code> attribute is specified and no suitable method is
      located, SCR must log an error message with the Log Service, if present,
      and the component configuration becomes unsatisfied and is deactivated
      as if the <code>modified</code> attribute was not specified.</para>

      <para>If a modified method is located, SCR must call this method to
      notify the component configuration of changes to the component
      properties. If the modified method throws an exception, SCR must log an
      error message containing the exception with the Log Service, if present
      and continue processing the modification.</para>
    </section>

    <section xml:id="service.component-deactivation">
      <title>Deactivation</title>

      <para>Deactivating a component configuration consists of the following
      steps:</para>

      <orderedlist>
        <listitem>
          <para>Call the deactivate method, if present. See <xref
          linkend="service.component-deactivate.method"/>.</para>
        </listitem>

        <listitem>
          <para>Unbind any bound services. See <xref
          linkend="service.component-unbinding"/>.</para>
        </listitem>

        <listitem>
          <para>Release all references to the component instance and component
          context.</para>
        </listitem>
      </orderedlist>

      <para>A component instance must complete activation or modification
      before it can be deactivated. A component configuration can be
      deactivated for a variety of reasons. The deactivation reason can be
      received by the deactivate method. The following reason values are
      defined:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.component.ComponentConstants.DEACTIVATION_REASON_UNSPECIFIED"
          xrefstyle="hyperlink"/> - Unspecified.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.ComponentConstants.DEACTIVATION_REASON_DISABLED"
          xrefstyle="hyperlink"/> - The component was disabled.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.ComponentConstants.DEACTIVATION_REASON_REFERENCE"
          xrefstyle="hyperlink"/> - A reference became unsatisfied.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.ComponentConstants.DEACTIVATION_REASON_CONFIGURATION_MODIFIED"
          xrefstyle="hyperlink"/> - A configuration was changed.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.ComponentConstants.DEACTIVATION_REASON_CONFIGURATION_DELETED"
          xrefstyle="hyperlink"/> - A configuration was deleted.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.ComponentConstants.DEACTIVATION_REASON_DISPOSED"
          xrefstyle="hyperlink"/> - The component was disposed.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.ComponentConstants.DEACTIVATION_REASON_BUNDLE_STOPPED"
          xrefstyle="hyperlink"/> - The bundle was stopped.</para>
        </listitem>
      </itemizedlist>

      <para>Once the component configuration is deactivated, SCR must discard
      all references to the component instance and component context
      associated with the activation.</para>
    </section>

    <section xml:id="service.component-deactivate.method">
      <title>Deactivate Method</title>

      <para>A component instance can have a deactivate method. The name of the
      deactivate method can be specified by the <code>deactivate</code>
      attribute. See <xref linkend="service.component-component.element"/>. If
      the <code>deactivate</code> attribute is not specified, the default
      method name of <code>deactivate</code> is used. Activation fields must
      not be modified during deactivation.</para>

      <para>The deactivate method can take zero or more parameters. Each
      parameter must be assignable from one of the following types:</para>

      <itemizedlist>
        <listitem>
          <para>One of the activation object types.</para>
        </listitem>

        <listitem>
          <para><code>int</code> or <code>Integer</code> - The reason the
          component configuration is being deactivated. See <xref
          linkend="service.component-deactivation"/>.</para>
        </listitem>
      </itemizedlist>

      <para>A suitable method is selected using the following priority:</para>

      <orderedlist>
        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is
          <code>org.osgi.service.component.ComponentContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>org.osgi.framework.BundleContext</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is a component property type.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>java.util.Map</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>int</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes a single parameter and the type of the
          parameter is <code>java.lang.Integer</code>.</para>
        </listitem>

        <listitem>
          <para>The method takes two or more parameters and the type of each
          parameter must be one of the activation object types,
          <code>int</code> or <code>java.lang.Integer</code>. If multiple
          methods match this rule, this implies the method name is overloaded
          and SCR may choose any of the methods to call.</para>
        </listitem>

        <listitem>
          <para>The method takes zero parameters.</para>
        </listitem>
      </orderedlist>

      <para>When searching for the deactivate method to call, SCR must locate
      a suitable method as specified in <xref
      linkend="service.component-locating.members"/>. If the
      <code>deactivate</code> attribute is specified and no suitable method is
      located, SCR must log an error message with the Log Service, if present,
      and the deactivation of the component configuration will
      continue.</para>

      <para>If a deactivate method is located, SCR must call this method to
      commence the deactivation of the component configuration. If the
      deactivate method throws an exception, SCR must log an error message
      containing the exception with the Log Service, if present, and the
      deactivation of the component configuration will continue.</para>
    </section>

    <section xml:id="service.component-unbinding">
      <title>Unbinding</title>

      <para>When a component configuration is deactivated, the bound services
      are unbound from the component configuration.</para>

      <para>When unbinding services, the references are processed in the
      reverse order in which they are specified in the component description.
      That is, target services from the last specified reference are unbound
      before services from the previous specified reference.</para>

      <para>If the reference uses method injection, the unbind method must be
      called for each bound service of that reference. If an unbind method
      throws an exception, SCR must log an error message containing the
      exception with the Log Service, if present, and the deactivation of the
      component configuration will continue. Then, if the reference uses field
      injection, the field must be set to <code>null</code>.</para>
    </section>

    <section>
      <title>Life Cycle Example</title>

      <para>A component could declare a dependency on the Http Service to
      register some resources.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;scr:component name="example.binding"
    xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
    &lt;implementation class="com.acme.impl.Binding"/&gt;
    &lt;reference name="LOG"
        interface="org.osgi.service.log.LogService"
        cardinality="1..1"
        policy="static"
    /&gt;   
    &lt;reference name="HTTP"
        interface="org.osgi.service.http.HttpService"
        cardinality="0..1"
        policy="dynamic"
        bind="setHttp"
        unbind="unsetHttp"
    /&gt;
&lt;/scr:component&gt;</programlisting>

      <para>The component implementation code looks like:</para>

      <programlisting>public class Binding {
    LogService  log;
    HttpService http;

    private void setHttp(HttpService h) {
        http = h;
        // register servlet
    }
    private void unsetHttp(HttpService h){
        if (http == h)
            http = null;
        // unregister servlet
    }
    private void activate(ComponentContext context ) {
        log = (LogService) context.locateService("LOG");
    }
    private void deactivate(ComponentContext context ) {...}
}</programlisting>

      <para>This example is depicted in a sequence diagram in <xref
      linkend="i1567615"/> with the following scenario:</para>

      <orderedlist>
        <listitem>
          <para>A bundle with the <code>example.Binding</code> component is
          started. At that time there is a Log Service <code>l1</code> and a
          Http Service <code>h1</code> registered.</para>
        </listitem>

        <listitem>
          <para>The Http Service <code>h1</code> is unregistered</para>
        </listitem>

        <listitem>
          <para>A new Http Service <code>h2</code> is registered</para>
        </listitem>

        <listitem>
          <para>The Log Service <code>h1</code> is unregistered.</para>
        </listitem>
      </orderedlist>

      <figure xml:id="i1567615">
        <title>Sequence Diagram for binding</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="3.062in"
                       contentwidth="7.000in" fileref="binding-sequence.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section xml:id="service.component-component.properties">
    <title>Component Properties</title>

    <para>Each component configuration is associated with a set of component
    properties. The component properties are specified in the following
    <emphasis>configuration sources</emphasis> (in order of
    precedence):</para>

    <orderedlist>
      <listitem>
        <para>Properties specified in the argument of the
        <code>ComponentFactory.newInstance</code> method. This is only
        applicable for factory components.</para>
      </listitem>

      <listitem>
        <para>Properties retrieved from the OSGi Configuration Admin service
        in Configuration objects whose PID matches a <emphasis>configuration
        PID</emphasis>. The configuration PIDs are specified by the
        <code>configuration-pid</code> attribute of the <code>component</code>
        element. See <xref linkend="service.component-component.element"/>. If
        no <code>configuration-pid</code> attribute is specified, the
        component name is used as the default configuration PID. If multiple
        configuration PIDs are specified, the order of precedence follows the
        order the configuration PIDs are specified in the component
        description. That is, the precedence for the configuration for an
        earlier specified configuration PID is lower than the precedence for
        the configurations for a later specified configuration PID.</para>
      </listitem>

      <listitem>
        <para>Properties specified in the component description via
        <code>property</code> and <code>properties</code> elements. Properties
        specified later in the component description override properties that
        have the same name specified earlier. See <xref
        linkend="service.component-property.properties.elements"/>.</para>
      </listitem>

      <listitem>
        <para>Target properties specified in the component description via the
        <code>target</code> attribute of <code>reference</code> elements. See
        <xref linkend="service.component-target.property"/>. The value of the
        <code>target</code> attribute is used for the value of a target
        property.</para>
      </listitem>
    </orderedlist>

    <para>The precedence behavior allows certain default values to be
    specified in the component description while allowing properties to be
    replaced and extended by:</para>

    <itemizedlist>
      <listitem>
        <para>A configuration in Configuration Admin</para>
      </listitem>

      <listitem>
        <para>The argument to the <code>ComponentFactory.newInstance</code>
        method</para>
      </listitem>
    </itemizedlist>

    <para>Normally, a property value from a higher precedence configuration
    source replace a property value from a lower precedence configuration
    source. However, the <code>service.pid</code> property values receive
    different treatment. For the <code>service.pid</code> property, if the
    property appears multiple times in the configuration sources, SCR must
    aggregate all the values found into a
    <code>Collection&lt;String&gt;</code> having an iteration order such that
    the first item in the iteration is the property value from the lowest
    precedence configuration source and the last item in the iteration is the
    property value from the highest precedence configuration source. If the
    component description specifies multiple configuration PIDs, then the
    order of the <code>service.pid</code> property values from the
    corresponding configurations matches the order the configuration PIDs are
    specified in the component description. The values of the
    <code>service.pid</code> component property are the values as they come
    from the configuration sources which, for Configuration objects, may be
    more detailed than the configuration PIDs specified in the component
    description.</para>

    <para>SCR always adds the following component properties, which cannot be
    overridden:</para>

    <itemizedlist>
      <listitem>
        <para><code>component.name</code> - The component name.</para>
      </listitem>

      <listitem>
        <para><code>component.id</code> - A unique value ( <code>Long</code>)
        that is larger than all previously assigned values. These values are
        not persistent across restarts of SCR.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="service.component-service.properties">
      <title>Service Properties</title>

      <para>When SCR registers a service on behalf of a component
      configuration, SCR must follow the recommendations in <xref
      linkend="service.cm.propertypropagation"/> and must not propagate
      private configuration properties. That is, the service properties of the
      registered service must be all the component properties of the component
      configuration whose property names do not start with full stop
      (<code>'.' \u002E</code>).</para>

      <para>Component properties whose names start with full stop are
      available to the component instance but are not available as service
      properties of the registered service.</para>
    </section>

    <section xml:id="service.component-reference.properties">
      <title>Reference Properties</title>

      <para>This specification defines some component properties which are
      associated with specific component references. These are called
      <emphasis>reference properties</emphasis>. The name of a reference
      property for a reference is the name of the reference appended with a
      full stop (<code>'.' \u002E</code>) and a suffix unique to the reference
      property. Reference properties can be set wherever component properties
      can be set.</para>

      <para>All component property names starting with a reference name
      followed by a full stop (<code>'.' \u002E</code>) are reserved for use
      by this specification.</para>

      <para>Following are the reference properties defined by this
      specification.</para>

      <section xml:id="service.component-target.property">
        <title>Target Property</title>

        <para>The <emphasis>target property</emphasis> is a reference property
        which aids in the selection of target services for the reference. See
        <xref linkend="service.component-selecting.target.services"/>. The
        name of a target property is the name of a reference appended with
        <code>.target</code>. For example, the target property for a reference
        with the name <code>http</code> would have the name
        <code>http.target</code>. The value of a target property is a filter
        string used to select targets services for the reference.</para>

        <para>The target property for a reference can also be set by the
        <code>target</code> attribute of the <code>reference</code> element.
        See <xref linkend="service.component-reference.element"/>.</para>
      </section>

      <section xml:id="service.component-minimum.cardinality.property">
        <title>Minimum Cardinality Property</title>

        <para>The initial minimum cardinality of a reference is specified by
        the optionality: the first part of the cardinality. It is either
        <code>0</code> or <code>1</code>. The minimum cardinality of a
        reference cannot exceed the multiplicity: the second part of the
        cardinality. See <xref
        linkend="service.component-reference.cardinality"/> for more
        information on the cardinality of a reference.</para>

        <para>The <emphasis>minimum cardinality property</emphasis> is a
        reference property which can be used to raise the minimum cardinality
        of a reference from its initial value. That is, a <code>0..1</code>
        cardinality can be raised to a <code>1..1</code> cardinality by
        setting the reference's minimum cardinality property to
        <code>1</code>, and a <code>0..n</code> or <code>1..n</code>
        cardinality can be raised to a <code>m..n</code> cardinality by
        setting the reference's minimum cardinality property to <code>m</code>
        such that <code>m</code> is a positive integer. The minimum
        cardinality of a reference cannot be lowered. That is, a
        <code>1..1</code> or <code>1..n</code> cardinality cannot be lowered
        to a <code>0..1</code> or <code>0..n</code> cardinality because the
        component was coded to expect at least one bound service.</para>

        <para>The name of a minimum cardinality property is the name of a
        reference appended with <code>.cardinality.minimum</code>. For
        example, the minimum cardinality property for a reference with the
        name <code>http</code> would have the name
        <code>http.cardinality.minimum</code>. The value of a minimum
        cardinality property must be a positive integer or a value that can be
        coerced into a positive integer. See <xref
        linkend="service.component-component.property.value.coercion"/> for
        information on coercing property values. If the numerical value of the
        minimum cardinality property is not valid for the reference's
        cardinality or the minimum cardinality property value cannot be
        coerced into a numerical value, then the minimum cardinality property
        must be ignored.</para>

        <para>SCR must support the minimum cardinality property for all
        components even those with component descriptions in older
        namespaces.</para>
      </section>
    </section>
  </section>

  <section xml:id="service.component-deployment">
    <title>Deployment</title>

    <para>A component description contains default information to select
    target services for each reference. However, when a component is deployed,
    it is often necessary to influence the target service selection in a way
    that suits the needs of the deployer. Therefore, SCR uses
    <code>Configuration</code> objects from Configuration Admin to replace and
    extend the component properties for a component configuration. That is,
    through Configuration Admin, a deployer can configure component
    properties.</para>

    <para>A component's configuration PIDs are used as keys for obtaining
    additional component properties from Configuration Admin. When
    <emphasis>matching</emphasis> a configuration PID to a
    <code>Configuration</code> object, SCR must use the
    <code>Configuration</code> object with the best matching PID for the
    component's bundle. See <xref linkend="service.cm-targeted.pids"/> for
    more information on targeted PIDs and <xref
    linkend="service.cm-extenders.targeted.pids"/> for more information on
    selecting the <code>Configuration</code> object with the best matching
    PID.</para>

    <para>The following situations can arise when looking for
    <code>Configuration</code> objects:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>No Configuration</emphasis> - If the component's
        <code>configuration-policy</code> is set to <code>ignore</code> or
        there are no Configurations with a PID or factory PID matching any of
        the configuration PIDs, then component configurations will not obtain
        component properties from Configuration Admin. Only component
        properties specified in the component description or via the
        <code>ComponentFactory.newInstance</code> method will be used.</para>
      </listitem>

      <listitem>
        <para><emphasis>Not Satisfied</emphasis> - If the component's
        <code>configuration-policy</code> is set to <code>require</code> and,
        for each configuration PID, there is no Configuration with a matching
        PID or factory PID, then the component configuration is not satisfied
        and will not be activated.</para>
      </listitem>

      <listitem>
        <para><emphasis>Single Configuration</emphasis> - If none of the
        configuration PIDs matches a factory PID, then component
        configurations will obtain additional component properties from
        Configuration Admin.</para>
      </listitem>

      <listitem>
        <para><emphasis>Factory Configuration</emphasis> - If one of the
        configuration PIDs matches a factory PID, with zero or more
        Configurations, then for each Configuration of the factory PID, a
        component configuration must be created that will obtain additional
        component properties from Configuration Admin.</para>

        <para>It is a configuration error if more than one of the
        configuration PIDs match a factory PID and SCR must log an error
        message with the Log Service, if present. If the
        <code>configuration-policy</code> is set to <code>optional</code>, the
        component configuration must be satisfied without the configurations
        PIDs which match a factory PID. If the
        <code>configuration-policy</code> is set to <code>require</code>, the
        component configuration is not satisfied and will not be
        activated.</para>

        <para>A factory configuration must not be used if the component is a
        factory component. This is because SCR is not free to create component
        configurations as necessary to support multiple Configurations. When
        SCR detects this condition, it must log an error message with the Log
        Service, if present, and ignore the component description.</para>
      </listitem>
    </itemizedlist>

    <para>SCR must obtain the <code>Configuration</code> objects from the
    Configuration Admin service using the Bundle Context of the bundle
    containing the component. SCR must only use <code>Configuration</code>
    objects for which the bundle containing the component has visibility. See
    <xref linkend="service.cm-location.binding"/>.</para>

    <para>To ensure Configuration Plugins can participate in the configuration
    process, SCR must use the
    <code>Configuration.getProcessedProperties</code> method when obtaining
    the configuration data from a <code>Configuration</code> object. To use
    the <code>getProcessedProperties</code> method, SCR must supply a Service
    Reference for a <code>ManagedService</code> or
    <code>ManagedServiceFactory</code> service. The
    <code>ManagedService</code> or <code>ManageServiceFactory</code> service
    must be registered using the Bundle Context of the bundle containing the
    component. If SCR registers one of these services for the purpose of using
    the service's Service Reference for the call to
    <code>getProcessedProperties</code>, SCR should register the service
    without a <code>service.pid</code> service property so that the service
    itself is not called by Configuration Admin.</para>

    <para>For example, there is a component named <code>com.acme.client</code>
    with a reference named <code>HTTP</code> that requires an Http Service
    which must be bound to a component <code>com.acme.httpserver</code> which
    provides an Http Service. A deployer can establish the following
    configuration:</para>

    <programlisting>[PID=com.acme.client, factoryPID=null]
HTTP.target = (component.name=com.acme.httpserver)</programlisting>

    <section xml:id="service.component-configuration.changes">
      <title>Configuration Changes</title>

      <para>SCR must track changes in the <code>Configuration</code> objects
      matching the configuration PIDs of a component description. Changes
      include the creating, updating and deleting of
      <code>Configuration</code> objects matching the configuration PIDs. The
      actions SCR must take when a configuration change for a component
      configuration occurs are based upon how the
      <code>configuration-policy</code> and <code>modified</code> attributes
      are specified in the component description, whether a component
      configuration becomes satisfied, remains satisfied or becomes
      unsatisfied and the type and number of matching
      <code>Configuration</code> objects.</para>

      <para>With targeted PIDs, multiple <code>Configuration</code> objects
      can exist which can match a configuration PID. Creation of a
      <code>Configuration</code> object with a better matching PID than a
      <code>Configuration</code> object currently being used by a component
      configuration results in a configuration change for the component
      configuration with the new <code>Configuration</code> object replacing
      the currently used <code>Configuration</code> object. Deletion of a
      <code>Configuration</code> object currently being used by a component
      configuration when there is another <code>Configuration</code> object
      matching the configuration PID also results in a configuration change
      for the component configuration with the <code>Configuration</code>
      object having the best matching PID replacing the currently used, and
      now deleted, <code>Configuration</code> object.</para>

      <section>
        <title>Ignore Configuration Policy</title>

        <para>For <code>configuration-policy</code> of <code>ignore</code>,
        component configurations are unaffected by configuration changes since
        the component properties do not include properties from
        <code>Configuration</code> objects.</para>
      </section>

      <section>
        <title>Require Configuration Policy</title>

        <para>For <code>configuration-policy</code> of <code>require</code>,
        component configurations require a <code>Configuration</code> object
        for each specified configuration PID. With a factory configuration,
        there can be zero or more matching <code>Configuration</code> objects
        which will result in a component configuration for each
        <code>Configuration</code> object of the factory configuration. With a
        factory component, multiple component configurations can be created
        all using the matching <code>Configuration</code> objects.</para>

        <para>A configuration change can cause a component configuration to
        become unsatisfied if any of the following occur:</para>

        <itemizedlist>
          <listitem>
            <para>Each configuration PID of the component description does not
            have a matching <code>Configuration</code> object.</para>
          </listitem>

          <listitem>
            <para>A target property change results in a bound service of a
            static reference ceasing to be a target service.</para>
          </listitem>

          <listitem>
            <para>A target property change results in unbound target services
            for a static reference with the <code>greedy</code> policy
            option.</para>
          </listitem>

          <listitem>
            <para>A target property change or minimum cardinality property
            change results in a reference falling below the minimum
            cardinality.</para>
          </listitem>

          <listitem>
            <para>The component description does not specify the
            <code>modified</code> attribute.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Optional Configuration Policy</title>

        <para>For <code>configuration-policy</code> of <code>optional</code>,
        component configurations do not require <code>Configuration</code>
        objects. Since matching <code>Configuration</code> objects are
        optional, component configurations can be satisfied with zero or more
        matched configuration PIDs. If a <code>Configuration</code> object is
        then created which matches a configuration PID, this is a
        configuration change for the component configurations that are not
        using the created <code>Configuration</code> object. If a
        <code>Configuration</code> object is deleted which matches a
        configuration PID, this is a configuration change for the component
        configurations using the deleted <code>Configuration</code>
        object.</para>

        <para>Furthermore, with a factory configuration matching a
        configuration PID, the factory configuration can provide zero or more
        <code>Configuration</code> objects which will result in a component
        configuration for each <code>Configuration</code> object or a single
        component configuration when zero matching <code>Configuration</code>
        objects are provided. With a factory component, multiple component
        configurations can be created all using the <code>Configuration</code>
        objects matching the configuration PIDs.</para>

        <para>A configuration change can cause a component configuration to
        become unsatisfied if any of the following occur:</para>

        <itemizedlist>
          <listitem>
            <para>A target property change results in a bound service of a
            static reference ceasing to be a target service.</para>
          </listitem>

          <listitem>
            <para>A target property change results in unbound target services
            for a static reference with the <code>greedy</code> policy
            option.</para>
          </listitem>

          <listitem>
            <para>A target property change or minimum cardinality property
            change results in a reference falling below the minimum
            cardinality.</para>
          </listitem>

          <listitem>
            <para>The component description does not specify the
            <code>modified</code> attribute.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="service.component-configuration.change.actions">
        <title>Configuration Change Actions</title>

        <para>If a component configuration becomes unsatisfied:</para>

        <itemizedlist>
          <listitem>
            <para>SCR must deactivate the component configuration.</para>
          </listitem>

          <listitem>
            <para>If the component configuration was not created from a
            factory component, SCR must attempt to satisfy the component
            configuration with the current configuration state.</para>
          </listitem>
        </itemizedlist>

        <para>If a component configuration remains satisfied:</para>

        <itemizedlist>
          <listitem>
            <para>If the component configuration has been activated, the
            modified method is called to provide the updated component
            properties. See <xref linkend="service.component-modification"/>
            for more information.</para>
          </listitem>

          <listitem>
            <para>If the component configuration is registered as a service,
            SCR must modify the service properties.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="service.component-coordinatorsupport">
        <title>Coordinator Support</title>

        <para>The <xref linkend="service.coordinator"/> defines a mechanism
        for multiple parties to collaborate on a common task without
        <emphasis>a priori</emphasis> knowledge of who will collaborate in
        that task. Like <xref linkend="service.cm"/>, SCR must participate in
        such scenarios to coordinate with provisioning or configuration
        tasks.</para>

        <para>If configurations changes occur and an implicit coordination
        exists, SCR must delay taking action on the configuration changes
        until the coordination terminates, regardless of whether the
        coordination fails or terminates regularly.</para>
      </section>
    </section>
  </section>

  <section xml:id="service.component-annotations">
    <title>Annotations</title>

    <para>A number of <code>CLASS</code> retention annotations have been
    provided to allow tools to construct the component description XML from
    the Java class files. The Component Annotations are intended to be used
    during build time to generate the component description XML.</para>

    <para>Component Property Types, which are user defined annotations, can be
    used to describe component properties in the component description XML and
    to access those component properties at runtime in a type safe
    manner.</para>

    <section xml:id="service.component-component.annotations">
      <title>Component Annotations</title>

      <para>The Component Annotations provide a convenient way to create the
      component description XML during build time. Since annotations are
      placed in the source file and can use types, fields, and methods, they
      can significantly simplify the use of Declarative Services.</para>

      <para>The Component Annotations are build time annotations because one
      of the key aspects of Declarative Services is its laziness. SCR can
      easily read the component description XML from the bundle, preprocess
      it, and cache the results between framework invocations. This way it is
      unnecessary to load a class from the bundle when the bundle is started
      and/or scan the classes for annotations. Component Annotations are not
      recognized by SCR at runtime.</para>

      <para>The Component Annotations are not inherited, they can only be used
      on a given class, annotations on its super class hierarchy or interfaces
      are not taken into account.</para>

      <para>The primary annotation is the <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> annotation. It indicates that a class is a
      component. Its defaults create the easiest to use component:</para>

      <itemizedlist>
        <listitem>
          <para>Its name is the class name</para>
        </listitem>

        <listitem>
          <para>It registers all of the class's directly implemented
          interfaces as services</para>
        </listitem>

        <listitem>
          <para>The instance will be shared by all bundles</para>
        </listitem>

        <listitem>
          <para>It is enabled</para>
        </listitem>

        <listitem>
          <para>It is immediate if it has no services, otherwise it is
          delayed</para>
        </listitem>

        <listitem>
          <para>It has an optional configuration policy</para>
        </listitem>

        <listitem>
          <para>The configuration PID is the class name</para>
        </listitem>
      </itemizedlist>

      <para>For example, the following class registers a Speech service that
      can run on a Macintosh:</para>

      <programlisting>public interface Speech {
  void say(String what) throws Exception;
}

@Component
public class MacSpeech implements Speech {
    ScriptEngine engine = 
        new ScriptEngineManager().getEngineByName("AppleScript");
    
    public void say(String message) throws Exception {
        engine.eval("say \"" + message.replace('"','\'' + "\"");
    }
}</programlisting>

      <para>The previous example would be processed at build time into a
      component description similar to the following XML:</para>

      <programlisting>&lt;scr:component name="com.example.MacSpeech"
  xmlns:scr="http://www.osgi.org/xmlns/scr/v1.5.0"&gt;
  &lt;implementation class="com.acme.impl.MacSpeech"/&gt;
  &lt;service&gt;
    &lt;provide interface="com.acme.service.speech.Speech"/&gt;
  &lt;/service&gt;
&lt;/scr:component&gt;</programlisting>

      <para>It is possible to add activate and deactivate methods on the
      component with the <xref
      linkend="org.osgi.service.component.annotations.Activate"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.component.annotations.Deactivate"
      xrefstyle="hyperlink"/> annotations. If the component wants to be
      updated for changes in the configuration properties then it can also
      indicate the modified method with the <xref
      linkend="org.osgi.service.component.annotations.Modified"
      xrefstyle="hyperlink"/> annotation. For example:</para>

      <programlisting>@Activate
void open(Map&lt;String,?&gt; properties) { ... }

@Deactivate
void close() { ... }

@Modified
void modified(Map&lt;String,?&gt; properties) { ... }</programlisting>

      <para>The <xref
      linkend="org.osgi.service.component.annotations.Activate"
      xrefstyle="hyperlink"/> annotation can also be used on a field or a
      constructor. When used on a field, the field will be set during
      activation of the component. When used on a constructor, the constructor
      will be used to construct the component instances.</para>

      <programlisting>@Activate
ComponentContext context;

@Activate
public MacSpeech(Map&lt;String,?&gt; properties) { ... }</programlisting>

      <para>If a component has dependencies on other services then they can be
      referenced with the <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation that can be applied to a bind method,
      a field, or a constructor parameter. For a bind method, the defaults for
      the <xref linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation are:</para>

      <itemizedlist>
        <listitem>
          <para>The name of the method is used for the name of the
          reference.</para>
        </listitem>

        <listitem>
          <para>1:1 cardinality.</para>
        </listitem>

        <listitem>
          <para>Static reluctant policy.</para>
        </listitem>

        <listitem>
          <para>The requested service is the type of the first parameter of
          the bind method.</para>
        </listitem>

        <listitem>
          <para>It will infer a default unset method and updated method based
          on the name of the bind method.</para>
        </listitem>
      </itemizedlist>

      <para>For example:</para>

      <programlisting>@Reference(cardinality=MULTIPLE, policy=DYNAMIC)
void setLogService( LogService log, Map&lt;String,?&gt; props) { ... }
void unsetLogService( LogService log ) {  ... }
void updatedLogService( Map&lt;String,?&gt; map ) { ...}</programlisting>

      <para>For a field, the defaults for the <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation are:</para>

      <itemizedlist>
        <listitem>
          <para>The name of the field is used for the name of the
          reference.</para>
        </listitem>

        <listitem>
          <para>0..n cardinality if the field is a collection. 0..1
          cardinality if the field is of type Optional. 1:1 cardinality
          otherwise.</para>
        </listitem>

        <listitem>
          <para>Static reluctant policy if the field is not declared volatile.
          Dynamic reluctant policy if the field is declared volatile.</para>
        </listitem>

        <listitem>
          <para>The requested service is the type of the field.</para>
        </listitem>
      </itemizedlist>

      <para>For example:</para>

      <programlisting>@Reference
volatile Collection&lt;LogService&gt; log;</programlisting>

      <para>For a constructor parameter, the defaults for the <xref
      linkend="org.osgi.service.component.annotations.Reference"
      xrefstyle="hyperlink"/> annotation are:</para>

      <itemizedlist>
        <listitem>
          <para>The name of the parameter is used for the name of the
          reference if method parameter names are included in the class file.
          Otherwise, a name for the reference must be generated.</para>
        </listitem>

        <listitem>
          <para>0..n cardinality if the parameter is a collection. 0..1
          cardinality if the parameter is of type Optional. 1:1 cardinality
          otherwise.</para>
        </listitem>

        <listitem>
          <para>Static reluctant policy.</para>
        </listitem>

        <listitem>
          <para>The requested service is the type of the parameter.</para>
        </listitem>
      </itemizedlist>

      <para>For example:</para>

      <programlisting>@Activate
public MacSpeech(@Reference Collection&lt;LogService&gt; log) { ... }</programlisting>
    </section>

    <section xml:id="service.component-component.property.types">
      <title>Component Property Types</title>

      <para>Component properties can be defined and accessed through a user
      defined annotation type, called a <emphasis>component property
      type</emphasis>, containing the property names, property types and
      default values. A component property type allows properties to be
      defined and accessed in a type safe manner. Component property types can
      themselves be annotated with the <xref
      linkend="org.osgi.service.component.annotations.ComponentPropertyType"
      xrefstyle="hyperlink"/> meta-annotation.</para>

      <para>The following example shows the definition of a component property
      type called <code>Config</code> which defines three properties where the
      name of the property is the name of the method, the type of the property
      is the return type of the method and the default value for the property
      is the default value of the method.</para>

      <programlisting>@ComponentPropertyType
public @interface Config {
  boolean enabled() default true;
  String[] names() default {"a", "b"};
  String topic() default "default/topic";
}</programlisting>

      <para>Component property types can be used in two ways:<itemizedlist>
          <listitem>
            <para>Component property types can be used to annotate the
            component implementation class, along side the <xref
            linkend="org.osgi.service.component.annotations.Component"
            xrefstyle="hyperlink"/> annotation. The annotation usage can
            specify property values which can be different than the default
            values declared in the component property type.</para>

            <para>To be used in this way, the component property type must be
            annotated with the <xref
            linkend="org.osgi.service.component.annotations.ComponentPropertyType"
            xrefstyle="hyperlink"/> meta-annotation so that, at build time,
            the annotation is recognized as a component property type.</para>
          </listitem>

          <listitem>
            <para>Component property types can be used as parameter types in
            the component's constructor and life cycle methods, or as field
            types for activation fields. The component implementation can use
            objects of a component property type at runtime to access
            component property values in a type safe manner.</para>

            <para>To be used in this way, it is recommended the component
            property type be annotated with the <xref
            linkend="org.osgi.service.component.annotations.ComponentPropertyType"
            xrefstyle="hyperlink"/> meta-annotation but it is not
            required.</para>
          </listitem>
        </itemizedlist></para>

      <para>Both ways define property names, types and values for the
      component.</para>

      <para>The following example shows the component implementation annotated
      with the example <code>Config</code> component property type which
      specifies a property value for the component which is different than the
      default value. The example also shows the activate method taking the
      example <code>Config</code> component property type as a parameter type
      and the method implementation accesses component property values by
      invoking methods on the component property type object.</para>

      <programlisting>@Component
@Config(names="myapp")
public class MyComponent {
  @Activate
  void activate(Config config) {
    if (config.enabled()) {
      // do something
    }
    for (String name:config.names()) {
      // do something with each name
    }
  }
}</programlisting>

      <para>If a component implementation needs to access component properties
      which are not represented by a component property type, it can use a
      type of Map to receive the properties map in addition to component
      property types. For example:</para>

      <programlisting>@Component
public class MyComponent {
  @Activate
  void activate(Config config, Map&lt;String, ?&gt; allProperties) {
    if (config.enabled()) {
      // do something
    }
    if (allProperties.get("other.prop") != null) {
      // do something
    }
  }
}</programlisting>

      <para>Component property types must be defined as annotation types. This
      is done for several reasons. First, the limitations on annotation type
      definitions make them well suited for component property types. The
      methods must have no parameters and the return types supported are
      limited to a set which is well suited for component properties. Second,
      annotation types support default values which is useful for defining the
      default value of a component property. Finally, as annotations, they can
      be used to annotate component implementation classes.</para>

      <para>At build time, the component property types must be processed to
      potentially generate <code>property</code> elements in the component
      description. See <xref
      linkend="service.component-ordering.generated.properties"/>.</para>

      <para>At runtime, when SCR needs to provide a component instance an
      activation object whose type is a component property type, SCR must
      construct an instance of the component property type whose methods are
      backed by the values of the component properties for the component
      instance. This object can then be used to obtain the property values in
      a type safe manner.</para>

      <section xml:id="service.component-component.property.mapping">
        <title>Component Property Mapping</title>

        <para>Each method of a configuration property type is mapped to a
        component property. The property name is derived from the method name.
        Certain common property name characters, such as full stop (<code>'.'
        \u002E</code>) and hyphen-minus (<code>'-' \u002D</code>) are not
        valid in Java identifiers. So the name of a method must be converted
        to its corresponding property name as follows:<itemizedlist>
            <listitem>
              <para>A single dollar sign (<code>'$' \u0024</code>) is removed
              unless it is followed by:<itemizedlist>
                  <listitem>
                    <para>A low line (<code>'_' \u005F</code>) and a dollar
                    sign in which case the three consecutive characters
                    (<code>"$_$"</code>) are converted to a single
                    hyphen-minus (<code>'-' \u002D</code>).</para>
                  </listitem>

                  <listitem>
                    <para>Another dollar sign in which case the two
                    consecutive dollar signs (<code>"$$"</code>) are converted
                    to a single dollar sign.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <para>A single low line (<code>'_' \u005F</code>) is converted
              into a full stop (<code>'.' \u002E</code>) unless is it followed
              by another low line in which case the two consecutive low lines
              (<code>"__"</code>) are converted to a single low line.</para>
            </listitem>

            <listitem>
              <para>All other characters are unchanged.</para>
            </listitem>

            <listitem>
              <para>If the component property type declares a
              <code>PREFIX_</code> field whose value is a compile-time
              constant String, then the property name is prefixed with the
              value of the <code>PREFIX_</code> field.</para>
            </listitem>
          </itemizedlist></para>

        <para><xref
        linkend="service.component-component.property.name.mapping"/> contains
        some name mapping examples.</para>

        <table xml:id="service.component-component.property.name.mapping">
          <title>Component Property Name Mapping Examples</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="1*"/>

            <colspec colnum="2" colwidth="1*"/>

            <thead>
              <row>
                <entry>Component Property Type Method Name</entry>

                <entry>Component Property Name</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>myProperty143</code></entry>

                <entry><code>myProperty143</code></entry>
              </row>

              <row>
                <entry><code>$new</code></entry>

                <entry><code>new</code></entry>
              </row>

              <row>
                <entry><code>my$$prop</code></entry>

                <entry><code>my$prop</code></entry>
              </row>

              <row>
                <entry><code>dot_prop</code></entry>

                <entry><code>dot.prop</code></entry>
              </row>

              <row>
                <entry><code>_secret</code></entry>

                <entry><code>.secret</code></entry>
              </row>

              <row>
                <entry><code>another__prop</code></entry>

                <entry><code>another_prop</code></entry>
              </row>

              <row>
                <entry><code>three___prop</code></entry>

                <entry><code>three_.prop</code></entry>
              </row>

              <row>
                <entry><code>four_$__prop</code></entry>

                <entry><code>four._prop</code></entry>
              </row>

              <row>
                <entry><code>five_$_prop</code></entry>

                <entry><code>five..prop</code></entry>
              </row>

              <row>
                <entry><code>six$_$prop</code></entry>

                <entry><code>six-prop</code></entry>
              </row>

              <row>
                <entry><code>seven$$_$prop</code></entry>

                <entry><code>seven$.prop</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>However, if the component property type is a
        <emphasis>single-element annotation</emphasis>, see 9.7.3 in <xref
        linkend="service.component-jls.ref"/>, then the property name for the
        <code>value</code> method is derived from the name of the component
        property type rather than the name of the method.</para>

        <para>In this case, the simple name of the component property type,
        that is, the name of the class without any package name or outer class
        name, if the component property type is an inner class, must be
        converted to the property name as follows:<itemizedlist>
            <listitem>
              <para>When a lower case character is followed by an upper case
              character, a full stop (<code>'.' \u002E</code>) is inserted
              between them.</para>
            </listitem>

            <listitem>
              <para>Each upper case character is converted to lower
              case.</para>
            </listitem>

            <listitem>
              <para>All other characters are unchanged.</para>
            </listitem>

            <listitem>
              <para>If the component property type declares a
              <code>PREFIX_</code> field whose value is a compile-time
              constant String, then the property name is prefixed with the
              value of the <code>PREFIX_</code> field.</para>
            </listitem>
          </itemizedlist></para>

        <para><xref linkend="service.component-single.element.name.mapping"/>
        contains some mapping examples for the <code>value</code>
        method.</para>

        <table xml:id="service.component-single.element.name.mapping">
          <title>Single-Element Annotation Mapping Examples for
          <code>value</code> Method</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="1*"/>

            <colspec colnum="2" colwidth="1*"/>

            <thead>
              <row>
                <entry>Component Property Type Name</entry>

                <entry><code>value</code> Method Component Property
                Name</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>ServiceRanking</code></entry>

                <entry><code>service.ranking</code></entry>
              </row>

              <row>
                <entry><code>Some_Name</code></entry>

                <entry><code>some_name</code></entry>
              </row>

              <row>
                <entry><code>OSGiProperty</code></entry>

                <entry><code>osgi.property</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>If the component property type is a <emphasis>marker
        annotation</emphasis>, see 9.7.2 in <xref
        linkend="service.component-jls.ref"/>, then the property name is
        derived from the name of the component property type, as is described
        above for single-element annotations, and the value of the property is
        <code>Boolean.TRUE</code>. Marker annotations can be used to annotate
        component implementation classes to set a component property to the
        value <code>Boolean.TRUE</code>. However, since marker annotations
        have no methods, they are of no use as parameter types in the
        component's constructor and life cycle methods, or as field types for
        activation fields.</para>

        <para>The property type can be directly derived from the type of the
        method. All types supported for annotation elements can be used except
        for annotation types. Method types of an annotation type or array
        thereof are not supported. A tool processing the component property
        types must ignore such methods.</para>

        <para>If the method type is <code>Class</code> or
        <code>Class[]</code>, then the property type must be
        <code>String</code> or <code>String[]</code>, respectively, whose
        values are fully qualified class names in the form returned by the
        <code>Class.getName()</code> method.</para>

        <para>If the method type is an enumeration type or an array thereof,
        then the property type must be <code>String</code> or
        <code>String[]</code>, respectively, whose values are the names of the
        enum constants in the form returned by the <code>Enum.name()</code>
        method.</para>
      </section>

      <section xml:id="service.component-component.property.value.coercion">
        <title>Coercing Component Property Values</title>

        <para>When a component property type is used as an activation object
        type, SCR must create an object that implements the component property
        type and maps the methods of the component property type to component
        properties. The name of the method is converted to the property name
        as described in <xref
        linkend="service.component-component.property.mapping"/>. The property
        value may need to be coerced to the type of the method. In <xref
        linkend="service.component-coercion.table"/>, the columns are source
        types, that is, the type of the component property value, and the rows
        are target types, that is, the method types. The property value is
        <emphasis>v</emphasis>; <emphasis>number</emphasis> is a primitive
        numerical type and <emphasis>Number</emphasis> is a wrapper numerical
        type. An invalid coercion is represented by <code>throw</code>. Such a
        coercion attempt must result in throwing a Component Exception when
        the component property type method is called. Any other coercion
        error, such as parsing a non-numerical string to a number or the
        inability to coerce a string into a Class or enum object, must be
        wrapped in a Component Exception and thrown when the component
        property type method is called.</para>

        <table pgwide="1" rowheader="firstcol"
               xml:id="service.component-coercion.table">
          <title>Coercion From Property Value to Method Type</title>

          <tgroup cols="6">
            <colspec colname="col1" colnum="1" colwidth="1*"/>

            <colspec colname="col2" colnum="2" colwidth="1*"/>

            <colspec colname="col3" colnum="3" colwidth="1*"/>

            <colspec colname="col4" colnum="4" colwidth="1*"/>

            <colspec colname="col5" colnum="5" colwidth="1*"/>

            <colspec colname="col6" colnum="6" colwidth="2*"/>

            <thead>
              <row>
                <entry><subscript>target</subscript> \
                <superscript>source</superscript></entry>

                <entry>String</entry>

                <entry>Boolean</entry>

                <entry>Character</entry>

                <entry><emphasis>Number</emphasis></entry>

                <entry>Collection/array</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>String</entry>

                <entry><emphasis>v</emphasis></entry>

                <entry><emphasis>v</emphasis>. toString()</entry>

                <entry><emphasis>v</emphasis>. toString()</entry>

                <entry><emphasis>v</emphasis>. toString()</entry>

                <entry>If <emphasis>v</emphasis> has no elements,
                <code>null</code>; otherwise the first element of
                <emphasis>v</emphasis> is coerced.</entry>
              </row>

              <row>
                <entry>boolean</entry>

                <entry>Boolean. parseBoolean( <emphasis>v</emphasis> )</entry>

                <entry><emphasis>v</emphasis>. booleanValue()</entry>

                <entry><emphasis>v</emphasis>. charValue() != 0</entry>

                <entry><emphasis>v</emphasis>. doubleValue() != 0</entry>

                <entry>If <emphasis>v</emphasis> has no elements,
                <code>false</code>; otherwise the first element of
                <emphasis>v</emphasis> is coerced.</entry>
              </row>

              <row>
                <entry>char</entry>

                <entry><emphasis>v</emphasis>. length() &gt; 0 ?
                <emphasis>v</emphasis>. charAt(0) : 0</entry>

                <entry><emphasis>v</emphasis>. booleanValue() ? 1 : 0</entry>

                <entry><emphasis>v</emphasis>. charValue()</entry>

                <entry>(char) <emphasis>v</emphasis>. intValue()</entry>

                <entry>If <emphasis>v</emphasis> has no elements, 0; otherwise
                the first element of <emphasis>v</emphasis> is
                coerced.</entry>
              </row>

              <row>
                <entry><emphasis>number</emphasis></entry>

                <entry><emphasis>Number</emphasis>.
                parse<emphasis>Number</emphasis>( <emphasis>v</emphasis>
                )</entry>

                <entry><emphasis>v</emphasis>. booleanValue() ? 1 : 0</entry>

                <entry>(<emphasis>number</emphasis>) <emphasis>v</emphasis>.
                charValue()</entry>

                <entry><emphasis>v</emphasis>.
                <emphasis>number</emphasis>Value()</entry>

                <entry>If <emphasis>v</emphasis> has no elements, 0; otherwise
                the first element of <emphasis>v</emphasis> is
                coerced.</entry>
              </row>

              <row>
                <entry>Class</entry>

                <entry>Bundle. loadClass( <emphasis>v</emphasis> )</entry>

                <entry><code>throw</code></entry>

                <entry><code>throw</code></entry>

                <entry><code>throw</code></entry>

                <entry>If <emphasis>v</emphasis> has no elements,
                <code>null</code>; otherwise the first element of
                <emphasis>v</emphasis> is coerced.</entry>
              </row>

              <row>
                <entry><emphasis>EnumType</emphasis></entry>

                <entry><emphasis>EnumType</emphasis>. valueOf(
                <emphasis>v</emphasis> )</entry>

                <entry><code>throw</code></entry>

                <entry><code>throw</code></entry>

                <entry><code>throw</code></entry>

                <entry>If <emphasis>v</emphasis> has no elements,
                <code>null</code>; otherwise the first element of
                <emphasis>v</emphasis> is coerced.</entry>
              </row>

              <row>
                <entry>annotation type</entry>

                <entry><code>throw</code></entry>

                <entry><code>throw</code></entry>

                <entry><code>throw</code></entry>

                <entry><code>throw</code></entry>

                <entry><code>throw</code></entry>
              </row>

              <row>
                <entry>array</entry>

                <entry nameend="col5" namest="col2">A single element array is
                created and <emphasis>v</emphasis> is coerced into the single
                element of the new array.</entry>

                <entry colname="col6">An array the size of
                <emphasis>v</emphasis> is created and each element of
                <emphasis>v</emphasis> is coerced into the corresponding
                element of the new array.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Component properties whose names do not map to component
        property type methods are ignored. If there is no corresponding
        component property for a component property type method, the component
        property type method must:</para>

        <itemizedlist>
          <listitem>
            <para>Return 0 for numerical and char method types.</para>
          </listitem>

          <listitem>
            <para>Return <code>false</code> for boolean method type.</para>
          </listitem>

          <listitem>
            <para>Return <code>null</code> for String, Class, and enum.</para>
          </listitem>

          <listitem>
            <para>Return an empty array for array method types.</para>
          </listitem>

          <listitem>
            <para>Throw a ComponentException for annotation method
            types.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section xml:id="service.component-standard.component.property.types">
        <title>Standard Component Property Types</title>

        <para>Component property types for standard component properties are
        specified in the <xref
        linkend="org.osgi.service.component.propertytypes"
        xrefstyle="hyperlink"/> package.</para>

        <para>The <xref
        linkend="org.osgi.service.component.propertytypes.ServiceDescription"
        xrefstyle="hyperlink"/> component property type can be used to add the
        <code>service.description</code> service property to a component. The
        <xref
        linkend="org.osgi.service.component.propertytypes.ServiceRanking"
        xrefstyle="hyperlink"/> component property type can be used to add the
        <code>service.ranking</code> service property to a component. The
        <xref linkend="org.osgi.service.component.propertytypes.ServiceVendor"
        xrefstyle="hyperlink"/> component property type can be used to add the
        <code>service.vendor</code> service property to a component. For
        example, using these component property types as annotations:</para>

        <programlisting>@Component
@ServiceDescription(”My Acme Service implementation”)
@ServiceRanking(100)
@ServiceVendor("My Corp")
public class MyComponent implements AcmeService {}</programlisting>

        <para>will result in the following component properties:</para>

        <programlisting>&lt;property name=”service.description” value=”My Acme Service implementation”/&gt;
&lt;property name=”service.ranking” type=”Integer” value=”100”/&gt;
&lt;property name=”service.vendor” value=”My Corp”/&gt;</programlisting>

        <para>The <xref
        linkend="org.osgi.service.component.propertytypes.ExportedService"
        xrefstyle="hyperlink"/> component property type can be used to specify
        service properties for remote services.</para>

        <para>The <xref
        linkend="org.osgi.service.component.propertytypes.SatisfyingConditionTarget"
        xrefstyle="hyperlink"/> component property type can be used to specify
        the target property for a reference to the satisfying condition of a
        component configuration. See <xref
        linkend="service.component-satisfying.condition"/>.</para>
      </section>
    </section>

    <section xml:id="service.component-ordering.generated.properties">
      <title>Ordering of Generated Component Properties</title>

      <para>The <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> annotation contains two ways to define component
      properties via the <xref
      linkend="org.osgi.service.component.annotations.Component.property--"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.component.annotations.Component.properties--"
      xrefstyle="hyperlink"/> elements. See <xref
      linkend="service.component-property.properties.elements"/>. If Component
      Annotations are used to describe the component, then any component
      property types used as the type of an activation object or used to
      annotate the component implementation class must also be processed since
      component property types can be used to define component property values
      as well. See <xref
      linkend="service.component-component.property.types"/>. A tool
      processing the Component Annotations and the component property types
      must write the defined component properties into the generated component
      description in the following order.</para>

      <orderedlist>
        <listitem>
          <para>Properties defined through component property types used as
          the type of an activation object.</para>

          <para>If any of the referenced component property types have methods
          with defaults, then the generated component description must include
          a <code>property</code> element for each such method with the
          property name mapped from the method name, the property type mapped
          from the method type, and the property value set to the method's
          default value. See <xref
          linkend="service.component-component.property.mapping"/>. The
          generated <code>property</code> elements must be added to the
          component description by processing the component property types
          used as the type of an activation object in the following
          order:</para>

          <orderedlist>
            <listitem>
              <para>The component property types used as parameters to the
              constructor.</para>
            </listitem>

            <listitem>
              <para>The component property types used as activation fields.
              The fields are processed in lexicographical order, using
              <code>String.compareTo</code>, of the field names.</para>
            </listitem>

            <listitem>
              <para>The component property types used as parameters to the
              activate method.</para>
            </listitem>

            <listitem>
              <para>The component property types used as parameters to the
              modified method.</para>
            </listitem>

            <listitem>
              <para>The component property types used as parameters to the
              deactivate method.</para>
            </listitem>
          </orderedlist>

          <para>If a method has more than one component property type
          parameter, the component property types are processed in the order
          of the method parameters.</para>

          <para>For component property type methods without a default value or
          with a default value of an empty array, a <code>property</code>
          element must not be generated.</para>
        </listitem>

        <listitem>
          <para>Properties defined through component property types annotating
          the component implementation class.</para>

          <para>The generated component description must include a
          <code>property</code> element for each such method with the property
          name mapped from the method name, the property type mapped from the
          method type, and the property value set to the method's value. See
          <xref linkend="service.component-component.property.mapping"/>. The
          generated <code>property</code> elements must be added to the
          component description by processing the component property types
          annotating the component implementation class in the order that the
          annotations appear in the component implementation's class file.
          However, the order of the <code>RuntimeVisibleAnnotations</code> and
          <code>RuntimeInvisibleAnnotations</code> attributes in the class
          file is unspecified by <xref linkend="service.component-jvms.ref"/>
          so care must be taken when using component property types of
          different <code>RetentionPolicy</code> that have method names in
          common.</para>

          <para>For component property type methods with a value of an empty
          array, a <code>property</code> element must not be generated.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.annotations.Component.property--"
          xrefstyle="hyperlink"/> element of the <xref
          linkend="org.osgi.service.component.annotations.Component"
          xrefstyle="hyperlink"/> annotation.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.component.annotations.Component.properties--"
          xrefstyle="hyperlink"/> element of the <xref
          linkend="org.osgi.service.component.annotations.Component"
          xrefstyle="hyperlink"/> annotation.</para>
        </listitem>
      </orderedlist>

      <para>This means that the properties defined through component property
      types are declared first in the generated component description,
      followed by all properties defined through the <xref
      linkend="org.osgi.service.component.annotations.Component.property--"
      xrefstyle="hyperlink"/> element of the <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> annotation and finally the properties entries
      defined through the <xref
      linkend="org.osgi.service.component.annotations.Component.properties--"
      xrefstyle="hyperlink"/> element of the <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> annotation.</para>

      <para>Since property values defined later in the component description
      override property values defined earlier in the component description,
      this means that property values defined in <xref
      linkend="org.osgi.service.component.annotations.Component.properties--"
      xrefstyle="hyperlink"/> element of the <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> annotation can override property values defined
      in <xref
      linkend="org.osgi.service.component.annotations.Component.property--"
      xrefstyle="hyperlink"/> element of the <xref
      linkend="org.osgi.service.component.annotations.Component"
      xrefstyle="hyperlink"/> annotation which can override values defined by
      values in the component property types.</para>
    </section>
  </section>

  <section xml:id="service.component-service.component.runtime">
    <title>Service Component Runtime</title>

    <para>Service Component Runtime (SCR) is the actor that manages the
    components and their life cycle and allows introspection of the
    components.</para>

    <section xml:id="service.component-relationship.framework">
      <title>Relationship to OSGi Framework</title>

      <para>SCR must have access to the Bundle Context of any bundle that
      contains a component. SCR needs access to the Bundle Context for the
      following reasons:</para>

      <itemizedlist>
        <listitem>
          <para>To be able to register and get services on behalf of a bundle
          with components.</para>
        </listitem>

        <listitem>
          <para>To interact with the Configuration Admin on behalf of a bundle
          with components.</para>
        </listitem>

        <listitem>
          <para>To provide a component its Bundle Context when the Component
          Context <code>getBundleContext</code> method is called.</para>
        </listitem>
      </itemizedlist>

      <para>SCR should use the <code>Bundle.getBundleContext()</code> method
      to obtain the Bundle Context reference.</para>
    </section>

    <section>
      <title>Starting and Stopping SCR</title>

      <para>When SCR is implemented as a bundle, any component configurations
      activated by SCR must be deactivated when the SCR bundle is stopped.
      When the SCR bundle is started, it must process any components that are
      declared in bundles that are started. This includes bundles which are
      started and are awaiting lazy activation.</para>
    </section>

    <section>
      <title>Logging Messages</title>

      <para>When SCR must log a message to the Log Service, it must use a
      Logger named for the component implementation class and associated with
      the bundle declaring the component. To obtain the Logger object, SCR
      must call the <code>LoggerFactory.getLogger(Bundle bundle, String name,
      Class loggerType)</code> method passing the bundle declaring the
      component as the first argument and the fully qualified name of the
      component implementation class as the second argument. If SCR cannot
      know the component implementation class name, because the error is not
      associated with a component or the error occurred before the component
      description is processed, then SCR must use the bundle's Root Logger,
      that is, the Logger named <code>ROOT</code>.</para>
    </section>

    <section xml:id="service.component-locating.members">
      <title>Locating Component Methods and Fields</title>

      <para>SCR will need to locate activate, deactivate, modified, bind,
      updated, and unbind methods as well as fields in a component instance.
      These members will be located, and called or modified, using reflection.
      The declared members of each class in the component implementation
      class's hierarchy are examined for a suitable member. If a suitable
      member is found in a class, and it is accessible to the component
      implementation class, then that member must be used. If suitable members
      are found in a class but none of the suitable members are accessible by
      the component implementation class, then the search for suitable members
      terminates with no suitable member having been located. If no suitable
      members are found in a class, the search continues in the
      superclass.</para>

      <para>Only members that are accessible to the component implementation
      class will be used. If the member has the <code>public</code> or
      <code>protected</code> access modifier, then access is permitted.
      Otherwise, if the member has the <code>private</code> access modifier,
      then access is permitted only if the member is declared in the component
      implementation class. Otherwise, if the member has default access, also
      known as package private access, then access is permitted only if the
      member is declared in the component implementation class or if the
      member is declared in a superclass and all classes in the hierarchy from
      the component implementation class to the superclass, inclusive, are in
      the same package and loaded by the same class loader.</para>

      <para>It is recommended that these members should not be declared with
      the <code>public</code> access modifier so that they do not appear as
      public members on the component instance when it is used as a service
      object. Having these members declared <code>public</code> allows any
      code to call or access the members with reflection, even if a Security
      Manager is installed. These members are generally intended to only be
      called or modified by SCR.</para>
    </section>

    <section>
      <title>Bundle Activator Interaction</title>

      <para>A bundle containing components may also declare a Bundle
      Activator. Such a bundle may also be marked for lazy activation. Since
      components are activated by SCR and Bundle Activators are called by the
      OSGi Framework, a bundle using both components and a Bundle Activator
      must take care. The Bundle Activator's start method must not rely upon
      SCR having activated any of the bundle's components. However, the
      components can rely upon the Bundle Activator's start method having been
      called. That is, there is a <emphasis>happens-before</emphasis>
      relationship between the Bundle Activator's start method being run and
      the components being activated.</para>
    </section>

    <section xml:id="service.component-introspection">
      <title>Introspection</title>

      <para>SCR provides an introspection API for examining the runtime state
      of the components in bundles processed by SCR. SCR must register a <xref
      linkend="org.osgi.service.component.runtime.ServiceComponentRuntime"
      xrefstyle="hyperlink"/> service upon startup. The Service Component
      Runtime service provides methods to inspect the component descriptions
      and component configurations as well as inspect and modify the enabled
      state of components. The service uses <emphasis>Data Transfer Objects
      (DTO)</emphasis> as parameters and return values. The rules for Data
      Transfer Objects are specified in <xref linkend="intro.core.release"
      xrefstyle="template:%t"/>.</para>

      <para>The Service Component Runtime service provides the following
      methods.</para>

      <para><itemizedlist>
          <listitem>
            <para><xref
            linkend="org.osgi.service.component.runtime.ServiceComponentRuntime.getComponentDescriptionDTOs-Bundle...-"
            xrefstyle="hyperlink"/> - For each specified bundle, if the bundle
            is active and processed by SCR, the returned collection will
            contain a <xref
            linkend="org.osgi.service.component.runtime.dto.ComponentDescriptionDTO"
            xrefstyle="hyperlink"/> for each valid component description in
            the bundle.</para>
          </listitem>

          <listitem>
            <para><xref
            linkend="org.osgi.service.component.runtime.ServiceComponentRuntime.getComponentDescriptionDTO-Bundle-String-"
            xrefstyle="hyperlink"/> - If the specified bundle is active and
            processed by SCR, and the specified bundle contains a valid
            component description with the specified name, the method will
            return a <xref
            linkend="org.osgi.service.component.runtime.dto.ComponentDescriptionDTO"
            xrefstyle="hyperlink"/> for the component description.</para>
          </listitem>

          <listitem>
            <para><xref
            linkend="org.osgi.service.component.runtime.ServiceComponentRuntime.getComponentConfigurationDTOs-ComponentDescriptionDTO-"
            xrefstyle="hyperlink"/> - If the specified <xref
            linkend="org.osgi.service.component.runtime.dto.ComponentDescriptionDTO"
            xrefstyle="hyperlink"/> represents a valid component description
            from an active bundle processed by SCR, the returned collection
            will contain a <xref
            linkend="org.osgi.service.component.runtime.dto.ComponentConfigurationDTO"
            xrefstyle="hyperlink"/> for each component configuration of the
            component.</para>
          </listitem>

          <listitem>
            <para><xref
            linkend="org.osgi.service.component.runtime.ServiceComponentRuntime.isComponentEnabled-ComponentDescriptionDTO-"
            xrefstyle="hyperlink"/> - Returns <code>true</code> if the
            specified Component Description DTO represents a valid component
            description from an active bundle processed by SCR, and the
            component is enabled. Otherwise, the method returns
            <code>false</code>.</para>
          </listitem>

          <listitem>
            <para><xref
            linkend="org.osgi.service.component.runtime.ServiceComponentRuntime.enableComponent-ComponentDescriptionDTO-"
            xrefstyle="hyperlink"/> - If the specified Component Description
            DTO represents a valid component description from an active bundle
            processed by SCR, the component is enabled. This method must
            return after changing the enabled state of the specified
            component. Any actions that result from this, such as activating
            or deactivating a component configuration, must occur
            asynchronously to this method call. The method returns a <xref
            linkend="org.osgi.util.promise.Promise" xrefstyle="hyperlink"/>
            that will be resolved when the actions that result from changing
            the enabled state of the specified component have
            completed.</para>
          </listitem>

          <listitem>
            <para><xref
            linkend="org.osgi.service.component.runtime.ServiceComponentRuntime.disableComponent-ComponentDescriptionDTO-"
            xrefstyle="hyperlink"/> - If the specified Component Description
            DTO represents a valid component description from an active bundle
            processed by SCR, the component is disabled. This method must
            return after changing the enabled state of the specified
            component. Any actions that result from this, such as activating
            or deactivating a component configuration, must occur
            asynchronously to this method call. The method returns a <xref
            linkend="org.osgi.util.promise.Promise" xrefstyle="hyperlink"/>
            that will be resolved when the actions that result from changing
            the enabled state of the specified component have
            completed.</para>
          </listitem>
        </itemizedlist></para>

      <para>The runtime state of the components can change at any time. So any
      information returned by these methods only provides a snapshot of the
      state at the time of the method call.</para>

      <para>There are a number of DTOs available via the Service Component
      Runtime service.</para>

      <figure>
        <title>Service Component Runtime DTOs</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="3.500in"
                       contentwidth="7.000in" fileref="dto-structure.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The two main DTOs are <xref
      linkend="org.osgi.service.component.runtime.dto.ComponentDescriptionDTO"
      xrefstyle="hyperlink"/>, which represents a component description, and
      <xref
      linkend="org.osgi.service.component.runtime.dto.ComponentConfigurationDTO"
      xrefstyle="hyperlink"/>, which represents a component configuration. The
      Component Description DTO contains an array of <xref
      linkend="org.osgi.service.component.runtime.dto.ReferenceDTO"
      xrefstyle="hyperlink"/> objects which represent each declared reference
      in the component description. The Component Configuration DTO contains
      an array of <xref
      linkend="org.osgi.service.component.runtime.dto.SatisfiedReferenceDTO"
      xrefstyle="hyperlink"/> objects and an array of <xref
      linkend="org.osgi.service.component.runtime.dto.UnsatisfiedReferenceDTO"
      xrefstyle="hyperlink"/> objects. A Satisfied Reference DTO represents a
      satisfied reference of the component configuration and an Unsatisfied
      Reference DTO represents an unsatisfied reference of the component
      configuration. The Component Configuration DTO for a satisfied component
      configuration must contain no Unsatisfied Reference DTOs. The Component
      Configuration DTO for an unsatisfied component configuration may contain
      some Satisfied Reference DTOs and some Unsatisfied Reference DTOs. This
      information can be used to diagnose why the component configuration is
      not satisfied.</para>

      <para>SCR must register the <xref
      linkend="org.osgi.service.component.runtime.ServiceComponentRuntime"
      xrefstyle="hyperlink"/> service with the
      <code>service.changecount</code> service property. See
      <code>org.osgi.framework.Constants.SERVICE_CHANGECOUNT</code> in <xref
      linkend="intro.core.release" xrefstyle="template:%t"/>. Whenever the
      Service Component Runtime DTOs available from the <xref
      linkend="org.osgi.service.component.runtime.ServiceComponentRuntime"
      xrefstyle="hyperlink"/> service change, SCR modify the
      <code>service.changecount</code> service property with an updated change
      count value. This allows interested parties to be notified of changes to
      the DTOs by observing Service Events of type <code>MODIFIED</code> for
      the <xref
      linkend="org.osgi.service.component.runtime.ServiceComponentRuntime"
      xrefstyle="hyperlink"/> service.</para>
    </section>

    <section xml:id="service.component-capabilities">
      <title>Capabilities</title>

      <para>SCR must provide the following capabilities.</para>

      <itemizedlist>
        <listitem>
          <para>A capability in the <link
          linkend="service.namespaces-osgi.extender.namespace"><code>osgi.extender</code></link>
          namespace declaring an extender with the name <xref
          linkend="org.osgi.service.component.ComponentConstants.COMPONENT_CAPABILITY_NAME"
          xrefstyle="hyperlink"/>. This capability must also declare a uses
          constraint for the <code>org.osgi.service.component</code> package.
          For example:</para>

          <programlisting>Provide-Capability: osgi.extender;
    osgi.extender="osgi.component";
    version:Version="<xref endterm="org.osgi.service.component-version.number"
              linkend="org.osgi.service.component"/>";
    uses:="org.osgi.service.component"</programlisting>

          <para>This capability must follow the rules defined for the <xref
          linkend="service.namespaces-osgi.extender.namespace"/>.</para>

          <para>A bundle that contains service components should require the
          <code>osgi.extender</code> capability from SCR. This requirement
          will wire the bundle to the SCR implementation and ensure that SCR
          is using the same <code>org.osgi.service.component</code> package as
          the bundle if the bundle uses that package.</para>

          <programlisting>Require-Capability: osgi.extender;
  filter:="(&amp;(osgi.extender=osgi.component)(version&gt;=<xref
              endterm="org.osgi.service.component-version.number"
              linkend="org.osgi.service.component"/>)(!(version&gt;=2.0)))"</programlisting>

          <para>The <xref
          linkend="org.osgi.service.component.annotations.RequireServiceComponentRuntime"
          xrefstyle="hyperlink"/> annotation can be used to require this
          capability. The <xref
          linkend="org.osgi.service.component.annotations.Component"
          xrefstyle="hyperlink"/> annotation is meta-annotated with this
          annotation.</para>

          <para>SCR must only process a bundle's service components if one of
          the following is true:</para>

          <itemizedlist>
            <listitem>
              <para>The bundle's wiring has a required wire for at least one
              <code>osgi.extender</code> capability with the name
              <code>osgi.component</code> and the first of these required
              wires is wired to SCR.</para>
            </listitem>

            <listitem>
              <para>The bundle's wiring has no required wire for an
              <code>osgi.extender</code> capability with the name
              <code>osgi.component</code>.</para>
            </listitem>
          </itemizedlist>

          <para>Otherwise, SCR must not process the bundle's service
          components.</para>
        </listitem>

        <listitem>
          <para>A capability in the <link
          linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
          namespace representing the <xref
          linkend="org.osgi.service.component.runtime.ServiceComponentRuntime"
          xrefstyle="hyperlink"/> service. This capability must also declare a
          uses constraint for the
          <code>org.osgi.service.component.runtime</code> package. For
          example:</para>

          <programlisting>Provide-Capability: osgi.service;
    objectClass:List&lt;String&gt;=
      "org.osgi.service.component.runtime.ServiceComponentRuntime";
    uses:="org.osgi.service.component.runtime"</programlisting>

          <para>This capability must follow the rules defined for the <xref
          linkend="service.namespaces-osgi.service.namespace"/>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="service.component-locating.true.condition">
      <title>Locating the True Condition Service</title>

      <para>SCR must locate the True Condition service. This can be done using
      the Bundle Context of SCR itself. However, if SCR is unable to locate
      the True Condition service using the Bundle Context of SCR itself, it
      may retry using the Bundle Context of the system bundle. This retry to
      locate the True Condition service can succeed when a service hook
      implementation is in use that has not been updated to support the
      Condition Service Specification by providing visibility of the True
      Condition service to all bundles.</para>

      <para>If SCR is unable to locate the True Condition service, which can
      occur if SCR is running on an older OSGi Framework which does not
      support the Condition Service Specification and register the True
      Condition service, then SCR must not augment component descriptions to
      add the implicit reference for a satisfying condition. See <xref
      linkend="service.component-satisfying.condition"/>.</para>

      <para>SCR may use the already located True Condition service to satisfy
      any component configuration's reference to the True Condition
      service.</para>
    </section>
  </section>

  <section>
    <title>Security</title>

    <para>When Java permissions are enabled, SCR must perform the following
    security procedures.</para>

    <section>
      <title>Service Permissions</title>

      <para>Declarative services are built upon the existing OSGi service
      infrastructure. This means that Service Permission applies regarding the
      ability to publish, find or bind services.</para>

      <para>If a component specifies a service, then component configurations
      for the component cannot be satisfied unless the component's bundle has
      <code>ServicePermission[&lt;provides&gt;, REGISTER]</code> for each
      provided interface specified for the service.</para>

      <para>If a component's reference does not specify optional cardinality,
      the reference cannot be satisfied unless the component's bundle has
      <code>ServicePermission[&lt;interface&gt;, GET]</code> for the specified
      interface in the reference. If the reference specifies optional
      cardinality but the component's bundle does not have
      <code>ServicePermission[&lt;interface&gt;, GET]</code> for the specified
      interface in the reference, no service must be bound for this
      reference.</para>

      <para>If a component is a factory component, then the above Service
      Permission checks still apply. But the component's bundle is not
      required to have <code>ServicePermission[ComponentFactory,
      REGISTER]</code> as the Component Factory service is registered by
      SCR.</para>

      <para>SCR must have <code>ServicePermission[ServiceComponentRuntime,
      REGISTER]</code> permission to register the <xref
      linkend="org.osgi.service.component.runtime.ServiceComponentRuntime"
      xrefstyle="hyperlink"/> service. Administrative bundles wishing to use
      the <xref
      linkend="org.osgi.service.component.runtime.ServiceComponentRuntime"
      xrefstyle="hyperlink"/> service must have
      <code>ServicePermission[ServiceComponentRuntime, GET]</code> permission.
      In general, this permission should only be granted to administrative
      bundles to limit access to the potentially intrusive methods provided by
      this service.</para>
    </section>

    <section>
      <title>Required Admin Permission</title>

      <para>SCR requires <code>AdminPermission[*,CONTEXT]</code> because it
      needs access to the bundle's Bundle Context object with the
      <code>Bundle.getBundleContext()</code> method.</para>
    </section>

    <section>
      <title>Using hasPermission</title>

      <para>SCR does all publishing, finding and binding of services on behalf
      of the component using the Bundle Context of the component's bundle.
      This means that normal stack-based permission checks will check SCR and
      not the component's bundle. Since SCR is registering and getting
      services on behalf of a component's bundle, SCR must call the
      <code>Bundle.hasPermission</code> method to validate that a component's
      bundle has the necessary permission to register or get a service.</para>
    </section>

    <section xml:id="service.component-multi.location.regions">
      <title>Configuration Multi-Locations and Regions</title>

      <para>SCR must ensure a bundle has the proper
      <code>ConfigurationPermission</code> for a Configuration used by its
      components when the Configuration has a multi-location. See <xref
      linkend="service.cm-multi.locations"/> for more information on
      multi-locations and <xref linkend="service.cm-regions"/> for more
      information on regions. If a bundle does not have the necessary
      permission for a multi-location Configuration, then SCR must act as if
      the Configuration does not exist for the bundle.</para>
    </section>
  </section>

  <section xml:id="service.component-schema">
    <title>Component Description Schema</title>

    <para>This XML Schema defines the component description grammar.</para>

    <programlisting role="pgwide"><xi:include encoding="utf-8"
        href="../../generated/xmlns/scr/v1.5.0/scr.xsd" parse="text"/></programlisting>

    <para>SCR must not require component descriptions to specify the elements
    in the order required by the schema. SCR must allow other orderings since
    arbitrary orderings of these elements do not affect the meaning of the
    component description. Only the relative ordering of
    <code>property</code>, <code>properties</code> and <code>reference</code>
    elements have meaning for overriding previously set property
    values.</para>

    <para>The schema is also available in digital form from <xref
    linkend="i1655737"/>.</para>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.component.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.component.annotations.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.component.runtime.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.component.runtime.dto.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.component.propertytypes.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i1550732"><title>Automating Service Dependency
      Management in a Service-Oriented Component Model</title>Humberto
      Cervantes, Richard S. Hall, Proceedings of the Sixth Component-Based
      Software Engineering Workshop, May 2003, pp. 91-96<?line-break ?><biblioid
      class="uri"><link
      xlink:href="https://www.researchgate.net/publication/238655490_Automating_Service_Dependency_Management_in_a_Service-Oriented_Component_Model"/></biblioid></bibliomixed>

      <bibliomixed><title>Service Binder</title>Humberto Cervantes, Richard S.
      Hall<?line-break ?><biblioid class="uri"><link
      xlink:href="http://gravity.sourceforge.net/servicebinder"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1567926"><title>Java Properties
      File</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1636361"><title>Extensible Markup Language (XML)
      1.0</title><biblioid class="uri"><link
      xlink:href="https://www.w3.org/TR/REC-xml/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1655737"><title>OSGi XML Schemas</title><biblioid
      class="uri"><link
      xlink:href="https://docs.osgi.org/xmlns/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.component-jvms.ref"><title>The Java Virtual
      Machine Specification, Java SE 8 Edition</title><biblioid
      class="uri"><link
      xlink:href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.component-jls.ref"><title>The Java Language
      Specification, Java SE 8 Edition</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
  <section>
    <title>Changes</title>
    <itemizedlist>
      <listitem>
        <para>Add Component Activation Policy Header to control how to handle lazy activation.</para>
      </listitem>
    </itemizedlist>
   </section>
</chapter>
