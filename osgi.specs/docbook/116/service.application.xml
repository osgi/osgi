<?xml version="1.0" encoding="utf-8"?>
<chapter label="116"
         revision="$Id$"
         version="5" xml:id="service.application"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Application Admin Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.application-version"
    linkend="org.osgi.service.application"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The OSGi Application Admin specification is intended to simplify the
    management of an environment with many different
    <emphasis>types</emphasis> of applications that are simultaneously
    available. A diverse set of application types are a fact of life because
    backward compatibility and normal evolution require modern devices to be
    able to support novel as well as legacy applications. End users do not
    care if an application is an Applet, a Midlet, a bundle, a Symbian, or a
    BREW application. This specification enables applications that manage
    other applications, regardless of application type. These applications are
    called <emphasis>application managers</emphasis>. This specification
    supports enumerating, launching, stopping and locking applications. This
    specification does not specify a user interface or end-user
    interactions.</para>

    <para>The OSGi Framework is an excellent platform on which to host
    different Application Containers. The class loading and code sharing
    mechanisms available in the OSGi Framework can be used to implement
    powerful and extendable containers for Java based application models with
    relative ease. Native code based application models like Symbian and BREW
    can be supported with proxies.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Generic Model</emphasis> - The Application Admin
          specification defines how all applications, regardless of type, can
          be launched and destroyed. This application-type neutral model
          allows a screen or desktop manager access to all executable content
          in a uniform manner.</para>
        </listitem>

        <listitem>
          <para><emphasis>Schedule</emphasis> - A mechanism that allows the
          launching of applications at a predefined time, interval, or
          event.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dynamic</emphasis> - Detects installations and
          uninstallations of applications in real time.</para>
        </listitem>

        <listitem>
          <para><emphasis>Locking</emphasis> - Allows applications to be
          persistently locked so that they cannot be launched.</para>
        </listitem>

        <listitem>
          <para><emphasis>Exit Value</emphasis> - Provide a return value for
          an application that has exited.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Application</emphasis> - A software component, which
          has well-defined entry and exit criteria. Applications can be
          started and destroyed, and usually are designed for user
          interaction. Applications may be of various types, each having their
          own specification. Applications and application instances are
          visible through the their Application Descriptor services and
          Application Handle services.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Container</emphasis> - An implementation
          of a runtime environment for one or more application types. It
          provides specialized Application Descriptor and Application Handle
          services that correspond to the supported application type and their
          instances. The design of a particular Application Container is
          defined by other specifications. For example, an Application
          Container which implements MIDlets must follow the appropriate JSR
          specifications for MIDP.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Handle</emphasis> - A service that
          represents an <emphasis>instance</emphasis> of an application. This
          service is available in the OSGi service registry as long as the
          application instance exists.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Instance</emphasis> - The actual
          application that has been launched. Registered in the service
          registry as long as the application is running.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Descriptor</emphasis> - A service that
          represents an installed Application and provides information about
          the application as well as launching, scheduling and locking
          features. An Application Descriptor must be registered for each
          application as long as the Application is installed</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Manager</emphasis> - A bundle that
          manages a number of applications.</para>
        </listitem>

        <listitem>
          <para><emphasis>Scheduled Application</emphasis> - An information
          record for a scheduled application.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Application Management Diagram org.osgi.service.application
        package</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.340in"
                       contentwidth="7.000in"
                       fileref="application-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Synopsis</title>

      <para>Different types of applications can be accommodated in the
      Application Admin specification using a model of Application Containers.
      An Application Container typically follows an external specification,
      for example, the MIDP specification. In an OSGi environment, the
      implementer of such a specification can allow its applications (MIDlets
      in the previous example) to participate in the OSGi Application Model by
      registering an Application Descriptor service for each of its installed
      applications, and an Application Handle service for each of its running
      instances.</para>

      <para>This model leverages the capabilities of the OSGi service
      registry. Installed applications and running applications can be found
      by enumerating the appropriate services, possibly using a filter if a
      specific application is sought. The service registry provides necessary
      isolation of the clients of the applications and their implementers.
      Typical clients of this specification are desktop/screen managers that
      provide the end user access to the installed applications.</para>
    </section>
  </section>

  <section>
    <title>Application Managers</title>

    <para>An application manager (a bundle or application that manages other
    applications) must be able to discover the available applications, present
    them to an end user and launch applications on demand. A bundle that
    maintains the display of a mobile phone is a typical client of this
    specification.</para>

    <section xml:id="i1416836">
      <title>Discovery</title>

      <para>The primary means of discovery is the Application Descriptor
      service. An Application Container must register an Application
      Descriptor service for each of its applications. An application manager
      can detect the installation and uninstallation of applications by
      listening to service events.</para>

      <para>Service properties on the Application Descriptor carry most of the
      information that an application manager requires to present the
      application to the end user. The properties as defined in the following
      table.</para>

      <table xml:id="service.application-descriptor.service.properties">
        <title>Service Properties for an Application Descriptor</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="2*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="1*"/>

          <colspec colnum="4" colwidth="3*"/>

          <thead>
            <row>
              <entry><para>Key Name</para></entry>

              <entry><para>Type</para></entry>

              <entry><para>Default</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><code>service.pid</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>must be set</emphasis></para></entry>

              <entry><para>Unique identifier of the application. It is
              recommended to set a value generated from the vendor's reverse
              domain name, e.g. <code>com.acme.application.chess</code>. The
              <code>service.pid</code> service property is a standard
              Framework property.</para></entry>
            </row>

            <row>
              <entry><para><code>application.version</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>empty string</emphasis></para></entry>

              <entry><para>Specifies the version of the application. The
              default value is an empty string</para></entry>
            </row>

            <row>
              <entry><para><code>service.vendor</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>empty string</emphasis></para></entry>

              <entry><para>Specifies the vendor of the
              application.</para></entry>
            </row>

            <row>
              <entry><para><code>application.container</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>must be set</emphasis></para></entry>

              <entry><para>A unique identifier (like a PID) of the container
              implementation that registered this application
              descriptor.</para></entry>
            </row>

            <row>
              <entry><para><code>application.location</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>must be set</emphasis></para></entry>

              <entry><para>The identifier of package that contains the
              application corresponding to this descriptor. It represents the
              installation unit that contains the corresponding application.
              It should be a URL. For applications installed as bundles, it
              should be the location of the bundle. For others, it is defined
              by the container implementation.</para></entry>
            </row>

            <row>
              <entry><para><code>application.visible</code></para></entry>

              <entry><para><code>Boolean</code></para></entry>

              <entry><para><code>true</code></para></entry>

              <entry><para>Specifies whether the application should be visible
              for the user. For example, some applications may provide
              features to other applications but nothing directly to the user.
              In this case the application should not be revealed to the user
              to start it individually.</para></entry>
            </row>

            <row>
              <entry><para><code>application.launchable</code></para></entry>

              <entry><para><code>Boolean</code></para></entry>

              <entry><para><code>false</code></para></entry>

              <entry><para>Specifies whether the application is ready to be
              launched. If the value is <code>true</code>, it means that all
              the requirements of the application are
              fulfilled.</para></entry>
            </row>

            <row>
              <entry><para><code>application.locked</code></para></entry>

              <entry><para><code>Boolean</code></para></entry>

              <entry><para><code>false</code></para></entry>

              <entry><para>Specifies whether the represented application is
              locked to prevent launching it.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Specialized application descriptors can offer further service
      properties and method. For example, a MIDP container can register a
      property that describes that the MIDLet comes from a specific JAD file,
      thereby allowing a MIDLet aware Application Manager to group these
      MIDLets.</para>

      <para>Application Descriptor services must not be declarative. That is,
      they can be obtained from the service registry at any time without
      accidentally initializing a class loader.</para>

      <para>The following example shows how to track all visible, launchable,
      and unlocked applications. These tracked applications are the ones that
      can be started.</para>

      <programlisting>public class TrackLaunchables {
    final static String filter=
        "(&amp;(objectclass="
    +   ApplicationDescriptor.class.getName()
    + ")(application.launchable=true)"
    + "(application.visible=true)"
    + "(application.locked=false))";
    static ApplicationDescriptor[] EMPTY = 
        new ApplicationDescriptor[0];  
    ServiceTracker tracker;

    public void init(BundleContext cntxt) throws Exception {
        tracker = new ServiceTracker(cntxt, 
            cntxt.createFilter(filter), null);
        tracker.open();
    }

    public ApplicationDescriptor[] getActive() {
        Object [] result = tracker.getServices();
        List list = Arrays.asList(result);
        return (ApplicationDescriptor[]) list.toArray(EMPTY);
    }
}</programlisting>

      <para>The code is quite simple because the Service Tracker does the
      actual tracking. The most important part is therefore the filter. The
      filter selects all the Application Descriptor services that are visible,
      launchable, and not locked. The <code>getActive</code> method converts
      the <code>Object[]</code> that the Service Tracker maintains into an
      array of Application Descriptors.</para>
    </section>

    <section xml:id="i1416861">
      <title>Application Descriptor Properties</title>

      <para>The Application Descriptor object has an additional number of
      properties that are not available as service properties. These
      descriptor properties can be localized. The <xref
      linkend="org.osgi.service.application.ApplicationDescriptor.getProperties-String-"
      xrefstyle="hyperlink"/> method therefore takes a
      <emphasis>locale</emphasis> <code>String</code> object. This is a
      standard locale string as defined by the <code>java.util.Locale</code>
      class. The order for the locale constituents is:</para>

      <itemizedlist>
        <listitem>
          <para>language</para>
        </listitem>

        <listitem>
          <para>country</para>
        </listitem>

        <listitem>
          <para>variant</para>
        </listitem>
      </itemizedlist>

      <para>For example, the following files provide manifest translations for
      English, Dutch (Belgium and the Netherlands) and Swedish.</para>

      <programlisting>en          nl_BE           
nl_NL       sv</programlisting>

      <para>It returns a <code>Map</code> object containing localized versions
      of the properties. This is a copy of the original objects so changes to
      this <code>Map</code> object are not reflected in the Application
      Descriptor properties.</para>

      <para>If the locale string is <code>null</code>, the localization will
      be based on the default locale, as specified by the
      <code>java.util.Locale.getDefault</code> method. If the locale is the
      empty <code>String</code> object (<code>""</code>), no localization must
      be used. This will contain the raw values that are usually used as keys.
      If a specific locale has no appropriate translations, a less specific
      locale must be used, as described in the <code>Locale</code> class. As
      last resort, the raw values must be returned.</para>

      <para>The key names in the Map object are case-sensitive. Application
      Containers can add additional properties to this Map object, however,
      they must avoid key names starting with <code>application</code>. They
      should use key names that have a prefix that does not collide with other
      Application Containers.</para>

      <para>If no locale specific value of an application property is
      available then the default one must be returned. The following
      case-sensitive key names are treated as standard for locale specific
      values in the <code>Map</code> object. Additional elements may also be
      stored in the <code>Map</code> object. The specified properties are
      explained in the following table.</para>

      <table xml:id="service.application-descriptor.properties">
        <title>Descriptor localized properties</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="2.1*"/>

          <colspec colnum="2" colwidth="0.9*"/>

          <colspec colnum="3" colwidth="1*"/>

          <colspec colnum="4" colwidth="3*"/>

          <thead>
            <row>
              <entry><para>Key Name</para></entry>

              <entry><para>Type</para></entry>

              <entry><para>Default</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><code>application.name</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>must be set</emphasis></para></entry>

              <entry><para>The name of the application.</para></entry>
            </row>

            <row>
              <entry><para><code>application.icon</code></para></entry>

              <entry><para><code>URL</code></para></entry>

              <entry><para><emphasis>No Icon</emphasis></para></entry>

              <entry><para>A URL an icon's image resource. A compliant
              implementation of this specification must support the <xref
              linkend="i1519349"/>.</para></entry>
            </row>

            <row>
              <entry><para><code>application.version</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><code>0.0.0</code></para></entry>

              <entry><para>The version of the application</para></entry>
            </row>

            <row>
              <entry><para><code>service.vendor</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para/></entry>

              <entry><para>The vendor of the application</para></entry>
            </row>

            <row>
              <entry><para><code>application.visible</code></para></entry>

              <entry><para><code>Boolean</code></para></entry>

              <entry><para><code>true</code></para></entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry><para><code>application.launchable</code></para></entry>

              <entry><para><code>Boolean</code></para></entry>

              <entry><para><code>true</code></para></entry>

              <entry><para>If the application can be launched</para></entry>
            </row>

            <row>
              <entry><para><code>application.locked</code></para></entry>

              <entry><para><code>Boolean</code></para></entry>

              <entry><para><code>true</code></para></entry>

              <entry><para>If the application is locked</para></entry>
            </row>

            <row>
              <entry><para><code>application.description</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para/></entry>

              <entry><para>A description of the application</para></entry>
            </row>

            <row>
              <entry><para><code>application.documentation</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para/></entry>

              <entry><para>Document </para></entry>
            </row>

            <row>
              <entry><para><code>application.copyright</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para/></entry>

              <entry><para>A Copyright statement</para></entry>
            </row>

            <row>
              <entry><para><code>application.license</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para/></entry>

              <entry><para>A URL to the license related to the
              application</para></entry>
            </row>

            <row>
              <entry><para><code>application.container</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>must be set</emphasis></para></entry>

              <entry><para>The PID of the associated container</para></entry>
            </row>

            <row>
              <entry><para><code>application.location</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para/></entry>

              <entry><para>The URL of the location of the corresponding JAR
              file of the application, if exists.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Launching</title>

      <para>The Application Descriptor provides the <xref
      linkend="org.osgi.service.application.ApplicationDescriptor.launch-Map-"
      xrefstyle="hyperlink"/> methods for application managers to launch an
      application. Launching consists of creating the specific application
      object, starting it, registering an Application Handle service that
      represents that instance and return the Application Handle
      service.</para>

      <para>The <code>Map</code> object parameter is application specific.
      Applications should use unique names for the keys in this map, for
      example <code>com.acme.ringsignal</code>. This specification does not
      specify any keys for this map except for:</para>

      <itemizedlist>
        <listitem>
          <para><code>org.osgi.triggeringevent</code> - This property is set
          to the Event object that cause the application to be launched (if
          any).</para>
        </listitem>
      </itemizedlist>

      <para>When an application is started successfully the corresponding
      Application Handle service will be registered with the service
      registry.</para>
    </section>

    <section xml:id="i1460622">
      <title>Application States</title>

      <para>An Application Handle service represents an instance of an
      application. The application handle is registered by the Application
      Container after successfully launching a new application
      instance.</para>

      <para>An Application Handle service can be used to query the state and
      manipulate the application instance. It is the responsibility of the
      Application Handle service to maintain the application instance life
      cycle state by interacting with the implementation object of the
      application.</para>

      <para>A running instance can have the following state according to this
      specification:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationHandle.RUNNING"
          xrefstyle="hyperlink"/> - This is the state of the Application
          Handle when it gets registered. It indicates that the application
          instance is active.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationHandle.STOPPING"
          xrefstyle="hyperlink"/> - The application is stopping. This is a
          transient state.</para>
        </listitem>
      </itemizedlist>

      <para>Application Containers can extend the number of states.</para>

      <para>The Application Handle service maintains the service properties as
      listed in the following table. Specialized application handles may offer
      further service properties, but the key names specified in the table
      below must not be used for other purposes.</para>

      <table xml:id="service.application-handler.service.properties">
        <title>Application Handle service properties</title>

        <tgroup cols="4">
          <colspec colnum="1" colwidth="2*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="1*"/>

          <colspec colnum="4" colwidth="3*"/>

          <thead>
            <row>
              <entry><para>Key Name</para></entry>

              <entry><para>Type</para></entry>

              <entry><para>Default</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><code>service.pid</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>must be set</emphasis></para></entry>

              <entry><para>The Application Instance ID as returned by the
              <code>getInstanceId</code> method.</para></entry>
            </row>

            <row>
              <entry><para><code>application.state</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>must be set</emphasis></para></entry>

              <entry><para>Contains the current state of the application
              instance represented by this application handle. These states
              can be application model specific.</para></entry>
            </row>

            <row>
              <entry><para><code>application.descriptor</code></para></entry>

              <entry><para><code>String</code></para></entry>

              <entry><para><emphasis>must be set</emphasis></para></entry>

              <entry><para>The PID of the associated Application Descriptor
              service</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Specialized application handles may offer further application
      states. The name of additional states must be qualified names (dotted);
      non-qualified names are reserved for future specifications.</para>
    </section>

    <section>
      <title>Destroying an Application Instance</title>

      <para>An application instance can be stopped with its associated
      Application Handle using the <xref
      linkend="org.osgi.service.application.ApplicationHandle.destroy--"
      xrefstyle="hyperlink"/> method. This first turns the state of the
      Application to <xref
      linkend="org.osgi.service.application.ApplicationHandle.STOPPING"
      xrefstyle="hyperlink"/>. The application instance may save its
      persistent data before termination and it must release all the used
      resources. The application instance's artifacts should not be reused any
      more. The Application Admin implementation and the application container
      should ensure (even forcefully) that all allocated resources are cleaned
      up.</para>

      <para>If the application instance has completely stopped, then its
      Application Handle must be unregistered.</para>
    </section>

    <section>
      <title>Getting the Exit Value of an Application</title>

      <para>Many application containers allow an application to specify a
      value when the application is stopped. This value is called the
      <emphasis>exit value</emphasis>. The Application Handle can therefore
      return the exit value when this is supported by the underlying
      application model. It is possible to find out if the underlying
      container support exit values because not all application containers
      support exit values.</para>

      <para>The Application Descriptor has a special service property that it
      must set when it supports exit values. This service property name is
      defined on the <code>ApplicationHandle</code> class as <xref
      linkend="org.osgi.service.application.ApplicationHandle.APPLICATION_SUPPORTS_EXITVALUE"
      xrefstyle="hyperlink"/>. Setting this property to any value signals that
      the application instance supports an exit value return.</para>

      <para>The <xref
      linkend="org.osgi.service.application.ApplicationHandle.getExitValue-long-"
      xrefstyle="hyperlink"/> method on the <code>ApplicationHandle</code>
      class returns the exit value object from the underlying application
      container. If the application container does not support exit values,
      then this method must always throw an Unsupported Operation
      Exception.</para>

      <para>The method takes a time out value which allows it to wait for the
      application instance to finish. This time-out can take the following
      values:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>negative</emphasis> - When the time-out is negative,
          there is no waiting. If the application instance has finished, the
          exit value will be returned. Otherwise an Application Exception must
          be thrown with the error code set to <xref
          linkend="org.osgi.service.application.ApplicationException.APPLICATION_EXITVALUE_NOT_AVAILABLE"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>zero</emphasis> - The method will wait indefinitely
          until the application is finished.</para>
        </listitem>

        <listitem>
          <para><emphasis>positive</emphasis> - The method will wait for the
          application to finish the given number of milliseconds. If after
          that time the application instance is still not finished, an
          Application Exception must be thrown with the error code set to
          <xref
          linkend="org.osgi.service.application.ApplicationException.APPLICATION_EXITVALUE_NOT_AVAILABLE"
          xrefstyle="hyperlink"/>.</para>
        </listitem>
      </itemizedlist>

      <para>The type of the exit value is undefined, it is a generic Java
      object. It is up to the application container to define the actual type
      for this Object.</para>
    </section>

    <section>
      <title>Locking an Application</title>

      <para>Applications represented by the application descriptors can be
      locked. If an application is locked then no new instance of the
      represented application can be started until it is unlocked. The locking
      state of the application has no effect on the already launched
      instance(s). The Application Descriptor provides the methods
      <code>lock</code> and <code>unlock</code> to set, unset the locking
      state. Locking and unlocking an application represented by an
      Application Descriptor requires the proper Application Admin Permission.
      The methods to lock, unlock, and query the locked status of an
      application are implemented as final methods of the abstract application
      descriptor class to ensure that an application container implementation
      will not be able to circumvent this security policy.</para>
    </section>

    <section xml:id="service.application.scheduling">
      <title>Scheduling</title>

      <para>Scheduling can be used to launch an a new application instance in
      the future when a specific event occurs, if needed on a recurring
      basis.</para>

      <para>The Application Descriptor service provides the <xref
      linkend="org.osgi.service.application.ApplicationDescriptor.schedule-String-Map-String-String-boolean-"
      xrefstyle="hyperlink"/> method to schedule an application to be launched
      when an specific event occurs. The parameters to this method are:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Schedule Id - </emphasis>( <code>String</code>) An
          id for this application that identifies the schedule, even over
          system restarts. Ids must be unique for one application. This id
          will be registered as service property on the Scheduled Application
          service under the name of <xref
          linkend="org.osgi.service.application.ScheduledApplication.SCHEDULE_ID"
          xrefstyle="hyperlink"/>. The name must match the following
          format:</para>

          <para><programlisting>    scheduleId ::= symbolic-name 
               // See General Syntax Definitions in Core</programlisting></para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis>Arguments</emphasis> - (<code>Map)</code> These
          arguments will be passed to the application in the
          <code>launch</code> method. The keys in this map must not be null or
          the empty string.</para>
        </listitem>

        <listitem>
          <para><emphasis>Topic</emphasis> - (<code>String</code>) The topic
          of the event that must trigger the launch of the application.</para>
        </listitem>

        <listitem>
          <para><emphasis>Filter</emphasis> - (<code>String</code>) A filter
          that is passed to the Event Admin for subscribing to specific
          events, can be <code>null</code>. The syntax of the string is the
          same as an OSGi Framework filter.</para>
        </listitem>

        <listitem>
          <para><emphasis>Recurring</emphasis> - (<code>boolean</code>)
          Repeatedly launch the application when the specified events occur
          until the schedule is canceled.</para>
        </listitem>
      </itemizedlist>

      <para>The <code>schedule</code> method must register a Scheduled
      Application service with the service registry and return the Schedule
      Application service object.</para>

      <para>For example, the invocation</para>

      <programlisting>appDesc.schedule(
    null,       // System generates schedule id
    null,       // No arguments
    "org/osgi/application/timer",
    "(&amp;(hour_of_day=0)(minute=0))",
    true) </programlisting>

      <para>Schedules the application to be launched when a timer event is
      received and the <code>hour_of_day</code> and <code>minute</code>
      properties are zero.</para>

      <para>The Scheduled Application service must have the following
      properties:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ScheduledApplication.APPLICATION_PID"
          xrefstyle="hyperlink"/> - (<code>String</code>) The PID of the
          Application Descriptor service.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ScheduledApplication.SCHEDULE_ID"
          xrefstyle="hyperlink"/> - (<code>String</code>) a unique id (within
          the schedules for one application).</para>
        </listitem>
      </itemizedlist>

      <para>The list of active Scheduled Application services can be obtained
      from the service registry. A non-recurrent Scheduled Application service
      is unregistered once the application is successfully launched.</para>

      <para>The timer used to start an application from a schedule has a
      resolution of one minute. It is therefore possible that an application
      is delayed up to a minute before it is started.</para>
    </section>

    <section>
      <title>Application Exceptions</title>

      <para>Exceptional conditions that arise during processing of application
      requests. The Exception identifies the actual error with an integer
      code. The following codes are supported:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationException.APPLICATION_INTERNAL_ERROR"
          xrefstyle="hyperlink"/> - An internal error occurred.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationException.APPLICATION_LOCKED"
          xrefstyle="hyperlink"/> - The application is locked and can
          therefore not be launched.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationException.APPLICATION_NOT_LAUNCHABLE"
          xrefstyle="hyperlink"/> - The application could not be
          launched.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationException.APPLICATION_SCHEDULING_FAILED"
          xrefstyle="hyperlink"/> - The application scheduling could not be
          created due to some internal error. This entails that the scheduling
          information is not persisted.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationException.APPLICATION_DUPLICATE_SCHEDULE_ID"
          xrefstyle="hyperlink"/> - The application scheduling failed because
          the specified identifier is already in use.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Application Events</title>

      <para>The event mechanism of the Application Admin specification is
      based on the OSGi service registry event model. Both Application
      Descriptor and Application Handle are services. Bundles can listen to
      these events registering a <code>ServiceListener</code> object with a
      Bundle Context or they can listen to events from the Event Admin, see
      for more information <xref
      linkend="service.event.serviceevent"/>.</para>

      <itemizedlist>
        <listitem>
          <para>Application Descriptor service</para>

          <itemizedlist>
            <listitem>
              <para><code>REGISTERED</code> - A new application has become
              available. Depending on its properties, this application could
              be launched.</para>
            </listitem>

            <listitem>
              <para><code>MODIFIED</code> - The visibility, launchable or
              locked status is changed.</para>
            </listitem>

            <listitem>
              <para><code>UNREGISTERING</code> - The application is no longer
              available. All running instances of this application must be
              destroyed before this event is delivered.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Application Handle service</para>

          <itemizedlist>
            <listitem>
              <para><code>REGISTERED</code> - A new instance is created and
              started running.</para>
            </listitem>

            <listitem>
              <para><code>MODIFIED</code> - The application instance is
              changed its state. This specification only specifies the
              <code>STOPPING</code> state but application containers are free
              to add additional states. Transitions between all these states
              must be signaled with the <code>MODIFIED</code> service
              event.</para>
            </listitem>

            <listitem>
              <para><code>UNREGISTERING</code> - The application instance is
              no longer running.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Application Containers</title>

    <para>Application Containers provide the implementation of a specific
    application model like MIDP, BREW,.NET, or Symbian. Application Containers
    can be implemented inside the OSGi environment or run externally, in
    another VM or as native code. When the container runs externally, it is
    necessary to run a proxy inside the OSGi environment that communicates
    with the external container. This is shown in <xref
    linkend="i1416477"/>.</para>

    <figure xml:id="i1416477">
      <title>Application Container Model with Proxy</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="3.109in"
                     contentwidth="7.000in" fileref="model-with-proxy.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>The Application Descriptor</title>

      <para>The first responsibility of the Application Container is to
      register an Application Descriptor for each available application. The
      Application Container must therefore extend the
      <code>ApplicationDescriptor</code> base class that is provided by the
      Application Admin implementer and provided in the
      <code>org.osgi.service.application</code> package. The base class is
      defined as an abstract class in this specification with only minimal
      implementation code. Implementers of the Application Admin
      implementation can replace this class with an implementation that
      enforces their desired policies.</para>

      <para>The Application Container must override the methods that have a
      <code>Specific</code> suffix. These methods are:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.ApplicationDescriptor-String-"
          xrefstyle="hyperlink"/> - The Base class Application Descriptor
          takes the PID of the Application Descriptor as argument.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.getPropertiesSpecific-String-"
          xrefstyle="hyperlink"/> - Return the properties (including service
          properties) based on a specific locale. See the locale rules at
          <xref linkend="i1416861"/>. The Application Container must fill the
          returned <code>Map</code> object with the properties listed in <xref
          linkend="service.application-descriptor.properties"
          xrefstyle="template:Table %n on page %p"/> as well as other service
          properties. Non-localized data is returned if the corresponding
          application container doesn't support the localization of
          application properties. Changes in the <code>Map</code> object must
          not be reflected in Application Descriptor properties.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.launchSpecific-Map-"
          xrefstyle="hyperlink"/> - Launch a new instance and return its
          handle. The container must ensure that the application is started in
          a <code>doPrivileged</code> block I.e. the permissions of the caller
          must not influence the capabilities of the started
          application.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.lockSpecific--"
          xrefstyle="hyperlink"/> - Do the specific locking of the Application
          Descriptor.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.unlockSpecific--"
          xrefstyle="hyperlink"/> - Do the specific unlocking of the
          Application Descriptor.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.isLaunchableSpecific--"
          xrefstyle="hyperlink"/> - This method must return <code>true</code>
          when the application can be launched. This method can be called by
          the Application Descriptor implementation to find out if an
          application can be launched according to the container.</para>
        </listitem>
      </itemizedlist>

      <para>The specific methods must be made <code>protected</code> because
      the specific Application Descriptor is registered as a service and is
      intended to be used by a wide array of clients. These clients can call
      public methods so care should be taken to ensure that no intrusion can
      take place this way. The Application Admin implementer must provide the
      implementation for the <code>public</code> methods and perform the
      appropriate security checks.</para>

      <para>The specific Application Descriptor must be registered for each
      possible application with the set of service properties listed in <xref
      linkend="service.application-descriptor.service.properties"
      xrefstyle="template:Table %n on page %p"/>.</para>

      <para>An application is launched with the <code>launchSpecific</code>
      method. This method is called by the Application Admin implementation,
      as implemented in the <code>ApplicationDescriptor</code> base class. The
      implementation of the <code>launchSpecific</code> method must return
      expediently. The Application Descriptor must perform the following steps
      (in the given order):</para>

      <orderedlist>
        <listitem>
          <para>Create a new instance of the associated application</para>
        </listitem>

        <listitem>
          <para>Start the application in another process or thread.</para>
        </listitem>

        <listitem>
          <para>If the application cannot be started, an appropriate Exception
          must be thrown.</para>
        </listitem>

        <listitem>
          <para>Register an Application Handle for this running application.
          The registration of the Application Handle must be accompanied by
          the service properties from <xref
          linkend="service.application-handler.service.properties"
          xrefstyle="template:Table %n on page %p"/>.</para>
        </listitem>

        <listitem>
          <para>Return the new Application Handle.</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>The Application Handle</title>

      <para>The Application Handle represents the running instance. The
      Application Container must extend the provided base class and implement
      the following methods:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationHandle.ApplicationHandle-String-ApplicationDescriptor-"
          xrefstyle="hyperlink"/> - The constructor of the base class takes
          the executable id and the Application Descriptor as
          parameter.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationHandle.destroySpecific--"
          xrefstyle="hyperlink"/> - Clients of the Application Admin
          specification use the <code>destroy</code> method on the Application
          Handle service to make an application instance quit. The Application
          Admin implementer must at an appropriate time call the
          <code>destroySpecific</code> method. The Application Container must
          destroy the application instance (if it had not destroyed already)
          and clean up.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationHandle.getApplicationDescriptor--"
          xrefstyle="hyperlink"/> - Return the Application Descriptor that
          belongs to this Application Handle.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationHandle.getInstanceId--"
          xrefstyle="hyperlink"/> - A unique id for this instance.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationHandle.getState--"
          xrefstyle="hyperlink"/> - Returns the state for the instance. The
          Application Admin specification only specifies two states:
          <code>RUNNING</code> and <code>STOPPING</code>. Application
          Containers can add new states to represent for example
          <code>PAUSED</code>. States are strings and must be qualified to
          prevent conflicts. For example, the Midlet state for paused could be
          <code>MIDLET.PAUSED</code>.</para>
        </listitem>
      </itemizedlist>

      <para>The most important method is <code>destroySpecific</code>. This
      method must perform the following actions in the given order:</para>

      <orderedlist>
        <listitem>
          <para>Set the state to <code>STOPPING</code></para>
        </listitem>

        <listitem>
          <para>Modify the service properties of the Service Handle to reflect
          the new state. This sends out a service event.</para>
        </listitem>

        <listitem>
          <para>If the application instance is active, use any proprietary
          mechanism to stop it. Any errors and problems should be
          logged.</para>
        </listitem>

        <listitem>
          <para>Using proprietary means, clean up any resources on the system
          that were used by the application: locks, open files, etc.</para>
        </listitem>

        <listitem>
          <para>Unregister the Application Handle service.</para>
        </listitem>
      </orderedlist>

      <para>The Application container should monitor the progress of its
      instances. If an instance stops, for example due an exception or it
      quits voluntarily, the Application Container must call the destroy
      method on the Application Handle itself and handle the fact correctly
      that the instance is already stopped in the <code>destroySpecific</code>
      method.</para>
    </section>

    <section>
      <title>Certificates</title>

      <para>The following method on the Application Descriptor provides access
      to the certificate chain that was used to sign the application. This
      method is used by the Application Permission.</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.matchDNChain-String-"
          xrefstyle="hyperlink"/> - Verifies that the given pattern matches
          one or more of the certificates that were used to sign the
          application. This method is primarily used by the Application Admin
          Permission to verify permissions. Matching certificates is described
          in <emphasis>Certificate Matching</emphasis> of <xref
          linkend="intro.core.release" xrefstyle="template:%t"/>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Application Descriptor Example</title>

      <para>This is an Application Container that scans a directory for
      executables. Each executable is registered as an Application Descriptor.
      The example assumes that there is a bundle activator that creates the
      Application Descriptor services. This activator must also ensure that
      when it is stopped no handles remain.</para>

      <para>The example is not an robust implementation, its only intention is
      to show the concepts of the Application Admin specification in
      practice.</para>

      <para>The (simple) Application Descriptor could look like:</para>

      <programlisting>public class SimpleDescriptor extends ApplicationDescriptor{
    ServiceRegistration registration;
    File                executable;
    SimpleModel         model;
    boolean             locked;
    static URL          genericIcon = SimpleDescriptor.class
                                            .getResource("icon.png");

    SimpleDescriptor(SimpleModel model, File executable) {
        super("com.acme." + executable.getName());
        this.model = model;
        this.executable = executable;
    }

    public Map getPropertiesSpecific(String locale) {
        Map map = new Hashtable();
        map.put(APPLICATION_ICON, genericIcon);
        map.put(APPLICATION_NAME, executable.getName());
        return map;
    }

    protected ApplicationHandle launchSpecific(
        final Map args) throws Exception {
        final SimpleDescriptor descriptor = this;

        return (ApplicationHandle) AccessController
                .doPrivileged(new PrivilegedExceptionAction() {
                    public Object run() throws Exception {
                        SimpleHandle handle = 
                            new SimpleHandle(descriptor, args);
                        handle.registration =
                            model.register(handle);
                        return handle;
                    }
                });
    }

    Dictionary getServiceProperties() {
        Hashtable p = new Hashtable();
        p.put(APPLICATION_LAUNCHABLE, Boolean.TRUE);
        p.put(APPLICATION_LOCKED, Boolean.valueOf(locked));
        p.put(Constants.SERVICE_PID, getApplicationId());
        return p;
    }

    protected void lockSpecific() { locked = true; }
    protected void unlockSpecific() { locked = false; }
    public boolean matchDNChain(String arg) { return false; }
    protected boolean isLaunchableSpecific() { return true; }
}</programlisting>

      <para>The associated Application Handle must launch the external
      executable and track its process. If the process dies autonomously or is
      stopped via the <code>destroy</code> method, it must unregister the
      Application Handle service. The class could be implemented like:</para>

      <programlisting>public class SimpleHandle extends 
    ApplicationHandle implements Runnable {

    ServiceRegistration registration;
    Process             process;
    int                 instance;
    String              state = RUNNING;
    static int          INSTANCE = 0;
    Thread              thread;

    public SimpleHandle(SimpleDescriptor descriptor, 
        Map arguments) throws IOException {
        super(descriptor.getApplicationId() 
            + ":" + (INSTANCE++), descriptor);
        String path = descriptor.executable.getAbsolutePath();
        process = Runtime.getRuntime().exec(path);
        thread = new Thread(this, getInstanceId());
        thread.start();
    }

    public String getState() {  return state; }

    protected void destroySpecific() throws Exception {
        state = STOPPING;
        registration.setProperties(getServiceProperties());
        thread.interrupt();
    }

    // Wait until process finishes or when
    // interrupted
    public void run() {
        try {
            process.waitFor();
            destroy();
        }
        catch (InterruptedException ie) {
            process.destroy();
            try {
                process.waitFor();
            }
            catch (InterruptedException iee) {
                // Ignore
            }
        }
        catch( Exception e ) {
            .. logging
        }
        registration.unregister();
    }

    Dictionary getServiceProperties() {
        Hashtable p = new Hashtable();
        p.put(APPLICATION_PID, getInstanceId());
        p.put(APPLICATION_STATE, state);
        p.put(APPLICATION_DESCRIPTOR,
            getApplicationDescriptor().getApplicationId());
        return p;
    }
}</programlisting>

      <para>The Application Container must create the Application Descriptor
      services from some source. Care should be taken to optimize this
      scanning so that the initialization time is not significantly increased.
      Running application instances should be stopped if the Application
      Container is stopped. The following code shows a possible
      implementation:</para>

      <programlisting>public class SimpleModel implements BundleActivator{
    BundleContext context;
    Set           handles = new HashSet();

    public ServiceRegistration register(SimpleHandle handle){
        handles.add(handle);
        return context.registerService(
            ApplicationHandle.class.getName(),
            handle, handle.getServiceProperties());
    }

    public void start(BundleContext context) throws Exception 
    {
        this.context = context; 

        File file = new File("c:/windows");
        final SimpleModel me = this;

        file.list(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                if (name.endsWith(".exe")) {
                    SimpleDescriptor sd = new SimpleDescriptor(me,
                        new File(dir, name));
                    sd.registration = me.context.registerService(
                            ApplicationDescriptor.class.getName(),
                                sd, sd.getServiceProperties());
                }
                // We ignore the return anyway
                return false;
    }});}

    public void stop(BundleContext context) throws Exception{
        for (Iterator handle = handles.iterator();
            handle.hasNext();) {
            SimpleHandle sh = (SimpleHandle) handle.next();
            try {
                sh.destroy();
            }
            catch (Exception e) {
                // We are cleaning up ...
            }
}}}</programlisting>
    </section>
  </section>

  <section>
    <title>Application Admin Implementations</title>

    <section>
      <title>Implementing the Base Classes</title>

      <para>The OSGi specified <code>org.osgi.service.application</code>
      package that is delivered with the specification in a JAR file is a
      dummy implementation. The intention of this package is to be replaced by
      an Application Admin implementation. This implementation can then
      enforce policies by intercepting the calls from any Application Managers
      to the Application Containers.</para>

      <para>The Application Admin implementer must re-implement the following
      methods in the <code>ApplicationDescriptor</code> class:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.launch-Map-"
          xrefstyle="hyperlink"/> - The method can perform any checks before
          it must call the <xref
          linkend="org.osgi.service.application.ApplicationDescriptor.launchSpecific-Map-"
          xrefstyle="hyperlink"/> method. This must be a protected method. The
          implementation must perform any security checks. If these succeed,
          the <code>launchSpecific</code> method must not be called in a
          <code>doPrivileged</code> block.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.lock--"
          xrefstyle="hyperlink"/> - Must call the <code>lockSpecific</code>
          method.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.unlock--"
          xrefstyle="hyperlink"/> - Must call the <code>unlockSpecific</code>
          method.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationDescriptor.schedule-String-Map-String-String-boolean-"
          xrefstyle="hyperlink"/> - Register a new Scheduled Application
          service with the given arguments, thereby scheduling the application
          for launching when the topic and filter match an event. A virtual
          event is defined for timer based scheduling, see <xref
          linkend="i1508317"/>.</para>
        </listitem>
      </itemizedlist>

      <para>The Application Admin implementer must also implement the
      following method in the <code>ApplicationHandle</code> class:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationHandle.destroy--"
          xrefstyle="hyperlink"/> - The Application Admin implementer should
          call the protected <xref
          linkend="org.osgi.service.application.ApplicationHandle.destroySpecific--"
          xrefstyle="hyperlink"/> method after which it should perform any
          possible cleanup operations.</para>
        </listitem>
      </itemizedlist>

      <para>Implementers must not change the signature of the
      <code>public</code> and <code>protected</code> parts of the
      <code>ApplicationDescriptor</code> and <code>ApplicationHandle</code>
      classes. Adding fields or methods, either public or protected is
      explicitly forbidden.</para>
    </section>

    <section>
      <title>Exception Handling</title>

      <para>The implementation of the container must ensure that Security
      Exceptions are only thrown during the invocation of any of the
      Application Descriptor methods when the required permissions are
      lacking. If the Application Descriptor is not valid, an Illegal State
      Exception must be thrown and never a Security Exception.</para>
    </section>

    <section>
      <title>Launching</title>

      <para>The <code>launch</code> method of the Application Descriptor must
      be implemented by the Application Admin implementer. Launching must be
      performed in the following steps:</para>

      <orderedlist>
        <listitem>
          <para>Verify that the caller has the appropriate permissions, see
          <xref linkend="i1470141"/>.</para>
        </listitem>

        <listitem>
          <para>Verify that the Application Descriptor is not locked and
          launchable</para>
        </listitem>

        <listitem>
          <para>Perform any policy actions that are deemed necessary before
          the application is really launched.</para>
        </listitem>

        <listitem>
          <para>Call the protected <code>launchSpecific</code> method. If the
          method throws an Exception, then this exception should be logged,
          and must be re-thrown.</para>
        </listitem>

        <listitem>
          <para>Otherwise, return the received Application Handle</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>Destroying</title>

      <para>The implementation of the <code>ApplicationHandle</code>
      <code>destroy</code> method must follow the following steps:</para>

      <orderedlist>
        <listitem>
          <para>Verify that the caller has the appropriate permissions, see
          <xref linkend="i1470141"/>.</para>
        </listitem>

        <listitem>
          <para>Call the <code>destroySpecific</code> method. If an Exception
          is thrown, then this should be logged but must be further
          ignored.</para>
        </listitem>

        <listitem>
          <para>Perform any cleanup deemed necessary.</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>Scheduling</title>

      <para>Application Descriptor services can be scheduled by calling the
      <code>schedule</code> method, as described in <xref
      linkend="service.application.scheduling"/>. This method must be
      implemented by the Application Admin implementer.</para>

      <para>Application Admin implementations must make a reasonable effort to
      launch scheduled applications in a timely manner. However, launching is
      not guaranteed, implementations can drop and forget events if it is
      necessary in order to preserve the stability and integrity of the
      device. The granularity of the timer should also be taken into account,
      this granularity is one minute so the actual time an application will be
      launched can be shifted up to 60 seconds.</para>

      <para>If an event would launch multiple applications then the order of
      launching is not defined, it is implementation specific.</para>

      <para>Launching a scheduled application is constrained by the same rules
      as application launching. Thus, attempting to launch a locked
      application on the specified event must fail to launch. Launching can
      only succeed when the application is unlocked.</para>

      <para>If the scheduling is non-recurring and launching a new instance
      fails then when the specified event occurs again launching the
      application must be attempted again until it succeeds. Non recurring
      schedules must be removed once the launch succeeds.</para>

      <para>The triggering event will be delivered to the starting application
      instance as an additional item identified by the
      <code>org.osgi.triggeringevent</code> argument in its startup
      parameters. This property must not be used for other purposes in the
      startup parameters. To ensure that no events are leaked to applications
      without the appropriate permission, the event is delivered in a
      <code>java.security.GuardedObject</code>, where the guarding permission
      is the Topic Permission for the topic to which the event was
      posted.</para>

      <para>Scheduling and unscheduling an application, or retrieving
      information about scheduled applications requires the Application Admin
      Permission for the target application to be scheduled. If the target is
      the unique identifier of the scheduling application itself then it can
      schedule itself. In addition, the scheduling entity must have Topic
      Permission for the specified topic.</para>
    </section>

    <section xml:id="i1508317">
      <title>Virtual Timer Event</title>

      <para>The application scheduler can use a virtual timer event for time
      scheduled applications. This event is not actually sent out by the Event
      Admin; this virtual event is only used for the syntax to specify a
      recurring launch.</para>

      <para>The topic name of this virtual timer event is:</para>

      <programlisting>org/osgi/application/timer</programlisting>

      <para>The properties of the virtual timer event are:</para>

      <itemizedlist>
        <listitem>
          <para><code>year</code> - (<code>Integer</code>) The year of the
          specified date. The value is defined by <code>Calendar.YEAR</code>
          field.</para>
        </listitem>

        <listitem>
          <para><code>month</code> - (Integer) The month of the year. The
          value is defined by <code>Calendar.MONTH</code> field.</para>
        </listitem>

        <listitem>
          <para><code>day_of_month</code> - (<code>Integer</code>) The day of
          the month. The value is defined by the
          <code>Calendar.DAY_OF_MONTH</code> field.</para>
        </listitem>

        <listitem>
          <para><code>day_of_week</code> - ( <code>Integer</code>) The day of
          the week. The value is defined by the
          <code>Calendar.DAY_OF_WEEK</code> field.</para>
        </listitem>

        <listitem>
          <para><code>hour</code>_of_day - (<code>Integer</code>) The hour of
          the day. The value is defined by the
          <code>Calendar.HOUR_OF_DAY</code> field.</para>
        </listitem>

        <listitem>
          <para><code>minute</code> - (<code>Integer</code>) The minute of the
          hour. The value is defined by the <code>Calendar.MINUTE</code>
          field.</para>
        </listitem>
      </itemizedlist>

      <para>The timer has a resolution of a minute. That is, it is not
      possible to schedule per second.</para>

      <para>A property that is not included into the filter matches any value.
      Not including a field implies that it always matches. For example, if
      the <code>minute=0</code> clause from the filter is missing, the timer
      event will be fired every minute.</para>

      <para>The following examples are filters for the timer event to specify
      certain time in the device local time. The topic is always
      <code>org/osgi/application/timer</code>.</para>

      <para>Noon every day:</para>

      <programlisting>(&amp;(hour_of_day=12)(minute=0))</programlisting>

      <para>Every whole hour, on every Sunday:</para>

      <programlisting>(&amp;(day_of_week=0)(minute=0))</programlisting>

      <para>Every whole hour:</para>

      <programlisting>(minute=0)</programlisting>
    </section>
  </section>

  <section>
    <title>Interaction</title>

    <section>
      <title>Application Installation</title>

      <para><xref linkend="i1515497"/> shows how an application manager can be
      notified about the installation of a new application. The actual
      installation may be done prior to the notification or may be done by the
      application container. At the end of the successful installation the
      application container must register a specialized Application Descriptor
      service which properly represents the installed application. If the
      installed application's dependencies are fulfilled (which are container
      specific) then the application descriptor's
      <code>application.visible</code> and <code>application.launchable</code>
      properties should be set to <code>true</code>.</para>

      <figure xml:id="i1515497">
        <title>Installing a bundle that is managed by an Application
        Container</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.586in"
                       contentwidth="4.963in" fileref="installing-bundle.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Launching an Application</title>

      <para>Firstly the appropriate Application Descriptor service on which
      the operation will be made is fetched from the service registry. This
      Application Descriptor is a container specific sub-class of the
      Application Descriptor class. Its <code>launch</code> method is called
      which is in the base class.</para>

      <para>The application instance may not receive the startup arguments if
      its application container does not support startup arguments. The
      <code>launch</code> method checks if the a new application instance can
      be launched, for example, that the necessary rights are granted, the
      application is not locked and the application is not a singleton that
      already has an instance.</para>

      <para>If the application can be launched then the
      <code>launchSpecific</code> method, which is in the subclass, will
      create and start a new application instance according to its application
      container. It will create a specific application handle and associate
      the newly created application instance to it. The
      <code>launchSpecific</code> method will register the application handle
      with proper service properties. The value of
      <code>application.state</code> service property must be
      <code>RUNNING</code>. The call chain returns the application
      handle.</para>

      <figure pgwide="1">
        <title>Launching an application</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.176in"
                       contentwidth="4.963in"
                       fileref="launching-application.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Destroying an Application Instance</title>

      <para>To destroy an application, the proper application handle has to be
      fetched from the service registry to call its <code>destroy()</code>
      method. It checks if the instance can be destroyed, for example that the
      necessary permissions are granted, it then calls the
      <code>destroySpecific</code> method to let its implementation destroy
      the instance in an application container specific way. First, it sets
      the <code>application.state</code> service property to
      <code>STOPPING</code> then stops the application instance. Finally it
      unregisters the application handle.</para>
    </section>
  </section>

  <section xml:id="i1470141">
    <title>Security</title>

    <para>The Application Admin specification is an interaction of the:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Application Container implementers</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis>Applications</emphasis></para>
      </listitem>

      <listitem>
        <para>Application Managers</para>
      </listitem>
    </itemizedlist>

    <para>There are two permissions used in the security model of the
    Application Admin specification. The first is the Service Permission that
    grants access to getting or registering the Application Descriptor and
    Application Handle services. The second security is specific for the
    Application Admin specification and is the Application Permission.</para>

    <para>The Application Container must be very powerful because it starts
    the application code, which should be able to perform almost any
    function.</para>

    <para>The security checks are performed in the
    <code>ApplicationDescriptor</code> and <code>ApplicationHandle</code> base
    classes.</para>

    <section>
      <title>Application Admin Permissions</title>

      <para>This <code>ApplicationAdminPermission</code> class implements
      permissions for manipulating applications and their instances. The
      permission must be held by any bundle that manipulates application
      descriptors or application handles.</para>

      <para>The target of the Application Admin Permission is an OSGi filter
      that matches a number of properties. This is similar to the Admin
      Permission in the Framework. Alternatively, instead of the filter the
      pseudo target &lt;<code>&lt;SELF&gt;&gt;</code> can be used.</para>

      <para>The following properties can be tested in the filter:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>signer</emphasis> - A Distinguished Name chain that
          is used to sign the application. The matching of this property must
          be done according to the rules described for DN matching in <xref
          linkend="intro.core.release" xrefstyle="template:%t"/>. The
          Application Admin Permission must use the
          <code>ApplicationDescrptor</code> class' <code>matchDNChain</code>
          method. Matching DN's is described in <emphasis>Certificate
          Matching</emphasis> of <xref linkend="intro.core.release"
          xrefstyle="template:%t"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>pid</emphasis> - The PID of the target
          application.</para>
        </listitem>
      </itemizedlist>

      <para>The pseudo target <code>&lt;&lt;SELF&gt;&gt;</code> indicates that
      the calling application is allowed to manipulate its own descriptors and
      handlers.</para>

      <para>The following actions can be granted:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationAdminPermission.SCHEDULE_ACTION"
          xrefstyle="hyperlink"/> - The caller is allowed to schedule an
          application., i.e. call the <code>ApplicationDescriptor</code>
          <code>schedule</code> method. This action implies <xref
          linkend="org.osgi.service.application.ApplicationAdminPermission.LIFECYCLE_ACTION"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationAdminPermission.LIFECYCLE_ACTION"
          xrefstyle="hyperlink"/> - The caller is allowed to manipulate the
          life cycle state of an application instance: launch and
          destroy.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.application.ApplicationAdminPermission.LOCK_ACTION"
          xrefstyle="hyperlink"/> - The caller is allowed to the
          <code>lock</code> and <code>unlock</code> methods.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Service and Package Permissions</title>

      <section>
        <title>Application Admin Implementation</title>

        <para>The Application Admin implementation must have the following
        permissions:</para>

        <programlisting>ServicePermission  ..ScheduledApplication         REGISTER
ServicePermission  ..ApplicationDescriptor        GET
ServicePermission  ..ApplicationHandle            GET
PackagePermission  org.osgi.service.application   EXPORTONLY
ServicePermission  ..ApplicationDescriptor        GET
ServicePermission  ..ApplicationHandle            GET
ApplicationAdminPermission *                      *</programlisting>
      </section>

      <section>
        <title>Application Container</title>

        <programlisting>ServicePermission  ..ApplicationDescriptor        REGISTER
ServicePermission  ..ApplicationHandle            REGISTER
PackagePermission  org.osgi.service.application   IMPORT</programlisting>

        <para>Additionally, an Application Container requires all the
        permissions that are needed to run the applications. This is likely to
        be All Permission.</para>
      </section>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.application.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i1519349"><title>PNG Image
      Format</title><biblioid class="uri"><link
      xlink:href="http://www.libpng.org/pub/png/"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
