<?xml version="1.0" encoding="utf-8"?>
<chapter label="56" revision="$Id$"
         version="5" xml:id="framework.weavinghooks"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Weaving Hook Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.framework.hooks.weaving-version"
    linkend="org.osgi.framework.hooks.weaving"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>Bytecode weaving is a popular technique that transforms class files
    to provide additional functionality. This is a powerful technique that,
    when used with care, can significantly reduce the coding effort for
    mundane programming chores.</para>

    <para>This specification provides a means for a handler bundle to
    intercept any bundle class loading calls in the framework, transform the
    byte codes, and add new dynamic imports. A means for observing the final
    weaving results, both before and after they take effect, is also
    provided.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Ordering</emphasis> - Allow a weaver to weave a
          bundle before it is loaded and used.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dynamic Imports</emphasis> - Support additional
          imports.</para>
        </listitem>

        <listitem>
          <para><emphasis>Strategy</emphasis> - Support both Static and
          Dynamic Weaving strategies.</para>
        </listitem>

        <listitem>
          <para><emphasis>No Metadata</emphasis> - Allow standard bundles,
          without any specific metadata, to be woven.</para>
        </listitem>

        <listitem>
          <para><emphasis>Java API</emphasis> - Use the existing Java byte
          code transformation APIs where possible.</para>
        </listitem>

        <listitem>
          <para><emphasis>Multiple</emphasis> - Allow for multiple weavers per
          bundle in a defined order.</para>
        </listitem>

        <listitem>
          <para><emphasis>Observation</emphasis> - Allow woven class state
          transitions to be observed.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Weaving Hook</emphasis> - A service registered by a
          bundle that wants to weave other bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Woven Class</emphasis> - An object representing the
          class to be woven.</para>
        </listitem>

        <listitem>
          <para><emphasis>Woven Class Listener</emphasis> - A service
          registered by a bundle that wants to observe woven class state
          transitions.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Byte Code Weaving</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.437in"
                       contentwidth="4.959in"
                       fileref="weavinghooks-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Usage</title>

    <section>
      <title>Tracing</title>

      <para>For tracing purposes, a bundle can weave a trace entry and exit
      message around each method. This is trivial to do with byte code weaving
      by inserting a call to a service at the beginning and end of a method.
      In this example, a service is created that has two methods:</para>

      <itemizedlist>
        <listitem>
          <para><code>trace(Bundle)</code> - Byte code weave the given bundle
          with trace entry and exit methods.</para>
        </listitem>

        <listitem>
          <para><code>untrace(Bundle)</code> - Remove any weavings.</para>
        </listitem>
      </itemizedlist>

      <para>The strategy chosen here is simple. The weaver registers a Weaving
      Hook service so it receives all class loads. Any such class load is
      checked against a list of bundles that needs tracing, any class from a
      traced bundle is then woven with the trace information. If a bundle is
      traced, the list is set up and the bundle is refreshed to ensure all
      classes are loaded anew so the tracing code can be woven in.</para>

      <programlisting>public class Example implements WeavingHook{
    final Map&lt;Bundle,BundleWiring&gt; bundles = new HashMap&lt;Bundle,BundleWiring&gt;();
    final List&lt;String&gt; imports = Arrays.asList(
        "com.acme.trace;version=\"[1,2)\""); 
    BundleContext context;</programlisting>

      <para>The <code>weave</code> method is the service method of the Weaving
      Hook service. It receives a <code>WovenClass</code> object that provides
      the information about the class to be woven. In this case, the
      <code>bundles</code> field contains the bundles to be woven, so this is
      checked first. If the to be loaded class is in one of the traced
      bundles, the byte codes are changed to provide trace information.
      Otherwise the request is ignored.</para>

      <para>In general, weaving code will require new imports for the
      to-be-woven bundle. These imports can be added by adding Dynamic Import
      Package statements to the list received from the
      <code>getDynamicImports</code> method. This is a list of
      <code>String</code> objects, the syntax of each string is equal to a
      clause in the DynamicImport-Package header, see <xref
      linkend="framework.module.dynamicimportpackage"/> for the exact
      syntax.</para>

      <programlisting>    public void weave(WovenClass classInfo) {
        BundleWiring bw = classInfo.getBundleWiring(); 
        Bundle b = bw.getBundle(); 
        if (bundles.contains(b)) {
            byte [] woven = weaveTracing(classInfo.getBytes());
            if (!classInfo.getDynamicImports()
                    .containsAll(imports))
                classInfo.getDynamicImports().addAll(imports);
            classInfo.setBytes(woven);
        }
    }</programlisting>

      <para>The following <code>trace</code> method is called when a bundle
      must be traced. It ignores the request if the bundle is already traced.
      Otherwise, it will add the bundle to the list of traced bundles and
      refresh the bundle.</para>

      <programlisting>    public synchronized void trace(Bundle b) 
        throws BundleException {

        if (!bundles.containsKey(b))
            return;

        BundleWiring bw = b.adapt(BundleWiring.class);
        bundles.put(b, bw);
        refresh(b);
    }</programlisting>

      <para>The <code>untrace</code> method is the reverse:</para>

      <programlisting>    public synchronized void untrace(Bundle b) 
        throws BundleException {
        if (!bundles.containsKey(b))
            return;

        bundles.remove(b);
        refresh(b);
    }</programlisting>

      <para>The refresh method uses the Bundle Wiring API to refresh a bundle.
      Refreshing a bundle will throw away its class loader so that all used
      classes are reloaded when needed.</para>

      <programlisting>    private void refresh(Bundle b) {
        Bundle fwb = context.getBundle(0);
        FrameworkWiring fw = fwb.adapt(FrameworkWiring.class);
        fw.refreshBundles(Arrays.asList(b));
    }</programlisting>

      <para>The trace method that does the final weaving is left as an
      exercise to the reader:</para>

      <programlisting>    byte[] trace(byte [] bytes) {
        ..
    }       
}</programlisting>
    </section>

    <section>
      <title>Isolation</title>

      <para>The Framework Hooks API allows bundles to be separated into
      various regions isolated by sharing policies. The dynamic imports added
      in the tracing example will need to be taken into account by the sharing
      policies of regions containing bundles whose classes were woven in order
      for the bundles to resolve. This can be accomplished using a Woven Class
      Listener. A Weaving Hook would not be acceptable since there is no
      guarantee that the list of dynamic imports is final.</para>

      <para>The region registers a Woven Class Listener service so it receives
      notifications of Woven Class state transitions. The sharing policy of
      the region containing the bundle whose class was woven is updated with
      the dynamic imports, if any. This action occurs while the Woven Class is
      in the TRANSFORMED state to ensure the region is prepared to accept the
      imports before the bundle wiring is updated upon entering the DEFINED
      state. The region is initialized with the set of bundles composing it
      and a static sharing policy consisting of namespaces mapped to sets of
      filters indicating the allowed capabilities.</para>

      <programlisting>public class Region implements WovenClassListener, ResolverHook {
    final Set&lt;Bundle&gt; bundles;
    final Map&lt;String, Set&lt;Filter&gt;&gt; policy;</programlisting>

      <para>The <code>modified</code> method is the service method of the
      Woven Class Listener service. It receives a Woven Class object that
      provides the information about the woven class that underwent a state
      transition. If the current state is TRANSFORMED, and the associated
      bundle is part of the region, the sharing policy is updated with the
      additional dynamic imports, if any.</para>

      <programlisting>    public void modified(WovenClass wovenClass) {
        if (wovenClass.getState() == WovenClass.TRANSFORMED) {
            Bundle bundle = wovenClass.getBundleWiring().getBundle();
            if (!bundles.contains(bundle))
                return;
            Set&lt;Filter&gt; filters = policy.get(PackageNamespace.PACKAGE_NAMESPACE);
            synchronized (filters) {
                for (String dynamicImport : wovenClass.getDynamicImports())
                    filters.add(toFilter(dynamicImport));
            }
        }
    }</programlisting>

      <para>The region also implements <code>ResolverHook</code>. When the
      <code>filterMatches</code> method is called, the requirement is
      inspected to see if its matching capabilities are allowed into the
      region. If not, the list of candidates is cleared.</para>

      <programlisting>    public void filterMatches(BundleRequirement requirement, 
            Collection&lt;BundleCapability&gt; candidates) {
        Bundle bundle = requirement.getRevision().getBundle();
        if (!bundles.contains(bundle))
            return;
        String namespace = requirement.getNamespace();
        if (!policy.containsKey(namespace))
            return;
        Map&lt;String, String&gt; directives = requirement.getDirectives();
        String filter = directives.get(
            PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE);
        Set&lt;Filter&gt; filters = policy.get(namespace);
        synchronized (filters) {
            if (!filters.contains(toFilter(filter)))
                candidates.clear();
        }
    }</programlisting>

      <para>The toFilter method responsible for converting the requirement
      filters and dynamic import package headers into a Filter is left as an
      exercise to the reader.</para>

      <programlisting>    private Filter toFilter(String s) {
        ...
  }
}</programlisting>
    </section>
  </section>

  <section>
    <title>The Weaving Service</title>

    <para>The Weaving Hook service is a white board service; any party that
    wants to participate in weaving classes can register such a service. The
    framework picks up the Weaving Hook services and calls their
    <code>weave</code> method for each class that must be loaded. The weave
    methods must be called in the service ranking order, see <xref
    linkend="framework.service.servicerankingorder"/>.</para>

    <para>The Weaving Hook <code>weave</code> method is called with a
    <code>WovenClass</code> object that represents the class to be woven. This
    class is similar to the Java <code>ClassFileTransformer</code> class but
    adds bundle wiring information and can be made available in environments
    prior to Java 5. The methods must all be called in privileged blocks, see
    <xref linkend="framework.lifecycle.privilegedcallbacks"/>.</para>

    <para>The <code>WovenClass</code> object provides access to:</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.framework.hooks.weaving.WovenClass.getClassName--"
        xrefstyle="hyperlink"/> - The name of the class being loaded,</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.framework.hooks.weaving.WovenClass.getBundleWiring--"
        xrefstyle="hyperlink"/> - The bundle wiring, which provides access to
        the bundle, the bundle class loaders and the capabilities.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.framework.hooks.weaving.WovenClass.getProtectionDomain--"
        xrefstyle="hyperlink"/> - The protection domain it is being defined
        in, and</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.framework.hooks.weaving.WovenClass.getBytes--"
        xrefstyle="hyperlink"/> - The class bytes to be defined.</para>
      </listitem>
    </itemizedlist>

    <para>A Weaving Hook service can use the <code>WovenClass</code> object to
    decide to weave or not to weave. This decision can be based on the bundle
    wiring, the class name, the protection domain, or the bytes. For example,
    the following code checks if the class comes from a specific
    bundle:</para>

    <programlisting>if (wovenClass.getBundleWiring().getBundle()== mybundle)
  ...</programlisting>

    <para>If the Weaving Hook service decides to weave the class, it must
    calculate new bytes for the provided Woven Class, these bytes can be set
    with the <xref
    linkend="org.osgi.framework.hooks.weaving.WovenClass.setBytes-byte---"
    xrefstyle="hyperlink"/> method. This implies that ordering is relevant.
    Weaving Hook services that are lower in ranking (called later) will weave
    any of the changes of higher ranking Weaving Hook services. Not all
    combinations of Weaving Hook services will therefore work as
    expected.</para>

    <para>Weaving a class can create new dependencies that are unknown to the
    woven class. In the trace example, the entry and exit traces require
    access to the tracing subsystem, a dependency the original class did not
    have. The <code>WovenClass</code> object allows these extra imports to be
    added as new dynamic import package clauses. The current set of dynamic
    imports for the Woven Class is available from the <code>WovenClass</code>
    <xref
    linkend="org.osgi.framework.hooks.weaving.WovenClass.getDynamicImports--"
    xrefstyle="hyperlink"/> method. This method returns a mutable list of
    <code>String</code> during the <code>weave</code> method, the Weaving Hook
    service can add new dynamic import package clauses to this list while the
    <code>weave</code> method is active. The syntax of the strings is defined
    by the DynamicImport-Package header, see <xref
    linkend="framework.module.dynamicimportpackage"/>. The dynamic imports
    must have a valid syntax, otherwise an Illegal Argument Exception must be
    thrown. These dynamically added dependencies are made visible through the
    <xref linkend="framework.wiring"/> as new requirements. The
    <code>getRevision</code> method of these requirements must return the
    Bundle Revision of the bundle that is woven; that revision will not
    include these synthetic requirements in the
    <code>getDeclaredRequirements</code> method.</para>

    <para>Dynamic imports are the last resort for the framework to find a
    provider when the normal imports fail. The woven class dynamic imports are
    consulted after the dynamic imports specified in the bundle's manifest.
    Frameworks must append all additional dynamic imports in the given order
    but are expected to filter out duplicates for performance reasons.</para>

    <para>The management of the dynamic import is error prone and should be
    handled with care because dynamic imports use wildcards. Wildcards make
    the ordering of the imports important. In the pathological case, a full
    wildcard in the beginning (for example in the manifest) will void any more
    specific clauses that were added by Handlers. Handlers should be as
    specific as possible when adding dynamic import clauses.</para>

    <para>In many cases the additional imports must refer to classes that the
    Handler is already resolved to. In an OSGi framework, the same package can
    be present multiple times. A Handler should therefore ensure that the
    woven bundle gets wired to the correct bundle. One way to achieve this is
    to include the bundle-version and bundle-symbolic-name synthetic
    attributes that are available on every exported package.</para>

    <programlisting>com.acme.weavesupport.core;version=1.2;bundle-version=3.2; <code>Â«</code>
    bundle-symbolic-name=com.acme.weavesupport</programlisting>

    <para>After calling the last Weaving Hook service, the
    <code>WovenClass</code> object is made <emphasis>complete</emphasis>. The
    framework must make the <code>WovenClass</code> object immutable when it
    is complete. After the Woven Class is complete, the current bytes are then
    used to define the new class. Attempts to modify it, or any of its
    properties, must throw an Exception. After completion, the <xref
    linkend="org.osgi.framework.hooks.weaving.WovenClass.getBytes--"
    xrefstyle="hyperlink"/> method must return a copy of the byte array that
    was used to define the class.</para>

    <section>
      <title>Concurrency</title>

      <para>Class loads can occur at any time and Weaving Hook services must
      be able to handle concurrent as well as re-entrant calls to the weave
      method. The framework should not hold any locks when calling the Weaving
      Hook services, and Weaving Hook service implementations must be
      thread-safe. Furthermore Weaving Hook services may be re-entrant, and
      should be careful to avoid cycles when weaving.</para>

      <para>For example when a class is being woven the Weaving Hook may
      implicitly load a class by having a reference to it or the Weaving Hook
      can explicitly load a class. This new class load will also pass through
      the Weaving Hook service, so care must be taken to avoid infinite
      looping.</para>
    </section>

    <section>
      <title>Error Handling</title>

      <para>Weaving hooks are very low level and care must be taken by the
      Weaving Hook services to not disrupt normal class loading. In the case
      that a weaving hook throws an unexpected exception the framework must do
      the following:</para>

      <orderedlist>
        <listitem>
          <para>If the exception is not a Weaving Exception:</para>

          <itemizedlist>
            <listitem>
              <para>The framework must blacklist the weaving hook registration
              and never call that Weaving Hook service again as long as it is
              registered. This Weaving Hook service is considered
              <emphasis>blacklisted</emphasis>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>A framework event of type <code>ERROR</code> should be
          published that must include the Exception thrown by the Weaving Hook
          service. The source must be the bundle registering the Weaving Hook
          service.</para>
        </listitem>

        <listitem>
          <para>The <code>WovenClass</code> object must be marked as complete.
          All remaining Weaving Hook services must be skipped.</para>
        </listitem>

        <listitem>
          <para>The bundle class loader must throw a
          <code>ClassFormatError</code> with the cause being the exception
          thrown by the Weaving Hook service.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>The Woven Class Listener Service</title>

    <para>The Woven Class Listener service is a white board service; any party
    that wants to receive notifications of woven class state transitions can
    register such a service. The framework picks up the Woven Class Listener
    services and calls their <code>modified</code> method whenever a woven
    class undergoes a state transition.</para>

    <para>The Woven Class Listener <code>modified</code> method is called with
    a <code>WovenClass</code> object that represents the woven class that
    underwent a state transition. The method must be called in a privileged
    block, see <xref
    linkend="framework.lifecycle.privilegedcallbacks"/>.</para>

    <para>The following diagram depicts the state transitions of a Woven
    Class.</para>

    <figure>
      <title>Woven Class State Diagram</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.017in"
                     contentwidth="7.125in" fileref="wovenClass-states.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Woven class listeners are not notified of the TRANSFORMING state
    because the woven class is mutable and listeners are read-only. In all
    states received by woven class listeners, the woven class is immutable.
    The first notification received for a given woven class is either the
    TRANSFORMED or TRANSFORMING_FAILED state. TRANSFORMED occurs after all
    weaving hooks have been notified but before the class has been defined or
    the bundle wiring updated as a result of additional dynamic imports.
    TRANSFORMING_FAILED occurs instead if a weaving hook threw an exception.
    After TRANSFORMED comes either DEFINED or DEFINE_FAILED. DEFINED is
    received is the class was defined successfully and after the bundle wiring
    has been updated. DEFINE_FAILED occurs instead if a class definition error
    occurred.</para>

    <para>The following table describes the state transitions of a Woven Class
    in more detail.</para>

    <table>
      <title>Woven Class State Table</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth="1*"/>

        <colspec colnum="2" colwidth="1*"/>

        <colspec colnum="3" colwidth="2*"/>

        <thead>
          <row>
            <entry>Source State</entry>

            <entry>Target State</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><para>-</para></entry>

            <entry><para>TRANSFORMING</para></entry>

            <entry><para>A bundle class load request was made.</para>
            <itemizedlist>
                <listitem>
                  <para>Weaving is incomplete.</para>
                </listitem>

                <listitem>
                  <para>The class is undefined.</para>
                </listitem>

                <listitem>
                  <para>The woven class is mutable.</para>
                </listitem>

                <listitem>
                  <para>Weaving hooks are notified but woven class listeners
                  are not.</para>
                </listitem>
              </itemizedlist></entry>
          </row>

          <row>
            <entry><para>TRANSFORMING</para></entry>

            <entry><para>TRANSFORMED</para></entry>

            <entry><para>All weaving hooks have been notified.</para>
            <itemizedlist>
                <listitem>
                  <para>Weaving is incomplete.</para>
                </listitem>

                <listitem>
                  <para>The class is undefined.</para>
                </listitem>

                <listitem>
                  <para>The woven class is immutable.</para>
                </listitem>

                <listitem>
                  <para>Woven class listeners are notified.</para>
                </listitem>
              </itemizedlist></entry>
          </row>

          <row>
            <entry><para>TRANSFORMING</para></entry>

            <entry><para>TRANSFORMING FAILED</para></entry>

            <entry><para>A weaving hook threw an exception.</para>
            <itemizedlist>
                <listitem>
                  <para>Weaving is incomplete.</para>
                </listitem>

                <listitem>
                  <para>The class is undefined.</para>
                </listitem>

                <listitem>
                  <para>The woven class is immutable.</para>
                </listitem>

                <listitem>
                  <para>Woven class listeners are notified.</para>
                </listitem>
              </itemizedlist></entry>
          </row>

          <row>
            <entry><para>TRANSFORMED</para></entry>

            <entry><para>DEFINED</para></entry>

            <entry><para>All woven class listeners have been notified. The
            class has been defined.</para> <itemizedlist>
                <listitem>
                  <para>Weaving is incomplete.</para>
                </listitem>

                <listitem>
                  <para>The class is defined.</para>
                </listitem>

                <listitem>
                  <para>The woven class is immutable.</para>
                </listitem>

                <listitem>
                  <para>Woven class listeners are notified.</para>
                </listitem>
              </itemizedlist></entry>
          </row>

          <row>
            <entry><para>TRANSFORMED</para></entry>

            <entry><para>DEFINE FAILED</para></entry>

            <entry><para>All weaving hooks have been notified. A class
            definition failure occurred.</para> <itemizedlist>
                <listitem>
                  <para>Weaving is incomplete.</para>
                </listitem>

                <listitem>
                  <para>The class is undefined.</para>
                </listitem>

                <listitem>
                  <para>The woven class is immutable.</para>
                </listitem>

                <listitem>
                  <para>Woven class listeners are notified.</para>
                </listitem>
              </itemizedlist></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section>
      <title>Concurrency</title>

      <para>Class loads can occur at any time, and Woven Class Listener
      services must be able to handle concurrent calls to the <code>modified
      </code> method. The framework should not hold any locks when calling
      Woven Class Listener services, and Woven Class Listener service
      implementations must be thread-safe. Woven class listeners must be
      synchronously called by the framework when a woven class completes a
      state transition. The woven class processing will not proceed until all
      woven class listeners are done.</para>
    </section>

    <section>
      <title>Error Handling</title>

      <para>Woven Class Listeners must not cause the weaving process to fail.
      If a Woven Class Listener throws an exception, the framework should log
      the exception but otherwise ignore it.</para>
    </section>
  </section>

  <section>
    <title>Security</title>

    <section>
      <title>Weaving Hooks</title>

      <para>All hooks described in this specification are highly complex
      facilities that require great care in their implementation to maintain
      the Framework invariants concerning the service registry. It is
      therefore important that in a secure system the permission to register
      these hooks is only given to privileged bundles.</para>

      <para>In this case, the user of the hook services is the framework.
      Therefore, there is never a need to provide:</para>

      <itemizedlist>
        <listitem>
          <para><code>ServicePermission[..WeavingHook,GET]</code></para>
        </listitem>
      </itemizedlist>

      <para>Implementers of these hooks must have:</para>

      <itemizedlist>
        <listitem>
          <para><code>ServicePermission[..WeavingHook,REGISTER]</code> for
          Weaving Hook services.</para>
        </listitem>
      </itemizedlist>

      <para>In addition, a Weaving Hook must have Admin Permission with the
      <code>WEAVE</code> action to be able to use the methods on the
      <code>WovenClass</code> object that mutate the state like <xref
      linkend="org.osgi.framework.hooks.weaving.WovenClass.setBytes-byte---"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.framework.hooks.weaving.WovenClass.getBytes--"
      xrefstyle="hyperlink"/>, and <xref
      linkend="org.osgi.framework.hooks.weaving.WovenClass.getDynamicImports--"
      xrefstyle="hyperlink"/> when used to modify the imports. Moreover, a
      Weaving Hook must have Package Permission with the <code>IMPORT</code>
      action in order to add or replace dynamic imports.</para>
    </section>

    <section>
      <title>Woven Bundles</title>

      <para>The Framework must grant implied <code>PackagePermission[somePkg,
      IMPORT]</code> permissions to bundles whose classes are being woven with
      additional dynamic imports, assuming the weaver has a matching package
      import permission. The permission check for the weaver must occur during
      any call to the list that results in the addition or setting of a
      dynamic import. If the check fails, a SecurityException must be thrown.
      If it succeeds, the implied permission must be granted to the woven
      bundle immediately before defining the class.</para>
    </section>

    <section>
      <title>Woven Class Listeners</title>

      <para>Implementers of these listeners must have:</para>

      <itemizedlist>
        <listitem>
          <para><code>ServicePermission[..WovenClassListener,REGISTER]</code>
          for Woven Class Listener services.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <xi:include href="../../../generated/javadoc/docbook/org.osgi.framework.hooks.weaving.xml"/>
</chapter>
