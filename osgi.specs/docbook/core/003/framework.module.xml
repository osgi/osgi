<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->

<chapter label="3" revision="$Id$"
         version="5.0" xml:id="framework.module"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Module Layer</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.framework-version"
    linkend="org.osgi.framework"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The standard Java platform provides only limited support for
    packaging, deploying, and validating Java-based applications and
    components. Because of this, many Java-based projects, such as JBoss and
    NetBeans, have resorted to creating custom module-oriented layers with
    specialized class loaders for packaging, deploying, and validating
    applications and components. The OSGi Framework provides a generic and
    standardized solution for Java modularization.</para>
  </section>

  <section>
    <title>Bundles</title>

    <para>The Framework defines a unit of modularization, called a
    <emphasis>bundle</emphasis>. A bundle is comprised of Java classes and
    other resources, which together can provide functions to end users.
    Bundles can share Java <emphasis>packages</emphasis> among an
    <emphasis>exporter</emphasis> bundle and an <emphasis>importer</emphasis>
    bundle in a well-defined way. In the OSGi framework, bundles are the only
    entities for deploying Java-based applications.</para>

    <para>A bundle is deployed as a Java ARchive (JAR) file. JAR files are
    used to store applications and their resources in a standard ZIP-based
    file format. This format is defined by <xref linkend="i3100827"/>. Bundles
    normally share the Java Archive extension of <code>.jar</code>. However,
    there is a special MIME type reserved for OSGi bundles that can be used to
    distinguish bundles from normal JAR files. This MIME type is:</para>

    <programlisting>application/vnd.osgi.bundle</programlisting>

    <para>The type is defined in <xref linkend="i3211606"/>.</para>

    <para>A bundle is a JAR file that:</para>

    <itemizedlist>
      <listitem>
        <para>Contains the resources necessary to provide some functionality.
        These resources may be class files for the Java programming language,
        as well as other data such as HTML files, help files, icons, and so
        on. A bundle JAR file can also embed additional JAR files that are
        available as resources and classes. This is however not
        recursive.</para>
      </listitem>

      <listitem>
        <para>Contains a manifest file describing the contents of the JAR file
        and providing information about the bundle. This file uses headers to
        specify information that the Framework needs to install correctly and
        activate a bundle. For example, it states dependencies on other
        resources, such as Java packages, that must be available to the bundle
        before it can run.</para>
      </listitem>

      <listitem>
        <para>Can contain optional documentation in the <code>OSGI-OPT</code>
        directory of the JAR file or one of its sub-directories. Any
        information in this directory is optional. For example, the
        <code>OSGI-OPT</code> directory is useful to store the source code of
        a bundle. Management systems may remove this information to save
        storage space in the OSGi framework.</para>
      </listitem>

      <listitem>
        <para>Can be a multi-release JAR. See <xref
        linkend="framework.module-multireleasejar"/>.</para>
      </listitem>
    </itemizedlist>

    <para>Once a bundle is resolved, its functionality is provided to other
    bundles installed in the OSGi framework.</para>

    <section xml:id="i2654895">
      <title>Bundle Manifest Headers</title>

      <para xml:id="i2654900">A bundle can carry descriptive information about
      itself in the manifest file that is contained in its JAR file under the
      name of <code>META-INF/MANIFEST.MF</code>.</para>

      <para xml:id="i3200116">The Framework defines OSGi manifest headers such
      as Export-Package and Bundle-ClassPath, which bundle developers use to
      supply descriptive information about a bundle. Manifest headers must
      strictly follow the rules for manifest headers as defined in <xref
      linkend="i3024211"/>.</para>

      <para>A Framework implementation must:</para>

      <itemizedlist xml:id="i2654913">
        <listitem>
          <para>Process the main section of the manifest. Individual sections
          of the manifest are only used during bundle signature
          verification.</para>
        </listitem>

        <listitem xml:id="i2654915">
          <para>Ignore unrecognized manifest headers. The bundle developer can
          define additional manifest headers as needed.</para>
        </listitem>

        <listitem>
          <para>Ignore unknown attributes and directives.</para>
        </listitem>
      </itemizedlist>

      <para>All specified manifest headers are listed in the following
      sections. All headers are optional, unless specifically
      indicated.</para>

      <section>
        <title>Bundle-ActivationPolicy: lazy</title>

        <para>The Bundle-ActivationPolicy specifies how the framework should
        activate the bundle once started. See <xref
        linkend="i3270439"/>.</para>
      </section>

      <section>
        <title>Bundle-Activator: com.acme.fw.Activator</title>

        <para>The Bundle-Activator header specifies the name of the class used
        to start and stop the bundle. See <xref linkend="i3270328"/>.</para>
      </section>

      <section>
        <title>Bundle-Category: osgi, test, nursery</title>

        <para>The Bundle-Category header holds a comma-separated list of
        category names.</para>
      </section>

      <section>
        <title>Bundle-ClassPath: /jar/http.jar,.</title>

        <para>The Bundle-ClassPath header defines a comma-separated list of
        JAR file path names or directories (inside the bundle) containing
        classes and resources. The full stop (<code>'.' \u002E</code>)
        specifies the root directory of the bundle's JAR. The full stop is
        also the default. See <xref
        linkend="framework.module.bundleclasspath"/>.</para>
      </section>

      <section>
        <title>Bundle-ContactAddress: 2400 Oswego Road, Austin, TX
        74563</title>

        <para>The Bundle-ContactAddress header provides the contact address of
        the vendor.</para>
      </section>

      <section>
        <title>Bundle-Copyright: OSGi (c) 2002</title>

        <para>The Bundle-Copyright header contains the copyright specification
        for this bundle.</para>
      </section>

      <section>
        <title>Bundle-Description: Network Firewall</title>

        <para>The Bundle-Description header defines a short description of
        this bundle.</para>
      </section>

      <section xml:id="framework.module-bundle-developers">
        <title>Bundle-Developers: pkriens; email=pkriens@osgi.org; name="Peter
        Kriens"; organization="OSGi Working Group"</title>

        <para>The Bundle-Developers header provides an optional machine
        readable form of information about the developers of the bundle. This
        header is purely informational and must not be processed by the OSGi
        Framework.</para>

        <para>The syntax for this header is as follows:</para>

        <programlisting>Bundle-Developers ::= developer ( ',' developer ) *
developer         ::= identifier ( ';' developer-attr ) *
identifier        ::= argument
developer-attr    ::= email | name | url | organization | 
                        organization-url | roles | timezone
email             ::= 'email' '=' &lt;email&gt;
name              ::= 'name' '=' argument
url               ::= 'url' '=' &lt;url&gt;
organization      ::= 'organization' '=' argument
organization-url  ::= 'organizationUrl' '=' &lt;url&gt;
roles             ::= 'roles' '=' argument
timezone          ::= 'timezone' '=' argument</programlisting>

        <para>This header has the following attributes:</para>

        <itemizedlist>
          <listitem>
            <para><code>email</code> - (optional) The email address of the
            developer.</para>
          </listitem>

          <listitem>
            <para><code>name</code> - (optional) The name of the
            developer.</para>
          </listitem>

          <listitem>
            <para><code>url</code> - (optional) The URL of the
            developer.</para>
          </listitem>

          <listitem>
            <para><code>organization</code> - (optional) The name of the
            organization of the developer.</para>
          </listitem>

          <listitem>
            <para><code>organization-url</code> - (optional) The URL of the
            organization of the developer.</para>
          </listitem>

          <listitem>
            <para><code>roles</code> - (optional) The roles of the developer.
            This is a comma separated list of role names.</para>
          </listitem>

          <listitem>
            <para><code>timezone</code> - (optional) The time zone of where
            the developer resides. The time zone can be an id such as
            <code>America/New_York</code> or a numerical offset in hours from
            UTC.</para>
          </listitem>
        </itemizedlist>

        <para>See <xref linkend="framework.module-maven.pom.developers"/> for
        more information. Tools can use the information in this header for POM
        generation.</para>
      </section>

      <section>
        <title>Bundle-DocURL: http://www.example.com/Firewall/doc</title>

        <para>The Bundle-DocURL headers must contain a URL pointing to
        documentation about this bundle.</para>
      </section>

      <section xml:id="i3216245">
        <title>Bundle-Icon: /icons/acme-logo.png;size=64</title>

        <para>The optional Bundle-Icon header provides a list of URLs to icons
        representing this bundle in different sizes. The following attribute
        is permitted:</para>

        <itemizedlist>
          <listitem>
            <para><code>size</code> - (integer) Specifies the size of the icon
            in pixels horizontal. It is recommended to always include a 64x64
            icon.</para>
          </listitem>
        </itemizedlist>

        <para>The URLs are interpreted as relative to the bundle. That is, if
        a URL with a scheme is provided, then this is taken as an absolute
        URL. Otherwise, the path points to an entry in the JAR file, taking
        any attached fragments into account. Implementations that want to use
        this header should at least support the Portable Network Graphics
        (PNG) format, see <xref linkend="i3219167"/>.</para>
      </section>

      <section xml:id="framework.module-bundle-license">
        <title>Bundle-License: Apache-2.0;
        link="http://opensource.org/licenses/apache2.0.php"</title>

        <para>The Bundle-License header provides an optional machine readable
        form of license information. The purpose of this header is to automate
        some of the license processing required by many organizations like for
        example license acceptance before a bundle is used. The header is
        structured to provide the use of unique license naming to merge
        acceptance requests, as well as links to human readable information
        about the included licenses. This header is purely informational for
        management agents and must not be processed by the OSGi
        Framework.</para>

        <para>The syntax for this header is as follows:</para>

        <programlisting>Bundle-License ::= '&lt;&lt;EXTERNAL&gt;&gt;' | 
                      ( license ( ',' license ) * )
license        ::= license-identifier ( ';' license-attr ) *
license-attr   ::= description | link
description    ::= 'description' '=' string
link           ::= 'link' '=' &lt;url&gt;</programlisting>

        <para>This header has the following attributes:</para>

        <itemizedlist>
          <listitem>
            <para><code>license-identifier</code> - Provides a globally unique
            identifier for this license, preferably world wide, but it should
            at least be unique with respect to the other clauses. The magic
            identifier <code>&lt;&lt;EXTERNAL&gt;&gt;</code> is used to
            indicate that this artifact does not specify any license
            information but that licensing information is provided in some
            other way. This is also the default value of this header.</para>

            <para>This identifier should be one of the identifiers defined by
            <xref linkend="framework.module-spdx.license.list"/>. Clients of
            this bundle can assume that licenses with the same identifier
            refer to the same license. This can for example be used to
            minimize the click through licenses.</para>

            <para>Alternatively, the identifier can be the canonical URL of
            the license, it must not be localized by the translator. This URL
            does not have to exist but must not be used for later versions of
            the license. It is recommended to use URLs from <xref
            linkend="i3222193"/>. Other licenses should use the following
            structure, but this is not mandated:</para>

            <programlisting>http://&lt;domain-name&gt;/licenses/
          &lt;license-name&gt;-&lt;version&gt;.&lt;extension&gt;</programlisting>
          </listitem>

          <listitem>
            <para><code>description</code> - (optional) Provide the
            description of the license. This is a short description that is
            usable in a list box on a UI to select more information about the
            license.</para>
          </listitem>

          <listitem>
            <para><code>link</code> - (optional) Provide a URL to a page that
            defines or explains the license. If this link is absent, the name
            field is used for this purpose. The URL is relative to the root of
            the bundle. That is, it is possible to refer to a file inside the
            bundle.</para>
          </listitem>
        </itemizedlist>

        <para>If the Bundle-License statement is absent, then this does not
        mean that the bundle is not licensed. Licensing could be handled
        outside the bundle and the <code>&lt;&lt;EXTERNAL&gt;&gt;</code> form
        should be assumed. This header is informational and may not have any
        legal bearing. Consult a lawyer before using this header to automate
        licensing processing.</para>
      </section>

      <section xml:id="i3189740">
        <title>Bundle-Localization: OSGI-INF/l10n/bundle</title>

        <para>The Bundle-Localization header contains the location in the
        bundle where localization files can be found. The default value is
        <code>OSGI-INF/l10n/bundle</code>. Translations are by default
        therefore <code>OSGI-INF/l10n/bundle_de.properties</code>,
        <code>OSGI-INF/l10n/bundle_nl.properties</code>, etc. See <xref
        linkend="i3189742"/>.</para>
      </section>

      <section>
        <title>Bundle-ManifestVersion: 2</title>

        <para>The Bundle-ManifestVersion header defines that the bundle
        follows the rules of this specification. The Bundle-ManifestVersion
        header determines whether the bundle follows the rules of this
        specification. It is 1 (the default) for Release 3 Bundles, 2 for
        Release 4 and later. Future version of the OSGi framework can define
        higher numbers for this header.</para>
      </section>

      <section>
        <title>Bundle-Name: Firewall</title>

        <para>The Bundle-Name header defines a readable name for this bundle.
        This should be a short, human-readable name that can contain
        spaces.</para>
      </section>

      <section>
        <title>Bundle-NativeCode: /lib/http.DLL; osname = QNX; osversion =
        3.1</title>

        <para>The Bundle-NativeCode header contains a specification of native
        code libraries contained in this bundle. See <xref
        linkend="framework.module-loading.native.code.libraries"/>.</para>
      </section>

      <section>
        <title>Bundle-RequiredExecutionEnvironment:
        CDC-1.0/Foundation-1.0</title>

        <para>The Bundle-RequiredExecutionEnvironment contains a
        comma-separated list of execution environments that must be present on
        the OSGi framework. See <xref
        linkend="framework.module-execution.environment"/>. This header is
        deprecated.</para>
      </section>

      <section xml:id="framework.module-bundle-scm">
        <title>Bundle-SCM: url=https://github.com/bndtools/bnd,
        connection=scm:git:https://github.com/bndtools/bnd.git,
        developerConnection=scm:git:git@github.com:bndtools/bnd.git</title>

        <para>The Bundle-SCM header provides an optional machine readable form
        of information about the source code of the bundle. This header is
        purely informational and must not be processed by the OSGi
        Framework.</para>

        <para>The syntax for this header is as follows:</para>

        <programlisting>Bundle-SCM           ::= scm-attr ( ',' scm-attr ) *
scm-attr             ::= url | connection | developer-connection | tag
url                  ::= 'url' '=' &lt;url&gt;
connection           ::= 'connection' '=' &lt;uri&gt;
developer-connection ::= 'developerConnection' '=' &lt;uri&gt;
tag                  ::= 'tag' '=' argument</programlisting>

        <para>This header has the following attributes:</para>

        <itemizedlist>
          <listitem>
            <para><code>url</code> - (optional) The URL to browse the source
            code repository.</para>
          </listitem>

          <listitem>
            <para><code>connection</code> - (optional) The <code>scm:</code>
            URI for read access to the source code repository.</para>
          </listitem>

          <listitem>
            <para><code>developer-connection</code> - (optional) The
            <code>scm:</code> URI for write access to the source code
            repository.</para>
          </listitem>

          <listitem>
            <para><code>tag</code> - (optional) The tag within the source code
            repository.</para>
          </listitem>
        </itemizedlist>

        <para>See <xref linkend="framework.module-maven.pom.scm"/> for more
        information. Tools can use the information in this header for POM
        generation.</para>
      </section>

      <section>
        <title>Bundle-SymbolicName: com.acme.daffy</title>

        <para>The Bundle-SymbolicName header specifies a non-localizable name
        for this bundle. The bundle symbolic name together with a version must
        identify a unique bundle though it can be installed multiple times in
        a framework. The bundle symbolic name should be based on the reverse
        domain name convention, see <xref linkend="framework.module.bsn"/>.
        This header must be set.</para>
      </section>

      <section>
        <title>Bundle-UpdateLocation:
        http://www.acme.com/Firewall/bundle.jar</title>

        <para>The Bundle-UpdateLocation header specifies a URL where an update
        for this bundle should come from. If the bundle is updated, this
        location should be used, if present, to retrieve the updated JAR
        file.</para>
      </section>

      <section>
        <title>Bundle-Vendor: OSGi Working Group</title>

        <para>The Bundle-Vendor header contains a human-readable description
        of the bundle vendor.</para>
      </section>

      <section>
        <title>Bundle-Version: 1.1</title>

        <para>The Bundle-Version header specifies the version of this bundle.
        See <xref linkend="i2655136"/>. The default value is
        <code>0.0.0</code></para>
      </section>

      <section>
        <title>DynamicImport-Package: com.acme.plugin.*</title>

        <para>The DynamicImport-Package header contains a comma-separated list
        of package names that should be dynamically imported when needed. See
        <xref linkend="framework.module.dynamicimportpackage"/>.</para>
      </section>

      <section>
        <title>Export-Package: org.osgi.util.tracker;version=1.3</title>

        <para>The Export-Package header contains a declaration of exported
        packages. See <xref linkend="framework.module.exportpackage"/>.</para>
      </section>

      <section>
        <title>Export-Service: org.osgi.service.log.LogService</title>

        <para>Deprecated.</para>
      </section>

      <section>
        <title>Fragment-Host: org.eclipse.swt;
        bundle-version="[3.0.0,4.0.0)"</title>

        <para>The Fragment-Host header defines the host bundles for this
        fragment. See <xref linkend="framework.module.fragmenthost"/></para>
      </section>

      <section>
        <title>Import-Package:
        org.osgi.util.tracker,org.osgi.service.log;version=1.4</title>

        <para>The Import-Package header declares the imported packages for
        this bundle. See <xref
        linkend="framework.module.importpackage"/>.</para>
      </section>

      <section>
        <title>Import-Service: org.osgi.service.log.LogService</title>

        <para>Deprecated</para>
      </section>

      <section>
        <title>Provide-Capability: com.acme.dict; from=nl; to=de;
        version:Version=1.2</title>

        <para>Specifies that a bundle provides a set of Capabilities, see
        <xref linkend="framework.module.dependencies"/>.</para>
      </section>

      <section>
        <title>Require-Bundle: com.acme.chess</title>

        <para>The Require-Bundle header specifies that all exported packages
        from another bundle must be imported, effectively requiring the public
        interface of another bundle. See <xref
        linkend="framework.module.requirebundle"/></para>
      </section>

      <section>
        <title>Require-Capability: osgi.ee;
        filter:="(&amp;(osgi.ee=AcmeMin)(version=1.1))"</title>

        <para>Specifies that a bundle requires other bundles to provide a
        capability, see <xref
        linkend="framework.module.dependencies"/>.</para>
      </section>
    </section>

    <section xml:id="i3224842">
      <title>Custom Headers</title>

      <para>The manifest is an excellent place to provide metadata belonging
      to a bundle. This is true for the OSGi Working Group but it is also valid for
      other organizations. For historic reasons, the OSGi Working Group claims the
      default namespace, specifically headers that indicate OSGi related
      matters like names that contain Bundle, Import, Export, etc.
      Organizations that want to use headers that do not clash with OSGi
      Working Group defined names or bundle header names from other organizations
      should prefix custom headers with <code>x-</code>, for example
      <code>x-LazyStart</code>.</para>

      <para>Organizations external to the OSGi Working Group can request header
      names in the OSGi namespace. The OSGi Working Group maintains a registry of
      such names at <xref linkend="i3215677"/>.</para>

      <para>The <xref linkend="org.osgi.annotation.bundle.Header"
      xrefstyle="hyperlink"/> annotation can be used on a class or package to
      specify a header for a bundle. This annotation can be processed by
      bundle assembly tools to generate the specified header information in
      the bundle's manifest.</para>
    </section>

    <section>
      <title>Header Value Syntax</title>

      <para>Each Manifest header has its own syntax. In all descriptions, the
      syntax is defined with <xref linkend="i3024215"/>. These following
      sections define a number of commonly used terminals.</para>
    </section>

    <section xml:id="framework.common.header.syntax">
      <title>Common Header Syntax</title>

      <para>Many Manifest header values share a common syntax. This syntax
      consists of:</para>

      <programlisting>header ::= clause ( ',' clause ) *
clause ::= path ( ';' path ) *  
              ( ';' parameter ) *     // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/></programlisting>

      <para>A parameter can be either a <emphasis>directive</emphasis> or an
      <emphasis>attribute</emphasis>. A directive is an instruction that has
      some implied semantics for the Framework. An attribute is used for
      matching and comparison purposes.</para>
    </section>

    <section xml:id="i2655136">
      <title>Version</title>

      <para>Version specifications are used in several places. A version has
      the following grammar:</para>

      <programlisting>version     ::= 
        major( '.' minor ( '.' micro ( '.' qualifier )? )? )?

major       ::= number                   // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/>
minor       ::= number
micro       ::= number
qualifier   ::= ( alphanum | '_' | '-' )+</programlisting>

      <para>A version must not contain any white space. The default value for
      a version is <code>0.0.0</code>.</para>

      <para>Versions are supported in the API with the <xref
      linkend="org.osgi.framework.Version" xrefstyle="hyperlink"/>
      class.</para>

      <para>The <xref linkend="org.osgi.annotation.versioning.Version"
      xrefstyle="hyperlink"/> annotation can be used in
      <code>package-info.java</code> source files to document the version of a
      package. This annotation can be processed by bundle assembly tools when
      generating the version information for a bundle's Export-Package
      manifest header.</para>
    </section>

    <section xml:id="i3189032">
      <title>Version Ranges</title>

      <para>A version range describes a range of versions using a mathematical
      interval notation. See <xref linkend="i3024221"/>. The syntax of a
      version range is:</para>

      <programlisting>version-range ::= interval | atleast
interval      ::= ( '[' | '(' ) floor ',' ceiling ( ']' | ')' )
atleast       ::= version
floor         ::= version
ceiling       ::= version</programlisting>

      <para>If a version range is specified as a single version, it must be
      interpreted as the range <code>[version,</code><phrase
      role="symbol">∞</phrase><code>)</code>. The default for a non-specified
      version range is 0, which maps to <code>[0.0.0,</code><phrase
      role="symbol">∞</phrase><code>)</code>.</para>

      <para>Note that the use of a comma in the version range requires it to
      be enclosed in double quotes. For example:</para>

      <programlisting>Import-Package: com.acme.foo;version="[1.23,2)", «
   com.acme.bar;version="[4.0, 5.0)"</programlisting>

      <para>In the following table, for each specified range in the left-hand
      column, a version <emphasis>x</emphasis> is considered to be a member of
      the range if the predicate in the right-hand column is true.</para>

      <table>
        <title>Examples of version ranges</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="4*"/>

          <thead>
            <row>
              <entry>Example</entry>

              <entry>Predicate</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><code>[1.2.3, 4.5.6)</code></para></entry>

              <entry><para><code>1.2.3 &lt;= x &lt;
              4.5.6</code></para></entry>
            </row>

            <row>
              <entry><para><code>[1.2.3, 4.5.6]</code></para></entry>

              <entry><para><code>1.2.3 &lt;= x &lt;=
              4.5.6</code></para></entry>
            </row>

            <row>
              <entry><para><code>(1.2.3, 4.5.6)</code></para></entry>

              <entry><para><code>1.2.3 &lt; x &lt; 4.5.6</code></para></entry>
            </row>

            <row>
              <entry><para><code>(1.2.3, 4.5.6]</code></para></entry>

              <entry><para><code>1.2.3 &lt; x &lt;=
              4.5.6</code></para></entry>
            </row>

            <row>
              <entry><para><code>1.2.3</code></para></entry>

              <entry><para><code>1.2.3 &lt;= x</code></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Version Ranges are supported in the API with the <xref
      linkend="org.osgi.framework.VersionRange" xrefstyle="hyperlink"/>
      class.</para>
    </section>

    <section xml:id="framework.module.filtersyntax">
      <title>Filter Syntax</title>

      <para>The OSGi specifications use filter expressions extensively. Filter
      expressions allow for a concise description of a
      <emphasis>constraint</emphasis>. The syntax of a filter string is based
      upon the string representation of LDAP search filters as defined in
      <xref linkend="i3024195"/>. It should be noted that RFC 2254: A String
      Representation of LDAP Search Filters supersedes RFC 1960, but only adds
      extensible matching and is not applicable to this OSGi Framework
      API.</para>

      <para>The string representation of an LDAP search filter uses a prefix
      format and is defined by the following grammar:</para>

      <programlisting>filter      ::= '(' filter-comp ')'
filter-comp ::= and | or | not | operation
and         ::= '&amp;' filter-list
or          ::= '|' filter-list
not         ::= '!' filter
filter-list ::= filter | filter filter-list
operation   ::= simple | present | substring
simple      ::= attr filter-type value
filter-type ::= equal | approx | greater-eq | less-eq
equal       ::= '='
approx      ::= '~='
greater-eq  ::= '&gt;='
less-eq     ::= '&lt;='
present     ::= attr '=*'
substring   ::= attr '=' initial any final
initial     ::= () | value
any         ::= '*' star-value
star-value  ::= () | value '*' star-value
final       ::= () | value
value       ::= &lt;see text&gt;
attr        ::= &lt;see text&gt;</programlisting>

      <para><code>attr</code> is a string representing an attribute key or
      name. Attribute names are not case sensitive; that is, <code>cn</code>
      and <code>CN</code> both refer to the same attribute. <code>attr</code>
      must not contain the characters '=', '&gt;', '&lt;', '~', '(' or ')'.
      <code>attr</code> may contain embedded spaces but leading and trailing
      spaces must be ignored.</para>

      <para><code>value</code> is a string representing the value, or part of
      one, which will be compared against a value in the filtered
      properties.</para>

      <para>If <code>value</code> must contain one of the characters reverse
      solidus (<code>'\' \u005C</code>), asterisk (<code>'*' \u002A</code>),
      parentheses open (<code>'(' \u0028</code>) or parentheses close
      (<code>')' \u0029</code>), then these characters should be preceded with
      the reverse solidus (<code>'\' \u005C</code>) character. Spaces are
      significant in <code>value</code>. Space characters are defined by
      <code>Character.isWhiteSpace()</code>.</para>

      <para>Although both the <code>substring</code> and <code>present</code>
      productions can produce the <code>attr=*</code> construct, this
      construct is used only to denote a presence filter.</para>

      <para>The <code>substring</code> production only works for attributes
      that are of type <code>String</code>, <code>Collection</code> of
      <code>String</code> or <code>String[]</code>. In all other cases the
      result must be <code>false</code>.</para>

      <para>The evaluation of the approximate match (<code>'~='</code>) filter
      type is implementation specific but should at least ignore case and
      white space differences. Codes such as Soundex or other smart
      <emphasis>closeness</emphasis> comparisons could be used.</para>

      <para>Values specified in the filter are compared to values in the
      properties against which the filter is evaluated. The comparison of
      these values is not straightforward. Strings compare differently than
      numbers, and it is also possible for a property to have multiple
      values.</para>

      <para>Property keys are case insensitive. The object class of the
      property's value defines the comparison type. The properties values
      should be of the following types:</para>

      <figure xml:id="i3217016">
        <title>Primary Property Types</title>

        <programlisting>type        ::=  scalar  | collection | array
scalar      ::=  String | Integer | Long | Float 
                    | Double | Byte | Short 
                    | Character | Boolean
primitive   ::= int | long | float | double | byte 
                    | short | char | boolean
array       ::= &lt;Array of primitive&gt;  
                    | &lt;Array of scalar&gt;
collection  ::= &lt;Collection of scalar&gt;</programlisting>
      </figure>

      <para>The following rules apply for comparison:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>String</emphasis> - Use String comparison</para>
        </listitem>

        <listitem>
          <para><emphasis>Integer, Long, Float, Double, Byte, Short, Character
          objects and primitives</emphasis> - Use numerical comparison. The
          <code>value</code> should be trimmed of any extraneous white space
          before the comparison.</para>
        </listitem>

        <listitem>
          <para><emphasis>Boolean objects</emphasis> - Use comparison defined
          by <code>Boolean.valueOf(value).booleanValue()</code>. The
          <code>value</code> should be trimmed of any extraneous white space
          before this conversion is applied.</para>
        </listitem>

        <listitem>
          <para><emphasis>Array or Collection elements</emphasis> - Comparison
          is determined by the object type of the element</para>
        </listitem>
      </itemizedlist>

      <para>Array and Collection elements may be a mix of scalar types. Array
      and Collection elements may also be <code>null</code>. If the type of
      the property value is not one of the above types, then it could be
      possible to create an instance of the above type. The following
      conversions must be tried in the given order:</para>

      <orderedlist>
        <listitem>
          <para>A public static method on the required type called
          <code>valueOf</code> that returns an instance of the given type and
          takes a single <code>String</code> argument.</para>
        </listitem>

        <listitem>
          <para>A public constructor taking a single <code>String</code>
          argument.</para>
        </listitem>
      </orderedlist>

      <para>If one of these methods is available then the Framework must
      construct a temporary object by passing the <code>value</code> as the
      <code>String</code> argument. If the constructor/function is not
      directly accessible then the invocation should use the
      <code>setAccessible</code> method to make it accessible.</para>

      <para>The resulting object must be used to compare with the property
      value according to the following comparison rules:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Comparable objects</emphasis> - Comparison through
          the <code>Comparable</code> interface</para>
        </listitem>

        <listitem>
          <para><emphasis>Other objects</emphasis> - Equality
          comparison</para>
        </listitem>
      </itemizedlist>

      <para>If none of the above comparison rules apply, then the result of
      the comparison is <code>false</code>.</para>

      <para>A filter matches a property with multiple values if it matches at
      least one of those values. For example:</para>

      <programlisting>Dictionary dict = new Hashtable();
dict.put( "cn", new String[] { "a", "b", "c" } );</programlisting>

      <para>The <code>dict</code> will match against a filter with
      <code>(cn=a)</code> as well as <code>(cn=b)</code>.</para>

      <para>Service properties are often defined to take a type, a collection
      of that type, or an array of that type. In those cases, a simple + will
      be suffixed to the type name. For example <code>String+</code>,
      indicates that a <code>String</code>, a <code>String[]</code>, and a
      <code>Collection&lt;String&gt;</code> are all valid forms.</para>

      <para>Filters are supported in the API with the <xref
      linkend="org.osgi.framework.Filter" xrefstyle="hyperlink"/> type.
      Filters can be created with the <xref
      linkend="org.osgi.framework.FrameworkUtil" xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.FrameworkUtil.createFilter-String-"
      xrefstyle="hyperlink"/> method or the <xref
      linkend="org.osgi.framework.BundleContext" xrefstyle="hyperlink"/>.<xref
      linkend="org.osgi.framework.BundleContext.createFilter-String-"
      xrefstyle="hyperlink"/> method.</para>
    </section>

    <section xml:id="framework.module-multireleasejar">
      <title>Multi-release JAR</title>

      <para>A bundle JAR file can be a multi-release JAR. See <xref
      linkend="framework.module-ref.multireleasejar"/>. When a bundle is a
      multi-release JAR, that is, the manifest contains</para>

      <programlisting>Multi-Release: true</programlisting>

      <para>then the Framework must look for a supplemental manifest file,
      <code>OSGI-INF/MANIFEST.MF</code>, in the versioned directories. For
      example:</para>

      <programlisting>META-INF/versions/9/OSGI-INF/MANIFEST.MF</programlisting>

      <para>The Framework must first look in the versioned directory for the
      major version of the current Java platform and then prior versioned
      directories in descending order. The first supplemental manifest file
      found must be used and the Framework must replace the values of the
      following manifest headers in the manifest with the values of these
      headers, if present, in the supplemental manifest file.</para>

      <itemizedlist>
        <listitem>
          <para><code>Import-Package</code></para>
        </listitem>

        <listitem>
          <para><code>Require-Capability</code></para>
        </listitem>
      </itemizedlist>

      <para>Any other headers in the supplemental manifest file must be
      ignored.</para>

      <para>The Framework APIs which provide access to the bundle metadata,
      such as <xref linkend="org.osgi.framework.Bundle.getHeaders--"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.framework.wiring.BundleRevision"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.framework.wiring.BundleWiring"
      xrefstyle="hyperlink"/>, must present the supplemented manifest
      information. That is, the main manifest with the replacement values from
      a supplemental manifest, if any, for the running Java platform
      version.</para>

      <para>Both fragment bundles as well as non-fragment bundles can be
      multi-release JARs.</para>

      <para>Support for multi-release JARs must only be active on Java 9 and
      later. On Java 8 and earlier, the JAR must be treated as a
      non-multi-release JAR.</para>
    </section>
  </section>

  <section xml:id="framework.module.dependencies">
    <title>Dependencies</title>

    <para>OSGi dependency handling is based on a very general model that
    describes the dependency relationships. This model consists of a small
    number of primitive concepts:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Environment</emphasis> - A container or framework that
        installs Resources.</para>
      </listitem>

      <listitem>
        <para><emphasis>Resource</emphasis> - An abstraction for an artifact
        that needs to become installed in some way to provide its intended
        function. A Bundle is modeled by a Resource but for example a display
        or secure USB key store can also be Resources.</para>
      </listitem>

      <listitem>
        <para><emphasis>Namespace</emphasis> - Defines what it means for the
        Environment when a requirement and capability match in a given
        Namespace.</para>
      </listitem>

      <listitem>
        <para><emphasis>Capability</emphasis> - Describing a feature or
        function of the Resource when installed in the Environment. A
        capability has attributes and directives.</para>
      </listitem>

      <listitem>
        <para><emphasis>Requirement</emphasis> - An assertion on the
        availability of a capability in the Environment. A requirement has
        attributes and directives. The <code>filter</code> directive contains
        the filter to assert the attributes of the capability in the same
        Namespace.</para>
      </listitem>
    </itemizedlist>

    <para>The relations between these entities are depicted in <xref
    linkend="i3308531"/>.</para>

    <figure xml:id="i3308531">
      <title>Core Requirement/Capability model</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.326in"
                     contentwidth="6.415in" fileref="core-req-cap-model.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>A Resource in general has dependencies on other Resources or can
    satisfy other Resource's dependencies. Dependency types can vary wildly, a
    Bundle can require packages from another Bundle (Import-Package), or a
    Fragment needs a host Bundle (Fragment-Host), or a Bundle requires access
    to a high resolution display. The OSGi Core specification demonstrates
    that it is possible to describe these varying types of dependencies with
    dedicated headers, optimized for each case. However, this model requires
    that every type of dependency will go through a specification process,
    limiting the usefulness for parties not participating in this process.
    Therefore, this specification provides a generic dependency model based on
    <emphasis>Namespaces</emphasis>. A Namespace is the
    <emphasis>type</emphasis> of a dependency. For example, the
    <code>osgi.wiring.package</code> Namespace defines the semantics for
    Import-Package and Export-Package headers by specifying a number of
    <emphasis>attributes</emphasis> and <emphasis>directives</emphasis>.
    Attributes are used for matching and directives provide information about
    the semantics of the Namespace. For example, in the case of the
    <code>osgi.wiring.host</code> Namespace (Fragments) the capability's
    attributes are:</para>

    <itemizedlist>
      <listitem>
        <para><code>osgi.wiring.host</code> - (<code>String</code>) The host's
        name.</para>
      </listitem>

      <listitem>
        <para><code>bundle-version</code> - (<code>Version</code>) The host's
        version.</para>
      </listitem>

      <listitem>
        <para><code>*</code> - Any other attributes are allowed.</para>
      </listitem>
    </itemizedlist>

    <para>The OSGi Framework Namespaces are defined in classes, see <xref
    linkend="framework.namespaces"/>.</para>

    <para>The purpose of a Namespace is to create an attribute/directive based
    language that describes a dependency in a generic way unrelated to the
    specific dependency type. A number of Namespaces have been defined by the
    OSGi Working Group in this and other specifications. OSGi namespaces start with
    the reserved <code>osgi.</code> prefix. For example, the
    <code>osgi.ee</code> namespace defines a capability for specifying an
    execution environment. A Namespace can also be defined by other
    organizations and individuals. To minimize name clashes it is recommended
    to use the reverse domain name rule used for packages and bundle symbolic
    names. It is also recommended to register these Namespaces with the OSGi
    Working Group, see <xref linkend="framework.module.namespace-registry"/> to
    prevent clashes.</para>

    <para>Given a Namespace, it is possible to declare a
    <emphasis>capability</emphasis> of that Namespace. A capability provides
    the values for the attributes and directives defined in the Namespace. For
    example, it is possible to translate the Export-Package header to a
    capability in the <code>osgi.wiring package</code> Namespace.</para>

    <para>Given a capability, it is possible to specify a
    <emphasis>requirement</emphasis>. A requirement has a filter that can
    match the attributes of the capability, if so, the requirement is
    <emphasis>satisfied</emphasis>. Requirements are always associated with a
    given Namespace, like the capability, and can therefore only be
    <emphasis>satisfied</emphasis> by Capabilities in the same Namespace. A
    requirement is satisfied when its filter, as specified with the
    <code>filter</code> directive, matches a capability's attributes. The
    filter language specification can be found in <xref
    linkend="framework.module.filtersyntax"/>. A requirement can be
    <emphasis>mandatory</emphasis> or <emphasis>optional</emphasis>, as set
    with its <code>resolution</code> directive. A requirement can have
    <code>single</code> or <code>multiple</code> cardinality, indicating it
    requires at least one or more Capabilities.</para>

    <para>A Resource that declares requirements can only provide its intended
    functionality when its mandatory requirements are satisfied by one or more
    Capabilities, which in general means they come from other Resources. A
    Resource that has all its mandatory requirements satisfied is said to be
    <emphasis>resolved</emphasis> and must provide the functionality described
    by its Capabilities. A capability can only satisfy a requirement if its
    Resource is resolved.</para>

    <para>The process of matching up requirements to capabilities is called
    <emphasis>resolving</emphasis>. In this process, the resolver must create
    <emphasis>Wires</emphasis> that link requirements to Capabilities. Both
    the Wire and the requirement/ Capability have a reference to a Resource.
    In certain cases the requirement/ capability can be declared in one
    Resource but wired from another Resource. Therefore, a requirement/
    capability can have a <emphasis>declared</emphasis> Resource, which is the
    Resource that declares it. However, when a Resource is
    <emphasis>wired</emphasis> the Wire has a <emphasis>provider</emphasis> or
    <emphasis>requirer</emphasis> Resource which can differ from the
    corresponding declared Resource. When the declared Resource differs from
    the provider/requirer it is called <emphasis>hosting</emphasis>. This
    separation is caused by Fragments; with Fragments some requirements and
    Capabilities are hosted and others remain part of the Fragment.</para>

    <para>Only requirements that are <emphasis>effective</emphasis> must be
    wired. Each requirement is intended for a certain state of the system. For
    example, the OSGi Framework only resolves requirements when the
    requirement has the <code>effective</code> directive set to
    <code>resolve</code>.</para>

    <para>Once a set of Resources are resolved the Environment, for example
    the OSGi Framework for bundles, creates a <emphasis>Wiring</emphasis> per
    Resource to hold the resolved state. This state includes the Wires as well
    as all Capabilities and requirements, regardless if they are wired or
    not.</para>

    <para>The Wires between a requirement and a capability must be created
    according to the semantics implied by their Namespace. The Wires coming
    out of a resolve operation can be used during run time as specified in
    their Namespace. For example, the <code>osgi.wiring.*</code> Namespaces
    are used to control the Class Loading, see <xref
    linkend="framework.wiring"/>. However, they can also serve other purposes
    as outlined by their Namespace. For example, a Wire could specify a
    Dependency Injection source and target.</para>

    <para>Interfaces for the generic model are defined in <xref
    linkend="framework.resource"/>. The <xref linkend="framework.wiring"/>
    chapter describes the Wiring API that is based on this generic package.
    The generic API is intended for other specifications that want to be
    compatible with the generic OSGi Core framework's Capability /Requirement
    model.</para>

    <section>
      <title>Bundles</title>

      <para>All bundles depend on one or more external entities and this is
      expressed as requirements and Capabilities. Once a bundle is resolved,
      it assumes that those dependencies are <emphasis>satisfied</emphasis>.
      The Require-Capability and Provide-Capability headers are manifest
      headers that <emphasis>declare</emphasis> generic requirements and
      Capabilities in any Namespace. However, a number of manifest headers in
      the OSGi specifications are actually requirements on Capabilities
      specified by other OSGi manifest headers. For example, an Import-Package
      clause is a requirement on the capability specified by an Export-Package
      clause. The attributes on an Import-Package clause are treated as
      assertions on the attributes of the corresponding Export-Package clause.
      This specification therefore contains a number of Namespaces for these
      OSGi manifest headers: <code>osgi.wiring.bundle</code>,
      <code>osgi.wiring.package</code>, and <code>osgi.wiring.host</code>.
      These namespaces influence the resolver and define the class loading
      process. For example, a Require-Bundle clause is a requirement that
      ensures that the exported packages of the required bundle are available
      to the requirer's class loader.</para>

      <para>The OSGi resolving process is described in <xref
      linkend="framework.module.resolvingprocess"/>. The diagramming technique
      of the Requirement/Capability model is depicted in <xref
      linkend="i3249403"/>, the details of the wiring are further explained in
      <xref linkend="framework.wiring"/>.</para>

      <figure pgwide="1" xml:id="i3249403">
        <title>Requirements and Capabilities and their Wiring</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.800in"
                       contentwidth="6.199in" fileref="req-cap-wiring.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Example Use Case</title>

      <para>A bundle has Windows 7 specific Java code and requires a display
      that has a resolution of at least 1000x1000 pixels. It also relies on a
      bundle providing an IP-number-to-location table.</para>

      <para>These dependencies on the environment and another bundle can be
      expressed with the requirement header in the bundle as follows:</para>

      <programlisting>Require-Capability:
  com.microsoft;    filter:="(&amp;(api=win32)(version=7))",
  com.acme.display; filter:="(&amp;(width&gt;=1000)(height&gt;=1000))",
  com.acme.ip2loc</programlisting>

      <para>Each clause lives in a namespace, for example
      <code>com.microsoft</code>. A namespace defines the semantics of the
      attributes as well as optional rules.</para>

      <para>The deployer of the environment sets the following launching
      property when starting the framework:</para>

      <programlisting>org.osgi.framework.system.capabilities.extra= «
  com.acme.display; width:Long=1920; height:Long=1080; interlace=p, «
  com.microsoft; edition=home; version:Version=7; api=win32</programlisting>

      <para>The framework will be able to satisfy the display requirement but
      it cannot satisfy the <code>ip2loc</code> table requirement. The
      deployer can then install the bundle with the <code>ip2loc</code> table.
      This bundle specifies the following header:</para>

      <programlisting>Provide-Capability: com.acme.ip2loc; version:Version=1.2</programlisting>

      <para>After installing and resolving this bundle, the framework can
      resolve the original bundle because there is now a provider of the
      <code>ip2loc</code> table.</para>
    </section>

    <section>
      <title>Bundle Capabilities</title>

      <para>A generic capability for a Bundle is defined with the
      Provide-Capability header. This header has the following syntax:</para>

      <programlisting>Provide-Capability  ::= capability (',' capability )*
capability          ::= name-space 
                            ( ';' directive | typed-attr )*
name-space          ::= symbolic-name
typed-attr          ::=  extended ( ':' type )? '=' argument
type                ::= scalar | list
scalar              ::= 'String' | 'Version' | 'Long' 
                            |   'Double' 
list                ::= 'List' ( '&lt;' scalar '&gt;' )?</programlisting>

      <para>The <xref linkend="org.osgi.annotation.bundle.Capability"
      xrefstyle="hyperlink"/> annotation can be used on a class or package to
      specify a capability to be provided by the bundle. This annotation can
      be processed by bundle assembly tools to add the capability to the
      Provide-Capability header in the bundle's manifest.</para>

      <para>The header has the following directives architected:</para>

      <itemizedlist>
        <listitem>
          <para><code>effective</code> - <code>(resolve)</code> Specifies the
          time a capability is available, either <code>resolve</code>
          (default) or another name. The OSGi framework resolver only
          considers Capabilities without an <code>effective</code> directive
          or <code>effective:=resolve</code>. Capabilities with other values
          for the <code>effective</code> directive can be considered by an
          external agent.</para>
        </listitem>

        <listitem>
          <para><code>uses</code> - The uses directive lists package names
          that are used by this capability. This information is intended to be
          used for uses constraints, see <xref linkend="i3127019"/>.</para>
        </listitem>
      </itemizedlist>

      <para>Namespaces can define additional directives and attributes.</para>
    </section>

    <section xml:id="i3306043">
      <title>Bundle Capability Attributes</title>

      <para>Attributes can be <emphasis>typed</emphasis>. Typing is important
      because it defines how attributes compare. Comparing two versions as
      strings does not provide the proper comparison semantics for versions.
      In similar vein, lexicographical ordering is different than numeric
      ordering.</para>

      <para>Types are specified between the attribute name and the equal sign
      (<code>'=' \u003D</code>), the separator is a colon (<code>':'
      \u003A</code>). For example:, for a <code>Long:</code></para>

      <programlisting>attr:Long=24</programlisting>

      <para>If no type is specified, the <code>String</code> type is
      assumed.</para>

      <para>The parsing rules of the corresponding type's <code>String</code>
      constructor are then used to create a new instance that is placed in the
      capability's map. Numeric types must trim white space around the value,
      for other types spaces around the argument are not ignored, however,
      white space is skipped by the manifest parsing rules. That is:</para>

      <programlisting>attr:Long=        23       ,            //ok
attr:Version="    23      ",            // error
attr:Long="       23      ",            // ok, because nummeric</programlisting>

      <para>Multi-valued attributes can be constructed with the
      <code>List</code> type. The <code>List</code> type can specify a
      <code>scalar</code> type for the list elements. If no element type is
      specified, <code>String</code> is assumed. Parsing of the corresponding
      <code>argument</code> list must be done according to the following
      rules:</para>

      <itemizedlist>
        <listitem>
          <para>Element values in the list are separated by commas (<code>','
          \u002C</code>).</para>
        </listitem>

        <listitem>
          <para>White space around an element value must be trimmed for
          non-<code>String</code> element types.</para>
        </listitem>

        <listitem>
          <para>Commas or reverse solidi (<code>'\' \u005C</code>) that are
          part of an element value must be escaped by prefixing them with a
          reverse solidus. In practice, this requires escaping with two
          reverse solidi because a reverse solidus must already be escaped in
          strings.</para>
        </listitem>
      </itemizedlist>

      <para>The whole <code>argument</code> must be surrounded by quotes
      because the comma is a significant token in the manifest grammar.</para>

      <para>The version attribute requires the Version type to be specified to
      be compared as a Version rather than as a String:</para>

      <programlisting>version:Version=1.23</programlisting>

      <para>For example:</para>

      <programlisting>Provide-Capability: «
   com.acme.dictionary; from:String=nl; to=de; version:Version=3.4, «
   com.acme.dictionary; from:String=de; to=nl; version:Version=4.1, «
   com.acme.ip2location;country:List="nl,be,fr,uk";version:Version=1.3, «
   com.acme.seps;       tokens:List&lt;String&gt;="\\,,;,\\\""</programlisting>
    </section>

    <section>
      <title>System Bundle Capabilities</title>

      <para>Capabilities can also be provided by the system bundle by
      specifying the following launch properties:</para>

      <programlisting>org.osgi.framework.system.capabilities
org.osgi.framework.system.capabilities.extra</programlisting>

      <para>The format for these system properties is identical to the
      Provide-Capability header. A framework must parse these properties and
      use them in the resolving process as if provided by the system
      bundle.</para>

      <para>There are two properties so that the framework can specify its
      default Capabilities in
      <code>org.osgi.framework.system.capabilities</code> while the deployer
      can specify specific deployment Capabilities in the
      <code>org.osgi.framework.system.capabilities.extra</code> system
      property. Frameworks can often deduce many Capabilities from their
      environment.</para>

      <para>The following is an example capability header for the system
      bundle as defined by the deployer:</para>

      <programlisting>map.put("org.osgi.framework.system.capabilities.extra",
    "com.acme.screen; width:Long=640; height:Long=480; card=GeForce");</programlisting>
    </section>

    <section>
      <title>Bundle Requirements</title>

      <para>The Bundle's Require-Capability header has the following
      grammar:</para>

      <programlisting>Require-Capability ::= requirement ( ',' requirement )* 
requirement        ::= name-space ( ';' directive | typed-attr )*</programlisting>

      <para>Requirements have attributes that can be set with the
      Require-Capability header. The purpose of these attributes are to
      provide further information about the requirement; they are not
      assertions as they are in the Import-Package, Require-Bundle, and
      Fragment-Host headers. The attributes of these headers are mapped to the
      <code>filter</code> directive in their corresponding namespaces.</para>

      <para>The <xref linkend="org.osgi.annotation.bundle.Requirement"
      xrefstyle="hyperlink"/> annotation can be used on a class or package to
      specify a capability to be required by the bundle. This annotation can
      be processed by bundle assembly tools to add the requirement to the
      Require-Capability header in the bundle's manifest.</para>

      <para>The following directives are architected for the
      Require-Capability header:</para>

      <itemizedlist>
        <listitem>
          <para><code>effective</code> - <code>(resolve)</code> Specifies the
          time a requirement is considered, either <code>resolve</code>
          (default) or another name. The OSGi framework resolver only
          considers requirements without an <code>effective</code> directive
          or <code>effective:=resolve</code>. Other requirements can be
          considered by an external agent. Additional names for the
          <code>effective</code> directive should be registered with the OSGi
          Working Group.</para>
        </listitem>

        <listitem>
          <para><code>resolution</code> - (<code>mandatory|optional</code>) A
          mandatory requirement forbids the bundle to resolve when the
          requirement is not satisfied; an optional requirement allows a
          bundle to resolve even if the requirement is not satisfied. No
          wirings are created when this requirement cannot be resolved, this
          can result in Class Not Found Exceptions when the bundle attempts to
          use a package that was not resolved because it was
          <code>optional</code>. The default is <code>mandatory</code>.</para>
        </listitem>

        <listitem>
          <para><code>filter</code> - (<code>Filter</code>) A filter
          expression that is asserted on the Capabilities belonging to the
          given namespace. The matching of the filter against the capability
          is done on one capability at a time. A filter like
          <code>(&amp;(a=1)(b=2))</code> matches only a capability that
          specifies both attributes at the required value, not two
          capabilities that each specify one of the attributes correctly. A
          filter is optional, if no filter directive is specified the
          requirement always matches. The attribute names in the filter
          expression are used to locate capability attributes in a case
          sensitive manner.</para>
        </listitem>

        <listitem>
          <para><code>cardinality</code> - (<code>single|multiple</code>)
          Indicates if the requirement can be wired a single time or multiple
          times. The default is single.</para>
        </listitem>
      </itemizedlist>

      <para>Additional directives are ignored during resolving. Attributes on
      the <code>requirement</code> clause are also ignored.</para>
    </section>
  </section>

  <section xml:id="framework.module-execution.environment">
    <title>Execution Environment</title>

    <para>The Java environment provides all packages in the
    <code>java.*</code> namespace. Prior to Java SE 9, this namespace was not
    well defined and could be different for different runtime environments.
    For example, Java SE 5 is not equal to Java SE 7 and an Android
    environment has substantial differences to a Java SE environment. However,
    Java SE 6 is backward compatible for Java SE 5, Java SE 1.4, Java SE 1.3
    and Java SE 1.2. That is, applications written for Java SE 1.3 must run
    unchanged on a Java SE 5 environment.</para>

    <para>These differences and backward compatibilities can not be captured
    using versions because they are <emphasis>variations</emphasis>. For
    example, <xref linkend="i3246261"/> is a variation of a Java SE 5
    environment, as is <xref linkend="i3246276"/> and <xref
    linkend="i3246284"/>. All these variations have a different set of
    packages, types, and methods in the <code>java.*</code> namespace.</para>

    <para>Starting in Java SE 9, the platform has been modularized and its
    packages organized into a set of modules. Depending upon how the platform
    is configured for execution, some modules and their contained packages may
    not be present at runtime. However, Java SE 9 provides a standard way to
    interrogate the Java platform for the packages currently available at
    runtime. Therefore, the Framework must set the
    <code>org.osgi.framework.system.packages</code> launching property, see
    <xref linkend="framework.lifecycle.launchingproperties"/>, to the list of
    Java platform packages currently available at runtime.</para>

    <para>For Java platform versions prior to Java SE 9, the Framework must
    also set the <code>org.osgi.framework.system.packages</code> launching
    property to the list of Java platform packages generally known to be
    available at runtime. Since there is no standard way to interrogate the
    Java platform for the packages currently available at runtime, a Framework
    implementation may use a predefined list of packages for the Java platform
    version.</para>

    <para>In additional to specifying the version of the execution environment
    via an <code>osgi.ee</code> requirement, see <xref
    linkend="framework.namespaces.osgi.ee"/>, a Bundle may also import
    <code>java.*</code> packages using the Import-Package header. Imports of
    <code>java.*</code> packages by a bundle will be used during the
    resolution process, see <xref
    linkend="framework.module.resolvingprocess"/>, to ensure the bundle has
    visibility to the requested packages by wiring the bundle's import of a
    <code>java.*</code> package to the export of the <code>java.*</code>
    package by the Framework's system bundle. However, a bundle always loads
    classes in <code>java.*</code> packages via parent delegation. See <xref
    linkend="framework.module.parentdelegation"/>. Therefore, a bundle is not
    required to import a <code>java.*</code> package to have visibility to the
    classes in the package, if the package is present in the current runtime.
    It only needs to import a <code>java.*</code> package to have the
    resolution process ensure the package is available from the execution
    environment. This can avoid a <code>NoClassDefFoundError</code> during
    execution of the bundle due to a missing <code>java.*</code> package
    required by the bundle.</para>

    <section xml:id="framework.module.bree">
      <title>Bundle-RequiredExecutionEnvironment</title>

      <para>The Bundle-RequiredExecutionEnvironment manifest header provides
      the same function as the <xref linkend="framework.namespaces.osgi.ee"/>.
      It allows a bundle to depend on the execution environment. This header
      is deprecated but must be fully supported by a compliant framework.
      Bundles should not mix these headers but use either an
      <code>osgi.ee</code> requirement or this header. If both are used, both
      constraints must be met to resolve.</para>

      <para>The syntax of this header is a list of comma-separated names of
      execution environments.</para>

      <programlisting>Bundle-RequiredExecutionEnvironment ::= ee-name ( ',' ee-name )*

ee-name  ::= bree | &lt;ee name&gt;
bree     ::= token ( '-' version )? ( '/' token ( '-' version )? )?</programlisting>

      <para>For example:</para>

      <programlisting>Bundle-RequiredExecutionEnvironment: CDC-1.0/Foundation-1.0, «
  OSGi/Minimum-1.1</programlisting>

      <para>If a bundle includes this header in the manifest then the bundle
      must only use methods with signatures that are contained within a proper
      subset of all mentioned execution environments. Bundles should list all
      (known) execution environments on which it can run the bundle.</para>

      <para>A bundle can only resolve if the framework is running on a VM
      which implements one of the listed required execution environments.
      Frameworks should recognize that the current VM can implement multiple
      execution environments. For example, Java 6 is backward compatible with
      Java 5 and a bundle requiring the Java 6 execution environment must
      resolve on a Java 6 VM.</para>

      <para>The Bundle-RequiredExecutionEnvironment header can not prevent a
      bundle from installing.</para>

      <para>The <code>org.osgi.framework.executionenvironment</code> launching
      property defines the current execution environment with a comma
      separated list of execution environment names. If not set, the framework
      must provide an appropriate value. This property is also deprecated, its
      function is replaced with
      <code>org.osgi.framework.system.capabilities[.extra]</code>.</para>

      <para>An example:</para>

      <programlisting>org.osgi.framework.executionenvironment = 
     JavaSE-1.5, J2SE-1.4, JavaSE-1.4, JavaSE-1.3, OSGi/Minimum-1.1</programlisting>

      <para>Frameworks must convert a Bundle-RequiredExecutionEnvironment
      header to a requirement in the <code>osgi.ee</code> namespace when used
      in the Wiring API, see <xref linkend="framework.wiring"/>. Since the
      header uses opaque names for the execution environments there is no
      guaranteed algorithm to map the <code>ee-name</code> to a
      Require-Capability header. However, the suggested names so far for
      popular execution environments do have a structure that can be used to
      create such a header, this pattern was reflected in the
      <code>bree</code> term. The structure of the <code>bree</code> term for
      the existing recommendations is:</para>

      <programlisting>n1 ( '-' v )? ( '/' n2 ( '-' v )? )?</programlisting>

      <para>For example:</para>

      <programlisting>CDC-1.0/Foundation-1.0
OSGi/Minimum-1.2
J2SE-1.4
JavaSE-1.4</programlisting>

      <para>Each <code>bree</code> term that matches this pattern can thus be
      converted into an equivalent <code>osgi.ee</code> Require-Capability
      filter. First variable <code>n1</code> must be replaced with
      <code>JavaSE</code> when it is <code>J2SE</code> since the
      Require-Capability header uses a single name for the Java Standard
      Edition. The <code>filter</code> directive can then be constructed from
      <code>n1</code>, <code>v</code>, and <code>n2</code>. If n2 is not
      defined or v is not defined then the parenthesized parts in which they
      participate are not used in the expansion.</para>

      <programlisting>bree-filter ::= '(&amp;(osgi.ee=' n1 ( '/' n2 )? ')' ( '(version=' v ')' )? ')'</programlisting>

      <para>If the <code>bree</code> term cannot be parsed into the given
      constituents then the filter must look like:</para>

      <programlisting>filter    ::= '(osgi.ee=' &lt;ee name&gt; ')'</programlisting>

      <para>Some examples:</para>

      <programlisting>CDC-1.0/Foundation-1.0      (&amp;(osgi.ee=CDC/Foundation)(version=1.0))
OSGi/Minimum-1.2            (&amp;(osgi.ee=OSGi/Minimum)(version=1.2))
J2SE-1.4                    (&amp;(osgi.ee=JavaSE)(version=1.4))
JavaSE-1.6                  (&amp;(osgi.ee=JavaSE)(version=1.6))
AA/BB-1.7                   (&amp;(osgi.ee=AA/BB)(version=1.7))
V1-1.5/V2-1.6               (osgi.ee=V1-1.5/V2-1.6)
MyEE-badVersion             (osgi.ee=MyEE-badVersion)</programlisting>

      <para>Each element of the Bundle-RequiredExecutionEnvironment is ORed
      together in the final <code>osgi.ee</code> requirement's
      <code>filter</code> directive. For example:</para>

      <programlisting>Bundle-RequiredExecutionEnvironment: 
    CDC-1.0/Foundation-1.0,
    OSGi/Minimum-1.2,
    J2SE-1.4,
    JavaSE-1.6,
    AA/BB-1.7,
    V1-1.5/V2-1.6,
    MyEE-badVersion</programlisting>

      <para>This must be converted into the following
      Require-Capability:</para>

      <programlisting>Require-Capability:osgi.ee; filter:="(|
    (&amp;(osgi.ee=CDC/Foundation)(version=1.0))
    (&amp;(osgi.ee=OSGi/Minimum)(version=1.2))
    (&amp;(osgi.ee=JavaSE)(version=1.4))
    (&amp;(osgi.ee=JavaSE)(version=1.6))
    (&amp;(osgi.ee=AA/BB)(version=1.7))
    (osgi.ee=V1-1.5/V2-1.6)
    (osgi.ee=MyEE-badVersion)
 )"</programlisting>

      <para>Every <code>org.osgi.resource.Resource</code> representing a
      Bundle which has a Bundle-RequiredExecutionEnvironment header must have
      the converted <code>osgi.ee</code> requirement in the list returned by
      <xref linkend="org.osgi.resource.Resource.getRequirements-String-"
      xrefstyle="hyperlink"/> for the <code>osgi.ee</code> namespace. In cases
      where the bundle already has a requirement for the <code>osgi.ee</code>
      namespace no merging is done, the bundle will simply have an additional
      <code>osgi.ee</code> requirement added.</para>
    </section>
  </section>

  <section xml:id="i3174728">
    <title>Class Loading Architecture</title>

    <para>Many bundles can share a single virtual machine (VM), see <xref
    linkend="i3311293"/>. Within this VM, bundles can hide packages and
    classes from other bundles, as well as share packages with other
    bundles.</para>

    <para>The key mechanism to hide and share packages is the Java
    <emphasis>class loader</emphasis> that loads classes from a sub-set of the
    bundle-space using well-defined rules. Each bundle has a single class
    loader. That class loader forms a class loading delegation network with
    other bundles as shown in <xref linkend="i3119581"/>.</para>

    <figure pgwide="1" xml:id="i3119581">
      <title>Delegation model</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.570in"
                     contentwidth="4.958in"
                     fileref="classloader-delegation-model.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The class loader can load classes and resources from:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Boot class path</emphasis> - The boot class path
        contains the <code>java.*</code> packages and its implementation
        packages.</para>
      </listitem>

      <listitem>
        <para><emphasis>Framework class path</emphasis> - The Framework
        usually has a separate class loader for the Framework implementation
        classes as well as key service interface classes.</para>
      </listitem>

      <listitem>
        <para><emphasis>Bundle Space</emphasis> - The bundle space consists of
        the JAR file that is associated with the bundle, plus any additional
        JAR that are closely tied to the bundle, like
        <emphasis>fragments</emphasis>, see <xref
        linkend="framework.module.fragmentbundles"/>.</para>
      </listitem>
    </itemizedlist>

    <para>A <emphasis>class space</emphasis> is then all classes reachable
    from a given bundle's class loader. Thus, a class space for a given bundle
    can contain classes from:</para>

    <itemizedlist>
      <listitem>
        <para>The parent class loader (normally <code>java.*</code> packages
        from the boot class path)</para>
      </listitem>

      <listitem>
        <para>Imported packages</para>
      </listitem>

      <listitem>
        <para>Required bundles</para>
      </listitem>

      <listitem>
        <para>The bundle's class path (<emphasis>private
        packages</emphasis>)</para>
      </listitem>

      <listitem>
        <para>Attached fragments</para>
      </listitem>
    </itemizedlist>

    <para>A class space must be consistent, such that it
    <emphasis>never</emphasis> contains two classes with the same fully
    qualified name (to prevent Class Cast Exceptions). However, separate class
    spaces in an OSGi Platform may contain classes with the same fully
    qualified name. The modularization layer supports a model where multiple
    versions of the same class are loaded in the same VM.</para>

    <para><xref linkend="i3281668"/> shows the class space for a Bundle A. The
    right top of Bundle A is not in the class space because it illustrates
    that sometimes packages inside a bundle are not accessible to the Bundle
    itself when an export is substituted.</para>

    <figure xml:id="i3281668">
      <title>Class Space</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.836in"
                     contentwidth="4.958in" fileref="class-space.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The Framework therefore has a number of responsibilities related to
    class loading. Before a bundle is used, it must resolve the constraints
    that a set of bundles place on the sharing of packages. Then select the
    best possibilities to create a <emphasis>wiring</emphasis>. See <xref
    linkend="framework.module.resolvingprocess"/> for further information. The
    runtime aspects are described in <xref linkend="i2570775"/>.</para>

    <section xml:id="framework.module-resolving">
      <title>Resolving</title>

      <para>The Framework must <emphasis>resolve</emphasis> bundles. Resolving
      is the process where any external dependencies are satisfied and then
      importers are <emphasis>wired</emphasis> to exporters. Resolving is a
      process of satisfying constraints; constraints that are provided by the
      <xref linkend="framework.module.dependencies"/> section and constraints
      by the different manifest headers like Import/Export Package,
      Require-Bundle, and Fragment-Host. The resolving process must take place
      before any code from a bundle can be loaded or executed.</para>

      <para>A <emphasis>wire</emphasis> is an actual connection between an
      <emphasis>exporter</emphasis> and an <emphasis>importer</emphasis>,
      which are both bundles. A wire is associated with a number of
      constraints that are defined by its importer's and exporter's manifest
      headers. A <emphasis>valid</emphasis> wire is a wire that has satisfied
      all its constraints. <xref linkend="i2545604"/> depicts the class
      structure of the wiring model. Not all constraints result in a
      wire.</para>

      <figure pgwide="1" xml:id="i2545604">
        <title>Example class structure of wiring</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.600in"
                       contentwidth="7.418in"
                       fileref="class-wiring-example.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Resolving Metadata</title>

    <para>The following sections define the manifest headers that provide the
    metadata for the resolver.</para>

    <section xml:id="i3065034">
      <title>Bundle-ManifestVersion</title>

      <para>A bundle manifest must express the version of the OSGi manifest
      header syntax in the <code>Bundle-ManifestVersion</code> header. Bundles
      exploiting this version of the Framework specification (or later) must
      specify this header. The syntax of this header is as follows:</para>

      <programlisting>  Bundle-ManifestVersion ::= number     //See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/></programlisting>

      <para>The Framework bundle manifest version must be '2'. Bundle
      manifests written to previous specifications' manifest syntax are taken
      to have a bundle manifest version of '1', although there is no way to
      express this in such manifests. Therefore, any other value than
      <code>2</code> for this header is invalid unless the Framework
      explicitly supports such a later version.</para>

      <para>OSGi Framework implementations should support bundle manifests
      without a Bundle-ManifestVersion header and assume Framework 1.2
      compatibility at the appropriate places.</para>

      <para>Version 2 bundle manifests must specify the bundle symbolic name.
      They need not specify the bundle version because the version header has
      a default value.</para>
    </section>

    <section xml:id="framework.module.bsn">
      <title>Bundle-SymbolicName</title>

      <para>The Bundle-SymbolicName manifest header is a mandatory header. The
      bundle symbolic name and bundle version identify a unique bundle. This
      does not always imply that this pair is unique in a framework, in
      certain cases the same bundle can be installed multiple times in the
      same framework, see <xref
      linkend="framework.lifecycle.bundleidentifiers"/>.</para>

      <para>A bundle gets its unique Bundle-SymbolicName from the developer.
      The Bundle-Name manifest header provides a human-readable name for a
      bundle and is therefore not replaced by this header.</para>

      <para>The Bundle-SymbolicName manifest header must conform to the
      following syntax:</para>

      <programlisting>Bundle-SymbolicName ::= symbolic-name 
                        ( ';' parameter ) *    // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/></programlisting>

      <para>The framework must recognize the following directives for the
      Bundle-SymbolicName header:</para>

      <itemizedlist>
        <listitem>
          <para><code>singleton</code> - Indicates that the bundle can only
          have a single version resolved in an environment. A value of
          <code>true</code> indicates that the bundle is a <emphasis>singleton
          bundle</emphasis>. The default value is <code>false</code>. The
          Framework must resolve at most one bundle when multiple versions of
          a singleton bundle with the same symbolic name are installed.
          Singleton bundles do not affect the resolution of non-singleton
          bundles with the same symbolic name.</para>
        </listitem>

        <listitem>
          <para><code>fragment-attachment</code> - Defines how fragments are
          allowed to be attached, see the fragments in <xref
          linkend="framework.module.fragmentbundles"/>. The following values
          are valid for this directive:</para>

          <itemizedlist>
            <listitem>
              <para><code>always</code> - (Default) Fragments can attach at
              any time while the host is resolved or during the process of
              resolving.</para>
            </listitem>

            <listitem>
              <para><code>never</code> - No fragments are allowed.</para>
            </listitem>

            <listitem>
              <para><code>resolve-time</code> - Fragments must only be
              attached during resolving.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><code>mandatory</code> - Provide a list of mandatory
          attributes. If these attributes are not specifically used in the
          requirement (Require-Bundle, Fragment-Host) then this bundle must
          not match. See <xref linkend="i2515263"/>.</para>
        </listitem>
      </itemizedlist>

      <para>The header allows the use of arbitrary attributes that can be
      required by the Require-Bundle and Fragment-Host headers. The following
      attribute is predefined:</para>

      <itemizedlist>
        <listitem>
          <para><code>bundle-version</code> - The value of the Bundle-Version
          header or 0 if no such header is present. Explicitly setting this
          attribute is an error.</para>
        </listitem>
      </itemizedlist>

      <para>For example:</para>

      <programlisting>Bundle-SymbolicName: com.acme.foo;singleton:=true</programlisting>
    </section>

    <section>
      <title>Bundle-Version</title>

      <para>Bundle-Version is an optional header; the default value is
      <code>0.0.0</code>.</para>

      <programlisting>Bundle-Version ::= version  // See <xref
          linkend="i2655136" xrefstyle="template:%n"/></programlisting>

      <para>If the <code>minor</code> or <code>micro</code> version components
      are not specified, they have a default value of <code>0</code>. If the
      qualifier component is not specified, it has a default value of the
      empty string (<code>""</code>).</para>

      <para>Versions are comparable. Their comparison is done numerically and
      sequentially on the <code>major</code>, <code>minor</code>, and
      <code>micro</code> components and lastly using the String class
      <code>compareTo</code> method for the <code>qualifier</code>.</para>

      <para>A version is considered equal to another version if the major,
      minor, micro, and the qualifier components are equal (using
      <code>String</code> method <code>compareTo</code>).</para>

      <para>Example:</para>

      <programlisting>Bundle-Version: 22.3.58.build-345678</programlisting>
    </section>

    <section xml:id="framework.module.importpackage">
      <title>Import-Package</title>

      <para>The Import-Package header defines the constraints on the imports
      of shared packages. The syntax of the Import-Package header is:</para>

      <programlisting>Import-Package ::= import ( ',' import )*
import ::= package-names ( ';' parameter )*
package-names ::= package-name 
                    ( ';' package-name )* // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/></programlisting>

      <para>The header allows many packages to be imported. An
      <emphasis>import definition</emphasis> is the description of a single
      package for a bundle. The syntax permits multiple package names,
      separated by semi-colons, to be described in a short form.</para>

      <para>Import package directives are:</para>

      <itemizedlist>
        <listitem>
          <para><code>resolution</code> - Indicates that the packages must be
          resolved if the value is mandatory, which is the default. If
          mandatory packages cannot be resolved, then the bundle must fail to
          resolve. A value of <code>optional</code> indicates that the
          packages are optional. See <xref linkend="i2548181"/>.</para>
        </listitem>
      </itemizedlist>

      <para>The developer can specify arbitrary matching attributes. See <xref
      linkend="i2480178"/>. The following arbitrary matching attributes are
      predefined:</para>

      <itemizedlist>
        <listitem>
          <para><code>version</code> - A <code>version-range</code> to select
          the exporter's package version. The syntax must follow <xref
          linkend="i3189032"/>. For more information on version selection, see
          <xref linkend="framework.module-semantic.versioning"/>. If this
          attribute is not specified, it is assumed to be <code>[0.0.0,</code>
          <phrase role="symbol">∞</phrase><code>)</code>.</para>
        </listitem>

        <listitem>
          <para><code>specification-version</code> - This attribute is an
          alias of the version attribute only to ease migration from earlier
          versions. If the <code>version</code> attribute is present, the
          values must be equal.</para>
        </listitem>

        <listitem>
          <para><code>bundle-symbolic-name</code> - The bundle symbolic name
          of the exporting bundle. In the case of a fragment bundle, this will
          be the host bundle's symbolic name.</para>
        </listitem>

        <listitem>
          <para><code>bundle-version</code> - A <code>version-range</code> to
          select the bundle version of the exporting bundle. The default value
          is <code>[0.0.0,</code> <phrase
          role="symbol">∞</phrase><code>)</code>. See <xref
          linkend="framework.module-semantic.versioning"/>. In the case of a
          fragment bundle, the version is from the host bundle.</para>
        </listitem>
      </itemizedlist>

      <para>In order to be allowed to import a package, a bundle must have
      <code>PackagePermission[&lt;package-name&gt;, IMPORT]</code>. See
      <code>PackagePermission</code> for more information.</para>

      <para>An error aborts an installation or update when:</para>

      <itemizedlist>
        <listitem>
          <para>A directive or attribute appears multiple times, or</para>
        </listitem>

        <listitem>
          <para>There are multiple import definitions for the same package,
          or</para>
        </listitem>

        <listitem>
          <para>The version and specification-version attributes do not
          match.</para>
        </listitem>
      </itemizedlist>

      <para>Example of a correct definition:</para>

      <programlisting>Import-Package: com.acme.foo;com.acme.bar; «
    version="[1.23,1.24]"; «
    resolution:=mandatory</programlisting>
    </section>

    <section xml:id="framework.module.exportpackage">
      <title>Export-Package</title>

      <para>The syntax of the Export-Package header is similar to the
      Import-Package header; only the directives and attributes are
      different.</para>

      <programlisting>Export-Package  ::= export ( ',' export)*
export          ::= package-names ( ';' parameter )*
package-names   ::= package-name                // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/>
                        ( ';' package-name )*</programlisting>

      <para>The header allows many packages to be exported. An
      <emphasis>export definition</emphasis> is the description of a single
      package export for a bundle. The syntax permits the declaration of
      multiple packages in one clause by separating the package names with a
      semi-colon. Multiple export definitions for the same package are allowed
      for example, when different attributes are needed for different
      importers. The <xref linkend="org.osgi.annotation.bundle.Export"
      xrefstyle="hyperlink"/> annotation can be applied to a package to
      specify the package is to be exported. This annotation can be processed
      by bundle assembly tools to add the annotated package to the
      Export-Package header in the bundle's manifest.</para>

      <para>Export directives are:</para>

      <itemizedlist>
        <listitem>
          <para><code>uses</code> - A comma-separated list of package names
          that are used by the exported package. Note that the use of a comma
          in the value requires it to be enclosed in double quotes. If this
          exported package is chosen as an export, then the resolver must
          ensure that importers of this package wire to the same versions of
          the package in this list. See <xref linkend="i3127019"/>.</para>
        </listitem>

        <listitem>
          <para><code>mandatory</code> - A comma-separated list of attribute
          names. Note that the use of a comma in the value requires it to be
          enclosed in double quotes. A bundle importing the package must
          specify the mandatory attributes, with a value that matches, to
          resolve to the exported package. See <xref
          linkend="i2515263"/>.</para>
        </listitem>

        <listitem>
          <para><code>include</code> - A comma-separated list of class names
          that must be visible to an importer. Note that the use of a comma in
          the value requires it to be enclosed in double quotes. For class
          filtering, see <xref linkend="i3106983"/>.</para>
        </listitem>

        <listitem>
          <para><code>exclude</code> -A comma-separated list of class names
          that must be invisible to an importer. Note that the use of a comma
          in the value requires it to be enclosed in double quotes. For class
          filtering, see <xref linkend="i3106983"/>.</para>
        </listitem>
      </itemizedlist>

      <para>The following attributes are part of this specification:</para>

      <itemizedlist>
        <listitem>
          <para><code>version</code> - The version of the named packages with
          syntax as defined in <xref linkend="i2655136"/>. It defines the
          version of the associated packages. The default value is
          <code>0.0.0</code>.</para>
        </listitem>

        <listitem>
          <para><code>specification-version</code> - An alias for the version
          attribute only to ease migration from earlier versions. If the
          <code>version</code> attribute is present, the values must be
          equal.</para>
        </listitem>
      </itemizedlist>

      <para>Additionally, arbitrary matching attributes may be specified. See
      <xref linkend="i2480178"/>.</para>

      <para>The Framework will automatically associate each package export
      definition with the following attributes:</para>

      <itemizedlist>
        <listitem>
          <para><code>bundle-symbolic-name</code> - The bundle symbolic name
          of the exporting bundle. In the case of a fragment bundle, this is
          the host bundle's symbolic name.</para>
        </listitem>

        <listitem>
          <para><code>bundle-version</code> - The bundle version of the
          exporting bundle. In the case of a fragment bundle, this is the host
          bundle's version.</para>
        </listitem>
      </itemizedlist>

      <para>An installation or update must be aborted when any of the
      following conditions is true:</para>

      <itemizedlist>
        <listitem>
          <para>a directive or attribute appears multiple times</para>
        </listitem>

        <listitem>
          <para>the <code>bundle-symbolic-name</code> or
          <code>bundle-version</code> attribute is specified in the
          Export-Package header.</para>
        </listitem>
      </itemizedlist>

      <para>An export definition does not imply an automatic import
      definition. A bundle that exports a package and does not import that
      package will get that package via its bundle class path. Such an
      exported only package can be used by other bundles, but the exporting
      bundle does not accept a substitution for this package from another
      bundle.</para>

      <para>In order to export a package, a bundle must have
      <code>PackagePermission[&lt;package&gt;, EXPORTONLY]</code>.</para>

      <para>Example:</para>

      <programlisting>Export-Package: com.acme.foo;com.acme.bar;version=1.23</programlisting>
    </section>

    <section xml:id="i3238802">
      <title>Importing Exported Packages</title>

      <para>Bundles that collaborate require the same class loader for types
      used in the collaboration. If multiple bundles export packages with
      collaboration types then they will have to be placed in disjoint
      class-spaces, making collaboration impossible. Collaboration is
      significantly improved when bundles are willing to import exported
      packages; these imports will allow a framework to
      <emphasis>substitute</emphasis> exports for imports.</para>

      <para>Though substitution is recommended to increase collaboration, it
      is not always possible. Importing exported packages can only work when
      those packages are pure API and not encumbered with implementation
      details. Import of exported packages should only be done when:</para>

      <itemizedlist>
        <listitem>
          <para>The exported package does not use private packages. If an
          exported package uses private packages then it might not be
          substitutable and is therefore not clean API.</para>
        </listitem>

        <listitem>
          <para>There is at least one private package that references the
          exported package. If no such reference exist, there is no purpose in
          importing it.</para>
        </listitem>
      </itemizedlist>

      <para>In practice, importing exported packages can only be done with
      clean API-implementation separation. OSGi services are carefully
      designed to be as standalone as possible. Many libraries intertwine API
      and implementation in the same package making it impossible to
      substitute the API packages.</para>

      <para>Importing an exported package must use a version range according
      to its compatibility requirements, being either a consumer or a provider
      of that API. See <xref linkend="framework.module-semantic.versioning"/>
      for more information.</para>
    </section>

    <section>
      <title>Interpretation of Legacy Bundles</title>

      <para>Bundles that are not marked with a Bundle-ManifestVersion that
      equals 2 or more must treat the headers according the definitions in the
      Release 3. More specifically, the Framework must map the Release 3
      headers to the appropriate Release 4 headers:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Import-Package</emphasis> - An import definition
          must change the <code>specification-version</code> attribute to the
          <code>version</code> attribute. An import definition without a
          specification version needs no replacement since the default version
          value of <code>0.0.0</code> gives the same semantics as Release
          3.</para>
        </listitem>

        <listitem>
          <para><emphasis>Export-Package</emphasis> - An export definition
          must change the <code>specification-version</code> attribute to the
          <code>version</code> attribute. The export definition must be
          appended with the <code>uses</code> directive. The uses directive
          must contain all imported and exported packages for the given
          bundle. Additionally, if there is no import definition for this
          package, then an import definition for this package with the package
          version must be added.</para>
        </listitem>

        <listitem>
          <para><emphasis>DynamicImport-Package</emphasis> - A dynamic import
          definition is unmodified.</para>
        </listitem>
      </itemizedlist>

      <para>A bundle manifest which mixes legacy syntax with bundle manifest
      version 2 syntax is in error and must cause the containing bundle to
      fail to install.</para>

      <para>The <code>specification-version</code> attribute is a deprecated
      synonym for the version attribute in bundle manifest version 2
      headers.</para>
    </section>
  </section>

  <section xml:id="framework.module.constraint.solving">
    <title>Constraint Solving</title>

    <para>The OSGi Framework package resolver provides a number of mechanisms
    to match imports to exports. The following sections describe these
    mechanisms in detail.</para>

    <section>
      <title>Diagrams and Syntax</title>

      <para>Wires create a graph of nodes. Both the wires as well as nodes
      (bundles) carry a significant amount of information. In the next
      sections, the following conventions are used to explain the many
      details.</para>

      <para>Bundles are named <code>A</code>, <code>B</code>,<code>
      C</code>,... That is, uppercase characters starting from the character
      <code>A</code>. Packages are named <code>p</code>, <code>q</code>,
      <code>r</code>, <code>s</code>, <code>t</code>,... In other words, lower
      case characters starting from <code>p</code>. If a version is important,
      it is indicated with a dash followed by the version: <code>q-1.0</code>.
      The syntax <code>A.p</code> means the package definition (either import
      or export) of package <code>p</code> by bundle <code>A</code>.</para>

      <para>Import definitions are graphically shown by a white box. Export
      definitions are displayed with a black box. Packages that are not
      exported or imported are called private packages. They are indicated
      with diagonal lines.</para>

      <para>Bundles are a set of connected boxes. Constraints are written on
      the wires, which are represented by lines.</para>

      <figure xml:id="i3069144">
        <title>Legend of wiring instance diagrams, and example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.716in"
                       contentwidth="7.418in" fileref="wiring-legend.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>For example:</para>

      <programlisting>A: Import-Package: p; version="[1,2)"
   Export-Package: q; version=2.2.2; uses:=p
   Require-Bundle: C
B: Export-Package: p; version=1.5.1
C: Export-Package: r</programlisting>

      <para><xref linkend="i3069187"/> shows the same setup
      graphically.</para>

      <figure xml:id="i3069187">
        <title>Example bundle diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.389in"
                       contentwidth="7.418in" fileref="bundle-example.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Version Constraints</title>

      <para>Version constraints are a mechanism whereby an import definition
      can declare a precise version or a version range for matching an export
      definition.</para>

      <para>An import definition must specify a version range as the value for
      its version attribute, and the exporter must specify a version as the
      value for its version attribute. Matching is done with the rules for
      version range matches as described in <xref linkend="i3189032"/>.</para>

      <para>For example, the following import and export definition resolve
      correctly because the version range in the import definition matches the
      version in the export definition:</para>

      <programlisting>A: Import-Package: p; version="[1,2)"
B: Export-Package: p; version=1.5.1</programlisting>

      <para><xref linkend="i3237947"/> graphically shows how a constraint can
      exclude an exporter.</para>

      <figure xml:id="i3237947">
        <title>Version Constrained</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.146in"
                       contentwidth="7.418in"
                       fileref="version-constrained.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="framework.module-semantic.versioning">
      <title>Semantic Versioning</title>

      <para>Version ranges encode the assumptions about <emphasis>binary
      compatibility</emphasis>. Though the OSGi frameworks do not enforce a
      specific encoding for a compatibility policy, it is strongly recommended
      to use the following semantics.</para>

      <para>Traditionally, compatibility has always been between two parties.
      One is the consumer of the code and the other is the provider of the
      code. API based design introduces a third party in the compatibility
      policy:</para>

      <itemizedlist>
        <listitem>
          <para>The API itself</para>
        </listitem>

        <listitem>
          <para>The <emphasis>provider</emphasis> of the API</para>
        </listitem>

        <listitem>
          <para>The <emphasis>consumer</emphasis> of the API</para>
        </listitem>
      </itemizedlist>

      <para>A provider of an API is closely bound to that API. Virtually any
      change to that API makes a provider implementation incompatible with the
      new version of the API. However, API changes have more leeway from the
      perspective of a consumer of that API. Many API changes can be made
      backward compatible for consumers but hardly any API change can be made
      backward compatible for a provider of that API.</para>

      <para>A provider of an API should therefore import that API with a
      smaller range than a consumer of that API. This policy can be encoded in
      a version range. The rules are summarized as follows:</para>

      <itemizedlist>
        <listitem>
          <para><code>major</code> - Changes for an incompatible update for
          both a consumer and a provider of an API.</para>
        </listitem>

        <listitem>
          <para><code>minor</code> - Changes for a backward compatible update
          for a consumer but not for a provider.</para>
        </listitem>

        <listitem>
          <para><code>micro</code> - A change that does not affect the API,
          for example, a typo in a comment or a bug fix in an
          implementation.</para>
        </listitem>
      </itemizedlist>

      <para>Both consumers and providers should use the version they are
      compiled against as their base version. It is recommended to ignore the
      micro part of the version because systems tend to become very rigid if
      they require the latest bug fix to be deployed all the time. For
      example, when compiled against version <code>4.2.1.V201007221030</code>,
      the base version should be <code>4.2</code>.</para>

      <para>A consumer of an API should therefore import a range that starts
      with the base version and ends with the next major change, for example:
      <code>[4.2,5)</code>. A provider of an API should import a range that
      starts with the base version up to the next minor change, for example:
      <code>[4.2,4.3)</code>.</para>
    </section>

    <section xml:id="framework.module-semantic.versioning.type.roles">
      <title>Type Roles for Semantic Versioning</title>

      <para>As mentioned in <xref
      linkend="framework.module-semantic.versioning"/>, there are two roles
      for clients of an API package: API consumers and API providers. API
      consumers use the API and API providers implement the API. For the types
      in an API, it is important that the API clearly document which of those
      types are only to be implemented or extended by API providers and which
      of those types can be implemented or extended by API consumers. For
      example, listener interfaces are generally implemented by API consumers
      and instances of them passed to API providers.</para>

      <para>API providers are sensitive to changes in types implemented or
      extended by both API consumers and API providers. An API provider must
      implement any new changes in API provider types and must understand and
      likely invoke any new changes in API consumer types. An API consumer can
      generally ignore compatible changes in API provider types unless it
      wants to invoke the new function. But an API consumer is sensitive to
      changes in API consumer types and will probably need modification to
      implement the new function. For example, in the <xref
      linkend="org.osgi.framework" xrefstyle="hyperlink"/> package, the <xref
      linkend="org.osgi.framework.BundleContext" xrefstyle="hyperlink"/> type
      is implemented by the Framework which is the API provider. Adding a new
      method to <xref linkend="org.osgi.framework.BundleContext"
      xrefstyle="hyperlink"/> will require all Framework implementations to be
      updated to implement the new method. Bundles, which are the API
      consumers, do not have to change unless they wish to call the new
      method. However, the <xref linkend="org.osgi.framework.BundleActivator"
      xrefstyle="hyperlink"/> type is implemented by bundles and adding a new
      method to <xref linkend="org.osgi.framework.BundleActivator"
      xrefstyle="hyperlink"/> will require all bundles implementing this
      interface to be modified to implement the new method and will also
      require all Framework implementations to be modified to utilize the new
      method. Thus the <xref linkend="org.osgi.framework.BundleContext"
      xrefstyle="hyperlink"/> type has an API provider role and the <xref
      linkend="org.osgi.framework.BundleActivator" xrefstyle="hyperlink"/>
      type has an API consumer role in the <xref linkend="org.osgi.framework"
      xrefstyle="hyperlink"/> API package.</para>

      <para>Since there are generally many API consumer and few API providers,
      API evolution must be very careful when considering changes to API
      consumer types while being more relaxed about changes to API provider
      types. This is because you will need to change the few API providers to
      support an updated API but you do not want to require the many existing
      API consumers to change when an API is updated. API consumers should
      only need to change when the API consumer wants to take advantage of new
      API.</para>

      <para>The <xref linkend="org.osgi.annotation.versioning.ProviderType"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.annotation.versioning.ConsumerType"
      xrefstyle="hyperlink"/> annotations can be used in source files to
      document the roles of types in a package. API types marked <xref
      linkend="org.osgi.annotation.versioning.ProviderType"
      xrefstyle="hyperlink"/> must not be implemented or extended by API
      consumers. These annotations can be processed by bundle assembly tools
      that support Semantic Versioning when generating the version range
      information for a bundle's Import-Package manifest header.</para>
    </section>

    <section xml:id="i2548181">
      <title>Optional Packages</title>

      <para>A bundle can indicate that it does not require a package to
      resolve correctly, but it may use the package if it is available. For
      example, logging is important, but the absence of a log service should
      not prevent a bundle from running.</para>

      <para>Optional imports can be specified in the following ways:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Dynamic Imports</emphasis> - The
          DynamicImport-Package header is intended to look for an exported
          package when that package is needed. The key use case for dynamic
          import is the <code>Class forName</code> method when a bundle does
          not know in advance the class name it may be requested to
          load.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resolution Directive</emphasis> - The resolution
          directive on an import definition specifying the value
          <code>optional</code>. A bundle may successfully resolve if a
          suitable optional package is not present.</para>
        </listitem>
      </itemizedlist>

      <para>The key difference between these two mechanisms is when the wires
      are made. An attempt is made to establish a wire for a dynamic import
      every time there is an attempt to load a class in that package, whereas
      the wire for a resolution <code>optional</code> package may only be
      established when the bundle is resolved.</para>

      <para>The <code>resolution</code> directive of the import definition can
      take the value <code>mandatory</code> or <code>optional</code>.</para>

      <itemizedlist>
        <listitem>
          <para><code>mandatory</code> - (Default) Indicates that the package
          must be wired for the bundle to resolve.</para>
        </listitem>

        <listitem>
          <para><code>optional</code> - Indicates that the importing bundle
          may resolve without the package being wired. If the package is not
          wired, the class loading will treat this package as if it is not
          imported.</para>
        </listitem>
      </itemizedlist>

      <para>The following example will resolve even though bundle
      <code>B</code> does not provide the correct version (the package will
      <emphasis>not</emphasis> be available to the code when bundle
      <code>A</code> is resolved).</para>

      <programlisting>A: Import-Package: p; «
        resolution:=optional; «
        version=1.6
B: Export-Package: p; «
        q; «
        version=1.5.0</programlisting>

      <figure>
        <title>Optional import</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="0.751in"
                       contentwidth="7.418in" fileref="optional-import.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The implementation of a bundle that uses optional packages must be
      prepared to handle the fact that the packages may not be available: that
      is, an exception can be thrown when there is a reference to a class from
      a missing package. This can be prevented by including a fallback package
      on the bundle's class path. When an optional package cannot be resolved,
      any attempts by the bundle to load classes from it will follow normal
      bundle class loading search order as if the import never existed. It
      will load it from the bundle's class path or in the end through dynamic
      class loading when set for that bundle and package.</para>
    </section>

    <section xml:id="i3127019">
      <title>Package Constraints</title>

      <para>Classes can depend on classes in other packages. For example, when
      they extend classes from another package, or these other classes appear
      in method signatures. It can therefore be said that a package
      <emphasis>uses</emphasis> other packages. These inter-package
      dependencies are modeled with the <code>uses</code> directive on the
      Export-Package header.</para>

      <para>For example, <code>org.osgi.service.http</code> depends on the
      package <code>javax.servlet</code> because it is used in the API. The
      export definition of the <code>org.osgi.service.http</code> must
      therefore contain the <code>uses</code> directive with the
      <code>javax.servlet</code> package as its value.</para>

      <para>Class space consistency can only be ensured if a bundle has only
      one exporter for each package. For example, the Http Service
      implementation requires servlets to extend the
      <code>javax.servlet.http.HttpServlet</code> base class. If the Http
      Service bundle would import version 2.4 and the client bundle would
      import version 2.1 then a class cast exception is bound to happen. This
      is depicted in <xref linkend="i2648668"/>.</para>

      <figure xml:id="i2648668">
        <title>Uses directive in B, forces A to use javax.servlet from
        D</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.639in"
                       contentwidth="7.418in"
                       fileref="uses-directive-servlet.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>If a bundle imports a package from an exporter then the export
      definition of that package can imply constraints on a number of other
      packages through the <code>uses</code> directive. The <code>uses</code>
      directive lists the packages that the exporter depends upon and
      therefore constrains the resolver for imports. These constraints ensure
      that a set of bundles share the same class loader for the same
      package.</para>

      <para>When an importer imports a package with uses constraints, the
      resolver must wire the import to the exporter named in the uses
      constraint. This exporter may in turn imply additional constraints, and
      so on. The act of wiring a single import of a package to an exporter can
      therefore imply a large set of constraints. The term <emphasis>implied
      package constraints</emphasis> refers to the complete set of constraints
      constructed from recursively traversing the wires. Implied package
      constraints are not automatic imports; rather, implied package
      constraints only constrain how an import definition must be
      wired.</para>

      <para>For example, in <xref linkend="i3024345"/>, bundle <code>A</code>
      imports package <code>p</code>. Assume this import definition is wired
      to bundle <code>B</code>. Due to the <code>uses</code> directive (the
      ellipse symbols indicates the <code>uses</code> directive) this implies
      a constraint on package <code>q</code>.</para>

      <para>Further, assuming that the import for package <code>q</code> is
      wired to bundle <code>C</code>, then this implies a constraint on the
      import of package <code>r</code> and <code>s</code>. Continuing,
      assuming <code>C.s</code> and <code>C.r</code> are wired to bundle
      <code>D</code> and E respectively. These bundles both add package
      <code>t</code> to the set of implied packages for bundle A.</para>

      <figure pgwide="1" xml:id="i3024345">
        <title>Implied Packages</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.492in"
                       contentwidth="7.418in" fileref="implied-packages.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>To maintain class space consistency, the Framework must ensure
      that none of its bundle imports conflicts with any of that bundle's
      implied packages.</para>

      <para>For the example, this means that the Framework must ensure that
      the import definition of A.<code>t</code> is wired to package
      <code>D.t</code>. Wiring this import definition to package
      <code>F.t</code> violates the class space consistency. This violation
      occurs because bundle A could be confronted with objects with the same
      class name but from the class loaders of bundle <code>D</code> and
      <code>F</code>. This would potentially create
      <code>ClassCastExceptions</code>. Alternatively, if all bundles are
      wired to <code>F.t</code>, then the problem also goes away.</para>

      <para>Another scenario with this case is depicted in <xref
      linkend="i2648668"/>. Bundle <code>A</code> imports the Http Service
      classes from bundle <code>B</code>. Bundle <code>B</code> has grouped
      the <code>org.osgi.service.http</code> and the
      <code>javax.servlet</code> and bundle <code>A</code> is therefore
      constrained to wire <code>javax.servlet</code> to the same exporter as
      bundle <code>B</code>.</para>

      <para>As an example of a situation where the <code>uses</code> directive
      makes resolving impossible consider the following setup that is
      correctly resolved:</para>

      <programlisting>A: Import-Package: q; version="[1.0,1.0]"
   Export-Package: p; uses:="q,r",r
B: Export-Package: q; version=1.0
C: Export-Package: q; version=2.0</programlisting>

      <para>These specific constraints can be resolved because the import
      <code>A.q</code> can be wired to the export <code>B.q</code> but not
      <code>C.q</code> due to the version constraint.</para>

      <para>Adding a bundle <code>D</code> will now not be possible:</para>

      <programlisting>D: Import-Package: p, q; version=2.0</programlisting>

      <para>Package <code>D.p</code> must be wired to package <code>A.p</code>
      because bundle <code>A</code> is the only exporter. However, this
      implies the use of package <code>q</code> due the <code>uses</code>
      directive in the package <code>A.q</code> import. Package
      <code>A.q</code> is wired to <code>B.q-1.0</code>. However, import
      package <code>D.q</code> requires version 2.0 and can therefore not be
      resolved without violating the class space constraint.</para>

      <para>This scenario is depicted in <xref linkend="i3127819"/>.</para>

      <figure xml:id="i3127819">
        <title>Uses directive and resolving</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.017in"
                       contentwidth="7.418in"
                       fileref="uses-directive-resolving.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="i2480178">
      <title>Attribute Matching</title>

      <para>Attribute matching is a generic mechanism to allow the importer
      and exporter to influence the matching process in a declarative way. In
      order for an import definition to be resolved to an export definition,
      the values of the attributes specified by the import definition must
      match the values of the attributes of the export definition. By default,
      a match is not prevented if the export definition contains attributes
      that do not occur in the import definition. The <code>mandatory</code>
      directive in the export definition can reverse this by listing all
      attributes that the Framework must match in the import definition. Any
      attributes specified in the DynamicImport-Package is ignored during the
      resolve phase but can influence runtime class loading.</para>

      <para>For example, the following statements will match.</para>

      <programlisting>A: Import-Package: com.acme.foo;company=ACME
B: Export-Package: com.acme.foo; «
          company="ACME"; «
          security=false</programlisting>

      <para>Attribute values are compared string wise except for the version
      and bundle-version attributes which use version range comparisons.
      Leading and trailing white space in attribute values must be
      ignored.</para>

      <para>Attribute matching also works for the Require-Bundle and
      Fragment-Host headers; the attributes to be matched are specified on the
      Bundle-SymbolicName header.</para>
    </section>

    <section xml:id="i2515263">
      <title>Mandatory Attributes</title>

      <para>There are two types of attributes: <emphasis>mandatory</emphasis>
      and <emphasis>optional</emphasis>. Mandatory attributes must be
      specified in the import definition to match. Optional attributes are
      ignored when they are not referenced by the importer. Attributes are
      optional by default.</para>

      <para>The exporter can specify mandatory attributes with the
      <code>mandatory</code> directive in the export definition. This
      directive contains a comma-separated list of attribute names that must
      be specified by the importer to match.</para>

      <para>For example, the following import definition must not match the
      export definition because <code>security</code> is a mandatory
      attribute:</para>

      <programlisting>A: Import-Package: com.acme.foo;company=ACME

B: Export-Package: com.acme.foo; «
          company="ACME"; «
          security=false; «
          mandatory:=security</programlisting>
    </section>

    <section xml:id="i3106983">
      <title>Class Filtering</title>

      <para>An exporter can limit the visibility of the classes in a package
      with the <code>include</code> and <code>exclude</code> directives on the
      export definition. The value of each of these directives is a
      comma-separated list of class names. Note that the use of a comma in the
      value requires it to be enclosed in double quotes.</para>

      <para>Class names must not include their package name and do not end
      with <code>.class</code>. That is, the class
      <code>com.acme.foo.Daffy</code> is named <code>Daffy</code> in either
      list. The class name can include multiple wildcard asterisks (<code>'*'
      \u002A</code>).</para>

      <para>The default for the <code>include</code> directive is an asterisk
      (<code>'*' \u002A</code>) (wildcard matching all names), and for the
      <code>exclude</code> directive, so that no classes are excluded, an
      empty list that matches no names. If <code>include</code> or
      <code>exclude</code> directive are specified, the corresponding default
      is overridden.</para>

      <para>A class is only visible if it is:</para>

      <itemizedlist>
        <listitem>
          <para>Matched with an entry in the <code>included</code> list,
          <emphasis>and</emphasis></para>
        </listitem>

        <listitem>
          <para>Not matched with an entry in the <code>excluded</code>
          list.</para>
        </listitem>
      </itemizedlist>

      <para>In all other cases, loading or finding fails, and a Class Not
      Found Exception is thrown for a class load. The ordering of
      <code>include</code> and <code>exclude</code> is not significant.</para>

      <para>The following example shows an export statement, and a list of
      files with their visibility status.</para>

      <programlisting>Export-Package: com.acme.foo; include:="Qux*,BarImpl"; «
        exclude:=QuxImpl

com/acme/foo               
   QuxFoo            visible
   QuxBar            visible
   QuxImpl           excluded
   BarImpl           visible</programlisting>

      <para>Care must be taken when using filters. For example, a new version
      of a module that is intended to be backward compatible with an earlier
      version should not filter out classes that were not filtered out by the
      earlier version. In addition, when modularizing existing code, filtering
      out classes from an exported package may break users of the
      package.</para>

      <para>For example, packages defined by standard bodies often require an
      implementation class in the standardized package to have package access
      to the specification classes.</para>

      <programlisting>package org.acme.open;
public class Specified {
    static Specified implementation;
    public void foo() { implementation.foo(); }
}

package org.acme.open;
public class Implementation {
    public void initialize(Specified implementation) {
        Specified.implementation = implementation;
    }
}</programlisting>

      <para>The <code>Implementation</code> class must not be available to
      external bundles because it allows the implementation to be set. By
      excluding the <code>Implementation</code> class, only the exporting
      bundle can see this class. The export definition for this header could
      look like:</para>

      <programlisting>Export-Package: org.acme.open; exclude:=Implementation</programlisting>
    </section>

    <section xml:id="i3259465">
      <title>Provider Selection</title>

      <para>Provider selection allows the importer to select which bundles can
      be considered as exporters. Provider selection is used when there is no
      specification contract between the importer and the exporter. The
      importer tightly couples itself to a specific exporter, typically the
      bundle that was used for testing. To make the wiring less brittle, the
      importer can optionally specify a range of bundle versions that will
      match.</para>

      <para>An importer can select an exporter with the import attributes
      <code>bundle-symbolic-name</code> and <code>bundle-version</code>. The
      Framework automatically provides these attributes for each export
      definition. These attributes must not be specified in an export
      definition.</para>

      <para>The export definition <code>bundle-symbolic-name</code> attribute
      will contain the bundle symbolic name as specified in the
      <code>Bundle-SymbolicName</code> header without any parameters. The
      export definition bundle-<code>version</code> attribute is set to the
      value of the <code>Bundle-Version</code> header or its default of 0.0.0
      when absent.</para>

      <para>The <code>bundle-symbolic-name</code> is matched as an attribute.
      The <code>bundle-version</code> attribute is matched using the version
      range rules as defined in <xref linkend="i3189032"/>. The import
      definition must be a version range and the export definition is a
      version.</para>

      <para>For example, the following definitions will match:</para>

      <programlisting>A: Bundle-SymbolicName: A
   Import-Package: com.acme.foo; «
        bundle-symbolic-name=B; «
        bundle-version="[1.41,2.0.0)"

B: Bundle-SymbolicName: B
   Bundle-Version: 1.41
   Export-Package: com.acme.foo</programlisting>

      <para>The following statements will not match because bundle B does not
      specify a version and thus defaults to 0.0.0:</para>

      <programlisting>A: Bundle-SymbolicName: A
   Import-Package: com.acme.foo; «
          bundle-symbolic-name=B; «
          bundle-version="[1.41,2.0.0)"

B: Bundle-SymbolicName: B
   Export-Package: com.acme.foo;version=1.42</programlisting>

      <para>Selecting an exporter by symbolic name can result in brittleness
      because of hard coupling of the package to the bundle. For example, if
      the exporter eventually needs to be refactored into multiple separate
      bundles, all importers must be changed. Other arbitrary matching
      attributes do not have this disadvantage as they can be specified
      independently of the exporting bundle.</para>

      <para>The brittleness problem of the bundle symbolic name in bundle
      refactoring can be partly overcome by writing a façade bundle using the
      same bundle symbolic name as the original bundle.</para>
    </section>
  </section>

  <section xml:id="framework.module.resolvingprocess">
    <title>Resolving Process</title>

    <para>Resolving is the process that creates a wiring between bundles.
    Constraints on the wires are statically defined by:</para>

    <itemizedlist>
      <listitem>
        <para>Any mandatory requirement must be matched to at least one
        capability in the same namespace provided by any of the resolved
        bundles, including itself and the system bundle.</para>
      </listitem>

      <listitem>
        <para>The required execution environments as defined by the
        Bundle-RequiredExecutionEnvironment header.</para>
      </listitem>

      <listitem>
        <para>Native code</para>
      </listitem>

      <listitem>
        <para>Import and export packages (the DynamicImport-Package header is
        ignored in this phase)</para>
      </listitem>

      <listitem>
        <para>Required bundles, which import all exported packages from a
        bundle as defined in <xref
        linkend="framework.module.requiringbundles"/>.</para>
      </listitem>

      <listitem>
        <para>Fragments, which provide their contents and definitions to the
        host as defined in <xref
        linkend="framework.module.fragmentbundles"/></para>
      </listitem>
    </itemizedlist>

    <para>A bundle can only be resolved when a number of constraints are
    satisfied:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Execution Environment</emphasis> - The underlying VM
        implements at least one of the execution environments listed in the
        Bundle-RequiredExecutionEnvironment header. See <xref
        linkend="framework.namespaces.osgi.ee"/>.</para>
      </listitem>

      <listitem>
        <para><emphasis>Native code</emphasis> - The native code dependencies
        specified in the Bundle-NativeCode header must be resolved. See <xref
        linkend="framework.module-loading.native.code.libraries"/>.</para>
      </listitem>
    </itemizedlist>

    <para>The resolving process is then a constraint-solving algorithm that
    can be described in terms of requirements on wiring relations. The
    resolving process is an iterative process that searches through the
    solution space.</para>

    <para>A bundle can be resolved if the following conditions are met:</para>

    <itemizedlist>
      <listitem>
        <para>All its mandatory requirements are satisfied</para>
      </listitem>

      <listitem>
        <para>All its mandatory imports are wired</para>
      </listitem>

      <listitem>
        <para>All its mandatory required bundles are available and their
        exports wired</para>
      </listitem>
    </itemizedlist>

    <para>A wire is only created when the following conditions are met:</para>

    <itemizedlist>
      <listitem>
        <para>The importer's version range matches the exporter's version. See
        <xref linkend="framework.module-semantic.versioning"/>.</para>
      </listitem>

      <listitem>
        <para>The importer specifies all mandatory attributes from the
        exporter. See <xref linkend="i2515263"/>.</para>
      </listitem>

      <listitem>
        <para>All the importer's attributes match the attributes of the
        corresponding exporter. See <xref linkend="i2480178"/></para>
      </listitem>

      <listitem>
        <para>Implied packages referring to the same package as the wire are
        wired to the same exporter. See <xref linkend="i3127019"/>.</para>
      </listitem>

      <listitem>
        <para>The wire is connected to a valid exporter.</para>
      </listitem>
    </itemizedlist>

    <para>The following list defines the preferences, if multiple choices are
    possible, in order of decreasing priority:</para>

    <itemizedlist>
      <listitem>
        <para>A resolved exporter must be preferred over an unresolved
        exporter.</para>
      </listitem>

      <listitem>
        <para>An exporter with a higher version is preferred over an exporter
        with a lower version.</para>
      </listitem>

      <listitem>
        <para>An exporter with a lower bundle ID is preferred over a bundle
        with a higher ID.</para>
      </listitem>
    </itemizedlist>

    <section xml:id="framework.module-import.export.same.package">
      <title>Importing and Exporting the Same Package</title>

      <para>If a bundle has both import and export definitions for the
      <emphasis>same</emphasis> package, then the Framework needs to decide
      which to choose.</para>

      <para>It must first try to resolve the overlapping import definition.
      The following outcomes are possible:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>External</emphasis> - If this resolves to an export
          statement in another bundle, then the overlapping export definition
          in this bundle is discarded.</para>
        </listitem>

        <listitem>
          <para><emphasis>Internal</emphasis> - If it is resolved to an export
          statement in this bundle, then the overlapping import definition in
          this bundle is discarded.</para>
        </listitem>

        <listitem>
          <para><emphasis>Unresolved</emphasis> - There is no matching export
          definition. In this case the framework is free to discard either the
          overlapping export definition or overlapping import definition in
          this bundle. If the export definition is discarded and the import
          definition is not optional then the bundle will fail to
          resolve.</para>
        </listitem>
      </itemizedlist>

      <para>The above only applies to the import and export package
      definitions of a bundle. For namespaces other than
      <code>osgi.wiring.package</code>, a requirement definition of a bundle
      may be wired to a capability definition of that same bundle.</para>
    </section>
  </section>

  <section xml:id="i2570775">
    <title>Runtime Class Loading</title>

    <para>Each bundle installed in the Framework must not have an associated
    class loader until after it is resolved. After a bundle is resolved, the
    Framework must create one class loader for each bundle that is not a
    fragment. The framework may delay creation of the class loader until it is
    actually needed.</para>

    <para>One class loader per bundle allows all resources within a bundle to
    have package level access to all other resources in the bundle within the
    same package. This class loader provides each bundle with its own
    namespace, to avoid name conflicts, and allows resource sharing with other
    bundles.</para>

    <para>This class loader must use the wiring as calculated in the resolving
    process to find the appropriate exporters. If a class is not found in the
    imports, additional headers in the manifest can control the searching of
    classes and resources in additional places.</para>

    <para>The following sections define the factors that influence the runtime
    class loading and then define the exact search order the Framework must
    follow when a class or resource is loaded.</para>

    <section xml:id="framework.module.bundleclasspath">
      <title>Bundle Class Path</title>

      <para>JAR, ZIP, directories, etc. are called
      <emphasis>containers</emphasis>. Containers contain
      <emphasis>entries</emphasis> organized in hierarchical paths. During
      runtime, an entry from a bundle can actually come from different
      containers because of attached fragments. The order in which an entry
      can be found is significant because it can shadow other entries. For a
      bundle, the search order for a named entry is:</para>

      <itemizedlist>
        <listitem>
          <para>First the container of the (host) bundle</para>
        </listitem>

        <listitem>
          <para>Then the (optional) fragment containers in ascending id
          order</para>
        </listitem>
      </itemizedlist>

      <para>This search order is called the <emphasis>entry path</emphasis>. A
      <emphasis>resource</emphasis> (or class) is not loaded via the entry
      path, but it is loaded through the <emphasis>bundle class
      path</emphasis>. The bundle class path provides an additional
      indirection on top of the entry path. It defines an ordered list of
      <emphasis>container paths</emphasis>. Each container path can be found
      on the entry path.</para>

      <para>Each container, independent of any other containers, can be a
      multi-release container. See <xref
      linkend="framework.module-multireleasecontainer"/>.</para>

      <para>The full stop (<code>'.' \u002E</code>) container path is a
      synonym for the solidus (<code>'/' \u002F</code>) or the root of a
      container. The full stop is the default value for a bundle or fragment
      if no Bundle-ClassPath header is specified.</para>

      <para>The Bundle-ClassPath manifest header must conform to the following
      syntax:</para>

      <programlisting>Bundle-ClassPath ::= entry ( ',' entry )*
entry            ::= target ( ';' target )* ( ';' parameter ) *
target           ::= path | '.'     // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/></programlisting>

      <para>The Framework must ignore any unrecognized parameters.</para>

      <para>The content of the <emphasis>effective</emphasis> bundle class
      path is constructed from the bundle's Bundle-ClassPath header,
      concatenated with the Bundle-ClassPath headers of any fragments, in
      ascending bundle id order. The effective Bundle-ClassPath is calculated
      during resolve time, however, a dynamically attached fragment can append
      elements at the end if the Framework supports dynamically attached
      fragments.</para>

      <para>An element from the bundle's Bundle-ClassPath header refers to the
      first match when searched through the entry path, while a fragment's
      Bundle-ClassPath can refer only to an entry in its own container.</para>

      <para>An example can illustrate this:</para>

      <programlisting>A: Bundle-ClassPath: .,resource.jar
B: Fragment-Host: A</programlisting>

      <para>The previous example uses an effective bundle class path
      of:</para>

      <programlisting>/, resource.jar, B:/</programlisting>

      <para>The first element / is the root of a container. The bundle always
      has a root and can therefore always be found in the (host) bundle. The
      second element is first looked up in the host bundle's container, and if
      not found, the entry is looked up in the container of <code>B</code>.
      The Framework must use the first entry that matches. The last element in
      the effective bundle class path is the / from fragment <code>B</code>;
      the / is the default because there is no Bundle-ClassPath specified.
      However, a fragment can only refer to an internal entry. This full stop
      therefore refers to the root of the container of fragment
      <code>B</code>. Assuming, fragment <code>B</code> contains an entry for
      <code>resource.jar</code> and bundle <code>A</code> does not, then the
      search order must be:</para>

      <programlisting>A:/
B:resource.jar
B:/</programlisting>

      <para>The Framework must ignore a container path in the bundle
      class-path if the container cannot be located when it is needed, which
      can happen at any time after the bundle is resolved. However, the
      Framework should publish a Framework Event of type <code>INFO</code>
      once with an appropriate message for each entry that cannot be located
      at all.</para>

      <para>An entry on the Bundle-ClassPath can refer to a directory in the
      container. However, it is not always possible to establish the
      directory's existence. For example, directories can be omitted in
      JAR/ZIP files. In such a case, a Framework must probe the directory to
      see if any resources can be found in this directory. That is, even if
      the directory construct is absent in the container, if resources can be
      found assuming this directory, than it must still be chosen for the
      Bundle-ClassPath.</para>

      <para>A host bundle can allow a fragment to insert code ahead of its own
      code by naming a container in its Bundle-ClassPath that will be provided
      by a fragment. Fragments can never unilaterally insert code ahead of
      their host's bundle class path. The following example illustrates the
      possibilities of the bundle class path in more detail:</para>

      <programlisting>A: Bundle-SymbolicName: A
   Bundle-ClassPath: /,required.jar,optional,default.jar
   <emphasis>content ...</emphasis>
   required.jar
   default.jar
B: Bundle-SymbolicName: B
   Bundle-ClassPath: fragment.jar
   Fragment-Host: A
   <emphasis>content ...</emphasis>
   optional/
            <emphasis>content ...</emphasis>
   fragment.jar</programlisting>

      <para>The names of the bundle class path elements indicate their
      intention. The <code>required.jar</code> is a container that provides
      mandatory functionality, it is packaged in bundle A. The
      <code>optional</code> container is a directory containing optional
      classes, and the <code>default.jar</code> is a JAR entry with backup
      code. In this example, the effective bundle class path is:</para>

      <programlisting>A:/
A:required.jar
B:optional
A:default.jar
B:fragment.jar</programlisting>

      <para>This will expand to the following (logical) search order for a
      resource <code>X.class</code>:</para>

      <programlisting>    A:/X.class
    A:required.jar!X.class
    B:optional/X.class
    A:default.jar!X.class
    B:fragment.jar!X.class</programlisting>

      <para>The exclamation mark (!) indicates a load from a JAR
      resource.</para>

      <section xml:id="framework.module-multireleasecontainer">
        <title>Multi-release Container</title>

        <para>A container can be a <emphasis>multi-release
        container</emphasis> . A multi-release container supports versioned
        directories as specified in <xref
        linkend="framework.module-ref.multireleasejar"/>. When a container is
        a multi-release container, that is, the container has a
        <code>META-INF/MANIFEST.MF</code> manifest which specifies</para>

        <programlisting>Multi-Release: true</programlisting>

        <para>then the Framework must search the container's versioned
        directories when attempting to locate an entry in the
        container.</para>

        <para>Support for multi-release containers must only be active on Java
        9 and later. On Java 8 and earlier, the container must be treated as a
        non-multi-release container.</para>
      </section>
    </section>

    <section xml:id="framework.module.dynamicimportpackage">
      <title>Dynamic Import Package</title>

      <para>Dynamic imports are matched to export definitions (to form package
      wirings) during class loading, and therefore do not affect module
      resolution. Dynamic imports apply only to packages for which no wire has
      been established and no definition could be found in any other way.
      Dynamic import is used as a last resort.</para>

      <programlisting>DynamicImport-Package ::= dynamic-description 
           ( ',' dynamic-description )*
dynamic-description ::= wildcard-names ( ';' parameter )*
wildcard-names      ::= wildcard-name ( ';' wildcard-name )*
wildcard-name       ::= package-name 
            | ( package-name '.*' )   // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/>
            | '*' </programlisting>

      <para>No directives are architected by the Framework for
      DynamicImport-Package. Arbitrary matching attributes may be specified.
      The following matching attributes are architected by the
      Framework:</para>

      <itemizedlist>
        <listitem>
          <para><code>version</code> -- A version range to select the version
          of an export definition. The default value is 0.0.0 .</para>
        </listitem>

        <listitem>
          <para><code>bundle-symbolic-name</code> - The bundle symbolic name
          of the exporting bundle.</para>
        </listitem>

        <listitem>
          <para><code>bundle-version</code> - a version range to select the
          bundle version of the exporting bundle. The default value is
          <code>0.0.0</code>.</para>
        </listitem>
      </itemizedlist>

      <para>Packages may be named explicitly or by using wild-carded
      expressions such as <code>org.foo.*</code> and <code>*</code>. The
      wildcard can stand for any suffix, including multiple sub-packages. If a
      wildcard is used, then the package identified by the prefix must
      <emphasis>not</emphasis> be included. That is, <code>org.foo.*</code>
      will include all sub-packages of <code>org.foo</code> but it must not
      include package <code>org.foo</code> itself.</para>

      <para>Dynamic imports must be searched in the order in which they are
      specified. The order is particularly important when package names with
      wildcards are used. The order will then determine the order in which
      matching occurs. This means that the more specific package
      specifications should appear before the broader specifications. For
      example, the following DynamicImport-Package header indicates a
      preference for packages supplied by ACME:</para>

      <programlisting>DynamicImport-Package: *;vendor=acme, *</programlisting>

      <para>If multiple packages need to be dynamically imported with
      identical parameters, the syntax permits a list of packages, separated
      by semicolons, to be specified before the parameters.</para>

      <para>During class loading, the package of the class being loaded is
      compared against the specified list of (possibly wild-carded) package
      names. Each matching package name is used in turn to attempt to wire to
      an export using the same rules as Import-Package. If a wiring attempt is
      successful (taking any <code>uses</code> constraints into account), the
      search is forwarded to the exporter's class loader where class loading
      continues. The wiring must not subsequently be modified, even if the
      class cannot be loaded. This implies that once a package is dynamically
      resolved, subsequent attempts to load classes or resources from that
      package are treated as normal imports.</para>

      <para>In order for a DynamicImport-Package to be resolved to an export
      statement, all attributes of the dynamic import definition must match
      the attributes of the export statement. All mandatory arbitrary
      attributes (as specified by the exporter, see <xref linkend="i2515263"/>
      ) must be specified in the dynamic import definition and match.</para>

      <para>Once a wire is established, any <code>uses</code> constraints from
      the exporter must be obeyed for further dynamic imports.</para>

      <para>Dynamic imports are very similar to optional packages, see <xref
      linkend="i2548181"/>, but differ in the fact that they are handled after
      the bundle is resolved.</para>
    </section>

    <section xml:id="framework.module.parentdelegation">
      <title>Parent Delegation</title>

      <para>The Framework must always delegate any package that starts with
      <code>java.</code> to the parent class loader.</para>

      <para>Certain Java virtual machines, also Oracle's VMs, appear to make
      the erroneous assumption that the delegation to the parent class loader
      always occurs. This implicit assumption of strictly hierarchical class
      loader delegation can result in <code>NoClassDefFoundErrors</code>. This
      happens if the virtual machine implementation expects to find its own
      implementation classes from any arbitrary class loader, requiring that
      packages loaded from the boot class loader not be restricted to only the
      <code>java.*</code> packages.</para>

      <para>Other packages that must be loaded from the boot class loader can
      therefore be specified with the System property:</para>

      <programlisting>org.osgi.framework.bootdelegation</programlisting>

      <para>This property must contain a list with the following
      format:</para>

      <programlisting>org.osgi.framework.bootdelegation ::= boot-description 
            ( ',' boot-description )*
boot-description    ::= package-name        // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/>
            | ( package-name '.*' )           
            | '*' </programlisting>

      <para>The <code>.*</code> wildcard means deep matching, that is,
      <code>com.acme.*</code>, matches any sub-package of package
      <code>com.acme</code>, however, it does not match <code>com.acme</code>.
      Packages that match this list must be loaded from the parent class
      loader. The <code>java.*</code> prefix is always implied; it does not
      have to be specified.</para>

      <para>The single wildcard means that the Framework must always delegate
      to the parent class loader first, which is the same as the Release 3
      behavior.</para>

      <para>For example, when running on an OpenJDK, it may be necessary to
      specify a value like:</para>

      <programlisting>org.osgi.framework.bootdelegation=sun.*,com.sun.*</programlisting>

      <para>With such a property value, the Framework must delegate all
      <code>java.*</code>, <code>sun.*</code>, and <code>com.sun.*</code>
      packages to the parent class loader.</para>
    </section>

    <section xml:id="framework.module.overallsearchorder">
      <title>Overall Search Order</title>

      <para>Frameworks must adhere to the following rules for class or
      resource loading. When a bundle's class loader is requested to load a
      class or find a resource, the search must be performed in the following
      order:</para>

      <orderedlist>
        <listitem>
          <para>If the class or resource is in a <code>java.*</code> package,
          the request is delegated to the parent class loader; otherwise, the
          search continues with the next step. If the request is delegated to
          the parent class loader and the class or resource is not found, then
          the search terminates and the request fails.</para>
        </listitem>

        <listitem>
          <para>If the class or resource is from a package included in the
          boot delegation list
          (<code>org.osgi.framework.bootdelegation</code>), then the request
          is delegated to the parent class loader. If the class or resource is
          found there, the search ends.</para>
        </listitem>

        <listitem xml:id="i3128823">
          <para>If the class or resource is in a package that is imported
          using Import-Package or was imported dynamically in a previous load,
          then the request is delegated to the exporting bundle's class
          loader; otherwise the search continues with the next step. If the
          request is delegated to an exporting class loader and the class or
          resource is not found, then the search terminates and the request
          fails.</para>
        </listitem>

        <listitem xml:id="i3187927">
          <para>If the class or resource is in a package that is imported from
          one or more other bundles using Require-Bundle, the request is
          delegated to the class loaders of the other bundles, in the order in
          which they are specified in this bundle's manifest. This entails a
          depth-first strategy; all required bundles are searched before the
          bundle class path is used. If the class or resource is not found,
          then the search continues with the next step.</para>
        </listitem>

        <listitem>
          <para>Search the bundle's embedded class path, see <xref
          linkend="framework.module.bundleclasspath"/>. If the class or
          resource is not found, then continue with the next step.</para>
        </listitem>

        <listitem>
          <para>If the class or resource is in a package that is exported by
          the bundle or the package is imported by the bundle (using
          Import-Package or Require-Bundle), then the search ends and the
          class or resource is not found.</para>
        </listitem>

        <listitem>
          <para>Otherwise, if the class or resource is in a package that is
          imported using DynamicImport-Package, then a dynamic import of the
          package is now attempted. An exporter must conform to any implied
          package constraints. If an appropriate exporter is found, a wire is
          established so that future loads of the package are handled in step
          <xref linkend="i3128823"/>. If a dynamic wire is not established,
          then the request fails.</para>
        </listitem>

        <listitem>
          <para>If the dynamic import of the package is established, the
          request is delegated to the exporting bundle's class loader. If the
          request is delegated to an exporting class loader and the class or
          resource is not found, then the search terminates and the request
          fails.</para>
        </listitem>
      </orderedlist>

      <para>When delegating to another bundle class loader, the delegated
      request enters this algorithm at step <xref linkend="i3187927"/>.</para>

      <para>The following non-normative flow chart illustrates the search
      order described above:</para>

      <figure pgwide="1">
        <title>Flow chart for class loading (non-normative)</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="7.508in"
                       contentwidth="7.418in"
                       fileref="class-loading-flowchart.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section xml:id="framework.module.parentclassloader">
      <title>Parent Class Loader</title>

      <para>The set of implicitly visible packages are all <code>java.*</code>
      packages, since these packages are required by the Java runtime, and
      using multiple versions at the same time is not easy. For example, all
      objects must extend the same Object class.</para>

      <para>A bundle must not declare exports for <code>java.*</code>
      packages; doing so is an error and any such bundle must fail to install
      or update. A bundle may declare imports for <code>java.*</code>
      packages; but this is for resolution purposes only. All other packages
      visible through the parent class loader must be hidden from executing
      bundles.</para>

      <para>However, the Framework must explicitly export relevant packages
      from the parent class loader. The system property</para>

      <programlisting><code>org.osgi.framework.system.packages</code> </programlisting>

      <para>contains the export packages descriptions for the system bundle.
      This property employs the standard Export-Package manifest header
      syntax:</para>

      <programlisting>org.osgi.framework.system.packages ::= package-description
                                       ( ',' package-description )*</programlisting>

      <para>Some classes on the boot class path assume that they can use any
      class loader to load other classes on the boot class path, which is not
      true for a bundle class loader. Framework implementations should attempt
      to load these classes from the boot class path.</para>

      <para>The system bundle (bundle ID zero) is used to export packages from
      the parent class loader. Export definitions from the system bundle are
      treated like normal exports, meaning that they can have version numbers,
      and are used to resolve import definitions as part of the normal bundle
      resolving process. Other bundles may provide alternative implementations
      of the same packages.</para>

      <para>The set of export definitions for the parent class loader can
      either be set by this property or calculated by the Framework. The
      export definitions must have the <code>bundle-symbolic-name</code> and
      <code>bundle-version</code> attributes with the implementation-specific
      bundle symbolic name and bundle version value of the system
      bundle.</para>

      <para>Exposing packages from the parent class loader in this fashion
      must also take into account any <code>uses</code> directives of the
      underlying packages. For example, the definition of
      <code>javax.crypto.spec</code> must declare its usage of
      <code>javax.crypto.interfaces</code> and
      <code>javax.crypto</code>.</para>
    </section>

    <section xml:id="i3178562">
      <title>Resource Loading</title>

      <para>A resource in a bundle can be accessed through the class loader of
      that bundle but it can also be accessed with the <xref
      linkend="org.osgi.framework.Bundle.getResource-String-"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.framework.Bundle.getEntry-String-"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.framework.Bundle.findEntries-String-String-boolean-"
      xrefstyle="hyperlink"/> and other methods or the methods on the <xref
      linkend="framework.wiring"/>. All these methods return a
      <code>URL</code> object or an <code>Enumeration</code> object of
      <code>URL</code> objects. The URLs are called <emphasis>bundle entry
      URLs</emphasis>. The schemes for the URLs returned by these methods can
      differ and are implementation dependent.</para>

      <para>Bundle entry URLs are normally created by the Framework, however,
      in certain cases bundles need to manipulate the URL to find related
      resources. The Framework is therefore required to ensure that:</para>

      <itemizedlist>
        <listitem>
          <para>Bundle entry URLs must be hierarchical (See <xref
          linkend="i3086040"/> )</para>
        </listitem>

        <listitem>
          <para>Usable as a context for constructing another URL.</para>
        </listitem>

        <listitem>
          <para>The <code>java.net.URLStreamHandler</code> class used for a
          bundle entry URL must be available to the <code>java.net.URL</code>
          class to setup a URL that uses the protocol scheme defined by the
          Framework.</para>
        </listitem>

        <listitem>
          <para>The <code>getPath</code> method for a bundle entry URL must
          return an absolute path (a path that starts with '/') to a resource
          or entry in a bundle. For example, the URL returned from
          <code>getEntry("myimages/test.gif")</code> must have a path of
          <code>/myimages/test.gif</code>.</para>
        </listitem>
      </itemizedlist>

      <para>For example, a class can take a URL to an <code>index.html</code>
      bundle resource and map URLs in this resource to other files in the same
      JAR directory.</para>

      <programlisting>public class BundleResource implements HttpContext{
    URL  root;  // to index.html in bundle
    URL getResource( String resource ) {
        return new URL( root, resource );
    }
    ...
}</programlisting>
    </section>

    <section xml:id="i2581530">
      <title>Bundle Cycles</title>

      <para>Multiple required bundles can export the same package. Bundles
      which export the same package involved in a require bundle cycle can
      lead to lookup cycles when searching for classes and resources from the
      package. Consider the following definitions:</para>

      <programlisting>A: Require-Bundle: B, C
C: Require-Bundle: D</programlisting>

      <para>These definitions are depicted in <xref
      linkend="i2650348"/>.</para>

      <figure xml:id="i2650348">
        <title>Depth First search with Require Bundle</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.743in"
                       contentwidth="7.418in"
                       fileref="require-bundle-depth-first.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Each of the bundles exports the package <code>p</code>. In this
      example, bundle <code>A</code> requires bundle <code>B</code>, and
      bundle <code>C</code> requires bundle <code>D</code>. When bundle
      <code>A</code> loads a class or resource from package <code>p</code>,
      then the required bundle search order is the following: <code>B</code>,
      <code>D</code>, <code>C</code>, <code>A</code>. This is a depth first
      search order because required bundles are searched before the bundle
      class path is searched (see step <xref linkend="i3187927"/> ). The
      required bundles are searched in the order that they appear in the
      Require-Bundle header. The depth first search order can introduce
      endless search cycles if the dependency graph has a cycle in it.</para>

      <para>Using the previous setup, a cycle can be introduced if bundle
      <code>D</code> requires bundle <code>A</code> as depicted in <xref
      linkend="i3024353"/>.</para>

      <programlisting>D: Require-Bundle: A</programlisting>

      <figure xml:id="i3024353">
        <title>Cycles</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.743in"
                       contentwidth="7.418in" fileref="bundle-cycles.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>When the class loader for bundle <code>A</code> loads a class or
      resource from package <code>p</code> then the bundle search order would
      be the following: B, B, B,... if cycles were not taken into
      account.</para>

      <para>Since a cycle was introduced each time bundle D is reached the
      search will recurs back to A and start over. The framework must prevent
      such dependency cycles from causing endless recursive lookups.</para>

      <para>To avoid endless looping, the Framework must mark each bundle upon
      first visiting it and not explore the required bundles of a previously
      visited bundle. Using the visited pattern on the dependency graph above
      will result in the following bundle search order: <code>B</code>,
      <code>D</code>, <code>C</code>, <code>A</code>.</para>
    </section>

    <section>
      <title>Code Executed Before Started</title>

      <para>Packages exported from a bundle are exposed to other bundles as
      soon as the bundle has been resolved. This condition could mean that
      another bundle could call methods in an exported package
      <emphasis>before</emphasis> the bundle exporting the package is
      started.</para>
    </section>

    <section xml:id="framework.module-finding-a-bundle">
      <title>Finding a Bundle</title>

      <para>There are scenarios where a bundle is required in code that has no
      access to a Bundle Context. For this reason, the framework provides the
      following <emphasis>Framework Util</emphasis> methods:</para>

      <itemizedlist>
        <listitem>
          <para><code>getBundle(Class)</code> - The <xref
          linkend="org.osgi.framework.FrameworkUtil.getBundle-Class-"/> method
          allows code to find the bundle of a class. The method returns
          <code>null</code> when the class does not originate from a
          bundle.</para>
        </listitem>

        <listitem>
          <para><code>getBundle(ClassLoader)</code> - The <xref
          linkend="org.osgi.framework.FrameworkUtil.getBundle-ClassLoader-"/>
          method allows code to find the bundle of a class loader. The method
          returns an empty Optional when the class loader is not associated
          with a specific bundle.</para>
        </listitem>
      </itemizedlist>

      <para>In an OSGi system, not all objects belong to types loaded from a
      bundle class loader. For example, the boot class path loader.</para>
    </section>
  </section>

  <section xml:id="framework.module-loading.native.code.libraries">
    <title>Loading Native Code Libraries</title>

    <para>Dependency on native code is expressed in the Bundle-NativeCode
    header. The framework must verify this header and satisfy its dependencies
    before it attempts to resolve the bundle. However, a bundle can be
    installed without an exception if the header is properly formatted
    according to its syntax. If the header contains invalid information, or
    can not be satisfied, errors will be reported during resolving.</para>

    <para>A Java VM has a special way of handling native code. When a class
    loaded by a bundle's class loader attempts to load a native library, by
    calling <code>System.loadLibrary</code>, the <code>findLibrary</code>
    method of the bundle's class loader must be called to return the file path
    in which the Framework has made the requested native library available.
    The parameter to the <code>findLibrary</code> method is the name of the
    library in operating system independent form, like <code>http</code>. The
    bundle class loader can use the <code>mapLibraryName</code> method from
    the VM to map this name to an operating system dependent name, like
    <code>libhttp.so</code>.</para>

    <para>The bundle's class loader must attempt to find the native library by
    examining the selected native code clauses, if any, of the bundle
    associated with the class loader and each attached fragment. Fragments are
    examined in ascending bundle ID order. If the library is not referenced in
    any of the selected native code clauses then <code>null</code> must be
    returned which allows the parent class loader to search for the native
    library.</para>

    <para xml:id="i2623559">The bundle must have the required
    <code>RuntimePermission</code>[<code>loadLibrary.</code> &lt;
    <code>library name</code>&gt;] in order to load native code in the OSGi
    framework.</para>

    <para>The Bundle-NativeCode manifest header must conform to the following
    syntax:</para>

    <programlisting>Bundle-NativeCode   ::= nativecode 
        ( ',' nativecode )* ( ',' optional ) ?
nativecode          ::= path ( ';' path )*    // See <xref
        linkend="framework.general.syntax" xrefstyle="template:%n"/>
                        ( ';' parameter )*
optional            ::= '*'</programlisting>

    <para>When locating a path in a bundle the Framework must attempt to
    locate the path relative to the root of the bundle that contains the
    corresponding native code clause in its manifest header.</para>

    <para>The following attributes are architected:</para>

    <itemizedlist>
      <listitem>
        <para><code>osname</code> - Name of the operating system. The value of
        this attribute must be the name of the operating system upon which the
        native libraries run. A number of canonical names are defined in <xref
        linkend="framework.module.os-names"/>.</para>
      </listitem>

      <listitem>
        <para><code>osversion</code> - The operating system version. The value
        of this attribute must be a version range as defined in <xref
        linkend="i3189032"/>.</para>
      </listitem>

      <listitem>
        <para><code>processor</code> - The processor architecture. The value
        of this attribute must be the name of the processor architecture upon
        which the native libraries run. A number of canonical names are
        defined in <xref linkend="framework.module.processor-names"/>.</para>
      </listitem>

      <listitem>
        <para><code>language</code> - The ISO code for a language. The value
        of this attribute must be the name of the language for which the
        native libraries have been localized.</para>
      </listitem>

      <listitem>
        <para><code>selection-filter</code> - A selection filter. The value of
        this attribute must be a filter expression that indicates if the
        native code clause should be selected or not.</para>
      </listitem>
    </itemizedlist>

    <para>If a selection-filter attribute contains an invalid filter, then the
    bundle must fail to install with a Bundle Exception of type <xref
    linkend="org.osgi.framework.BundleException.NATIVECODE_ERROR"
    xrefstyle="hyperlink"/>. The following is a typical example of a native
    code declaration in a bundle's manifest:</para>

    <programlisting>Bundle-NativeCode: lib/http.dll ; lib/zlib.dll; «
        osname = Windows95 ; «
        osname = Windows98 ; «
        osname = WindowsNT ; «
        processor = x86 ; «
        selection-filter = «
            "(com.acme.windowing=win32)"; «
        language = en ; «
        language = se , «
    lib/solaris/libhttp.so ; «
        osname = Solaris ; «
        osname = SunOS ; «
        processor = sparc, «
    lib/linux/libhttp.so ; «
        osname = Linux ; «
        processor = mips; «
        selection-filter = «
            "(com.acme.windowing=gtk)"</programlisting>

    <para>If multiple native code libraries need to be installed on one
    platform, they must all be specified in the same clause for that
    platform.</para>

    <para>If a Bundle-NativeCode clause contains duplicate parameter entries,
    the corresponding values must be <code>OR</code>'ed together. This feature
    must be carefully used because the result is not always obvious. This is
    highlighted by the following example:</para>

    <programlisting>// The effect of this header has probably 
// not the intended effect!
Bundle-NativeCode: lib/http.DLL ; «
    osname = Windows95 ; «
    osversion = "3.1" ; «
    osname = WindowsXP ; «
    osversion = "5.1" ; «
    processor = x86</programlisting>

    <para>The above example implies that the native library will load on
    Windows XP 3.1 and later, which was probably not intended. The single
    clause should be split in two clauses:</para>

    <programlisting>Bundle-NativeCode: lib/http.DLL ; «
        osname = Windows95 ; «
        osversion = 3.1; «
        processor = x86, «
    lib/http.DLL ; «
        osname = WindowsXP ; «
        osversion = 5.1; «
        processor = x86</programlisting>

    <para>Any paths specified in the matching clause must be present in the
    bundle or any of its attached fragments for a bundle to resolve. The
    framework must report a Bundle Exception with the
    <code>NATIVECODE_ERROR</code> as error code when the bundle can not be
    resolved due to a native code problem.</para>

    <para>If the optional '*' is specified at the end of the Bundle-NativeCode
    manifest header, the bundle will still resolve even if the
    Bundle-NativeCode header has no matching clauses.</para>

    <para>The following is a typical example of a native code declaration in a
    bundle's manifest with an optional clause:</para>

    <programlisting>Bundle-NativeCode: lib/win32/winxp/optimized.dll; «
        lib/win32/native.dll ; «
        osname = WindowsXP ; «
        processor = x86 , «
    lib/win32/native.dll ; «
        osname = Windows95 ; «
        osname = Windows98 ; «
        osname = WindowsNT ; «
        osname = Windows2000; «
        processor = x86 , «
        *</programlisting>

    <para>Frameworks must convert a Bundle-NativeCode header to a requirement
    in the <code>osgi.native</code> namespace when used in the Wiring API, see
    <xref linkend="framework.wiring"/>. Each native code clause specified in a
    Bundle-NativeCode header is converted into a filter component for the
    <code>osgi.native</code> requirement filter directive using the following
    architected matching attributes:</para>

    <itemizedlist>
      <listitem>
        <para><code>osgi.native.osname</code> - Uses the approximate equals
        (~=) filter type to evaluate the value specified by the
        <code>osname</code> Bundle-NativeCode attribute.</para>
      </listitem>

      <listitem>
        <para><code>osgi.native.osversion</code> - Create a
        <code>VersionRange</code> using the value specified by the osversion
        Bundle-NativeCode attribute and then create a filter string out of the
        <code>VersionRange</code>.</para>
      </listitem>

      <listitem>
        <para><code>osgi.native.processor</code> - Uses the approximate equals
        (~=) filter type to evaluate the value specified by the
        <code>processor</code> Bundle-NativeCode attribute.</para>
      </listitem>

      <listitem>
        <para><code>osgi.native.language</code> - Uses the approximate equals
        (~=) filter type to evaluate the value specified by the
        <code>language</code> Bundle-NativeCode attribute.</para>
      </listitem>
    </itemizedlist>

    <para>In cases where the same Bundle-NativeCode attribute is specified
    multiple times within the same clause then the filter components for each
    value for that attribute are ORed together. For example, if osname
    attribute is specified as both "Windows95" and "Windows7" then the
    resulting filter will contain:</para>

    <programlisting>(|
        (osgi.native.osname~=Windows95)
        (osgi.native.osname~=Windows7)
)</programlisting>

    <para>If the <code>selection-filter</code> Bundle-NativeCode attribute is
    specified then the specified filter is included as a component of the
    native code clauses AND filter type. Consider the following
    Bundle-NativeCode header which contains a single clause:</para>

    <programlisting>Bundle-NativeCode: «
      lib/http.dll; lib/zlib.dll; «
      osname=Windows95; «
      osname=Windows98; «
      osname=WindowsNT; «
      processor=x86; «
      selection-filter="(com.acme.windowing=win32)";  «
      language=en; «
      language=se</programlisting>

    <para>This clause would get translated into the following AND filter
    type:</para>

    <programlisting>Require-Capability: «
      osgi.native; «
      filter:=" «
        (&amp; «
          (| «
            (osgi.native.osname~=Windows95) «
            (osgi.native.osname~=Windows98) «
            (osgi.native.osname~=WindowsNT) «
          ) «
          (osgi.native.processor~=x86) «
          (| «
            (osgi.native.language~=en) «
            (osgi.native.language~=se) «
          ) «
          (com.acme.windowing=win32) «
        )"</programlisting>

    <para>The Bundle-NativeCode header may specify multiple clauses, each
    having their own list of native code paths and set of matching attributes.
    Instead of using a separate <code>osgi.native</code> requirement for each
    Bundle-NativeCode clause, the complete Bundle-NativeCode header is
    specified as a single <code>osgi.native</code> requirement. This is done
    by using an OR filter type using all of the individual Bundle-NativeCode
    clause filter components (as specified above) as components of a single
    filter directive. Consider the following Bundle-NativeCode header which
    contains three clauses:</para>

    <programlisting>Bundle-NativeCode: «
      lib/http.dll; lib/zlib.dll; «
        osname=Windows95; «
        osname=Windows98; «
        osname=WindowsNT; «
        processor=x86; «
        selection-filter = "(com.acme.windowing=win32)"; «
        language=en; «
        language=se, «
      lib/solaris/libhttp.so; «
        osname=Solaris; «
        osname=SunOS; «
        processor=sparc, «
      lib/linux/libhttp.so; «
        osname=Linux; «
        processor=mips; «
        selection-filter="(com.acme.windowing=gtk)"</programlisting>

    <para>This Bundle-NativeCode header would get translated into the
    following <code>osgi.native</code> filter directive:</para>

    <programlisting>(|
  (&amp;
    (|
      (osgi.native.osname~=Windows95)
      (osgi.native.osname~=Windows98)
      (osgi.native.osname~=WindowsNT)
    )
    (osgi.native.processor~=x86)
    (|
      (osgi.native.language~=en)
      (osgi.native.language~=se)
    )
    (com.acme.windowing=win32)
  )
  (&amp;
    (|
      (osgi.native.osname~=Solaris)
      (osgi.native.osname~=SunOs)
    )
    (osgi.native.processor~=sparc)
  )
  (&amp;
    (osgi.native.osname~=Linux)
    (osgi.native.processor~=mips)
    (com.acme.windowing=gtk)
  )
)</programlisting>

    <para>If the optional '*' is specified at the end of the Bundle-NativeCode
    manifest header, then the native code for the bundle is considered to be
    optional. When the Framework converts a Bundle-NativeCode header into an
    <code>osgi.native</code> requirement which is designated as optional then
    the requirement resolution directive must be set to
    <code>optional</code></para>

    <section xml:id="framework.module.nativecodealgorithm">
      <title>Native Code Algorithm</title>

      <para>In the description of this algorithm, [x] represents the value of
      the launching property x (see <xref
      linkend="framework.lifecycle.launchingproperties"/>) and ~= represents
      the match operation. The match operation is a case insensitive
      comparison. Certain properties can be aliased. In those cases, the
      manifest header should contain the generic name for that property but
      the Framework should attempt to include aliases when it matches.</para>

      <para>The Framework must select the native code clause using the
      following algorithm:</para>

      <orderedlist>
        <listitem xml:id="framework.module-nativecodealg1">
          <para>Only select the native code clauses for which the following
          expressions all evaluate to true.</para>

          <itemizedlist>
            <listitem>
              <para><code>osname ~= [org.osgi.framework.os.name]</code> or
              <code>osname</code> is not specified</para>
            </listitem>

            <listitem>
              <para><code>processor ~= [org.osgi.framework.processor]</code>
              or <code>processor</code> is not specified</para>
            </listitem>

            <listitem>
              <para><code>osversion</code> range includes
              <code>[org.osgi.framework.os.version]</code> or
              <code>osversion</code> is not specified</para>
            </listitem>

            <listitem>
              <para><code>language ~= [org.osgi.framework.language]</code> or
              <code>language</code> is not specified</para>
            </listitem>

            <listitem>
              <para><code>selection-filter</code> evaluates to
              <code>true</code> when using the values of the launching
              properties or <code>selection-filter</code> is not
              specified</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>If no native clauses were selected in step <xref
          linkend="framework.module-nativecodealg1"/>, this algorithm is
          terminated. A Bundle Exception is thrown if the optional clause is
          not present.</para>
        </listitem>

        <listitem xml:id="framework.module-nativecodealg3">
          <para>The selected clauses are now sorted in the following priority
          order:</para>

          <itemizedlist>
            <listitem>
              <para><code>osversion</code>: floor of the
              <code>osversion</code> range in descending order,
              <code>osversion</code> not specified</para>
            </listitem>

            <listitem>
              <para><code>language</code>: language specified, language not
              specified</para>
            </listitem>

            <listitem>
              <para>Position in the Bundle-NativeCode manifest header: lexical
              left to right.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The first clause of the sorted clauses from step <xref
          linkend="framework.module-nativecodealg3"/> must be used as the
          selected native code clause.</para>
        </listitem>
      </orderedlist>

      <para>If a native code library in a selected native code clause cannot
      be found within the bundle then the bundle is still allowed to resolve.
      A missing native code library will result in an error being thrown at
      runtime when the bundle attempts to load the native code (for example,
      by invoking the method <code>System.loadLibrary</code>).</para>

      <para>If the selected clause contains multiple libraries with the same
      base file name then only the lexically left most library with that base
      file name will be used. For example, if the selected clause contains the
      libraries <code>lib1/http.dll; lib2/http.dll; lib3/foo.dll;
      a/b/c/http.dll</code> then only <code>http.dll</code> in
      <code>lib1</code> and <code>foo.dll</code> will be used.</para>

      <para>Designing a bundle native code header can become quickly
      complicated when different operating systems, libraries, and languages
      are used. The best practice for designing the header is to place all
      parameters in a table. Every targeted environment is then a row in that
      table. See <xref linkend="framework.module.nativecode.table"/> for an
      example.</para>

      <table xml:id="framework.module.nativecode.table">
        <title>Native code table</title>

        <tgroup cols="6">
          <colspec colnum="1" colwidth="3.2*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="0.8*"/>

          <colspec colnum="4" colwidth="0.8*"/>

          <colspec colnum="5" colwidth="0.8*"/>

          <colspec colnum="6" colwidth="3*"/>

          <thead>
            <row>
              <?dbfo rotated-width="0.5in"?>

              <entry valign="bottom">Libraries</entry>

              <entry rotate="1"><?dbfo orientation="90"?>osname</entry>

              <entry rotate="1"><?dbfo orientation="90"?>osversion</entry>

              <entry rotate="1"><?dbfo orientation="90"?>processor</entry>

              <entry rotate="1"><?dbfo orientation="90"?>language</entry>

              <entry rotate="1"><?dbfo orientation="90"?>filter</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para>nativecodewin32.dll, delta.dll</para></entry>

              <entry><para><code>win32</code></para></entry>

              <entry><para/></entry>

              <entry><para><code>x86</code></para></entry>

              <entry><para><code>en</code></para></entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry><para>nativecodegtk.so</para></entry>

              <entry><para><code>linux</code></para></entry>

              <entry><para/></entry>

              <entry><para><code>x86</code></para></entry>

              <entry><para><code>en</code></para></entry>

              <entry><para><code>(com.acme.windowing=gtk)</code></para></entry>
            </row>

            <row>
              <entry><para>nativecodeqt.so</para></entry>

              <entry><para><code>linux</code></para></entry>

              <entry><para/></entry>

              <entry><para><code>x86</code></para></entry>

              <entry><para><code>en</code></para></entry>

              <entry><para><code>(com.acme.windowing=qt)</code></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>This table makes it easier to detect missing combinations. This
      table is then mapped to the Bundle-NativeCode header in the following
      code example.</para>

      <programlisting>Bundle-NativeCode:  nativecodewin32.dll; «
        delta.dll; «
        osname=win32; «
        processor=x86; «
        language=en, «
    nativecodegtk.so; «
        osname=linux; «
        processor=x86; «
        language=en; «
        selection-filter= «
            "(com.acme.windowing=gtk)", «
    nativecodeqt.so; «
        osname=linux; «
        processor=x86; «
        language=en; «
        selection-filter = «
            "(com.acme.windowing=qt)"</programlisting>
    </section>

    <section>
      <title>Considerations Using Native Libraries</title>

      <para>There are some restrictions on loading native libraries due to the
      nature of class loaders. In order to preserve namespace separation in
      class loaders, only one class loader can load a native library as
      specified by an absolute path. Loading of a native library file by
      multiple class loaders (from multiple bundles, for example) will result
      in a linkage error.</para>

      <para>Care should be taken to use multiple libraries with the same file
      name but in a different directory in the JAR. For example,
      <code>foo/http.dll</code> and <code>bar/http.dll</code>. The Framework
      must only use the first library and ignore later defined libraries with
      the same name. In the example, only <code>foo/http.dll</code> will be
      visible.</para>

      <para>A native library is unloaded only when the class loader that
      loaded it has been garbage collected.</para>

      <para>When a bundle is uninstalled or updated, any native libraries
      loaded by the bundle remain in memory until the bundle's class loader is
      garbage collected. The garbage collection will not happen until all
      references to objects in the bundle have been garbage collected, and all
      bundles importing packages from the updated or uninstalled bundle are
      refreshed. This implies that native libraries loaded from the system
      class loader always remain in memory because the system class loader is
      never garbage collected.</para>

      <para>It is not uncommon that native code libraries have dependencies on
      other native code libraries. This specification does not support these
      dependencies, it is assumed that native libraries delivered in bundles
      should not rely on other native libraries.</para>
    </section>
  </section>

  <section xml:id="framework.module.localization">
    <title>Localization</title>

    <para>A bundle contains a significant amount of information that is
    human-readable. Some of this information may require different
    translations depending on the user's language, country, and any special
    variant preferences, a.k.a. the <emphasis>locale</emphasis>. This section
    describes how a bundle can provide common translations for the manifest
    and other configuration resources depending on a locale.</para>

    <para>Bundle localization entries share a common base name. To find a
    potential localization entry, an underscore (<code>'_' \u005F</code>) is
    added plus a number of suffixes, separated by another underscore, and
    finally appended with the suffix <code>.properties</code> . The suffixes
    are defined in <code>java.util.Locale</code>. The order for the suffixes
    this must be:</para>

    <itemizedlist>
      <listitem>
        <para>language</para>
      </listitem>

      <listitem>
        <para>country</para>
      </listitem>

      <listitem>
        <para>variant</para>
      </listitem>
    </itemizedlist>

    <para>For example, the following files provide manifest translations for
    English, Dutch (Belgium and the Netherlands) and Swedish.</para>

    <programlisting>OSGI-INF/l10n/bundle_en.properties
OSGI-INF/l10n/bundle_nl_BE.properties
OSGI-INF/l10n/bundle_nl_NL.properties
OSGI-INF/l10n/bundle_sv.properties</programlisting>

    <para>The Framework searches for localization entries by appending
    suffixes to the localization base name according to a specified locale and
    finally appending the <code>.properties</code> suffix. If a translation is
    not found, the locale must be made more generic by first removing the
    variant, then the country and finally the language until an entry is found
    that contains a valid translation. For example, looking up a translation
    for the locale <code>en_GB_welsh</code> will search in the following
    order:</para>

    <programlisting>OSGI-INF/l10n/bundle_en_GB_welsh.properties
OSGI-INF/l10n/bundle_en_GB.properties
OSGI-INF/l10n/bundle_en.properties
OSGI-INF/l10n/bundle.properties</programlisting>

    <para>This allows localization files for more specific locales to override
    localizations from less specific localization files.</para>

    <section xml:id="i3212953">
      <title>Finding Localization Entries</title>

      <para>Localization entries can be contained in the bundle or delivered
      in fragments. The framework must search for localization entries using
      the following search rules based on the bundle type:</para>

      <itemizedlist>
        <listitem>
          <para><code>fragment bundle</code> - If the bundle is a
          <emphasis>resolved</emphasis> fragment, then the search for
          localization data must delegate to the attached host bundle with the
          highest version. If the fragment is not resolved, then the framework
          must search the fragment's JAR for the localization entry.</para>
        </listitem>

        <listitem>
          <para><code>other bundle</code> - The framework must first search in
          the bundle's JAR for the localization entry. If the entry is not
          found and the bundle has fragments, then the attached fragment JARs
          must be searched for the localization entry.</para>
        </listitem>
      </itemizedlist>

      <para>The bundle's class loader is not used to search for localization
      entries. Only the contents of the bundle and its attached fragments are
      searched. The bundle will still be searched for localization entries
      even if the full stop (<code>'.' \u002E</code>) is not in the bundle
      class path.</para>
    </section>

    <section xml:id="i3189742">
      <title>Manifest Localization</title>

      <para>Localized values are stored in property resources within the
      bundle. The default base name of the bundle localization property files
      is <code>OSGI-INF/l10n/bundle</code>. The Bundle-Localization manifest
      header can be used to override the default base name for the
      localization files. This location is relative to the root of the bundle
      and bundle fragments.</para>

      <para>A localization entry contains key/value entries for localized
      information. All headers in a bundle's manifest can be localized.
      However, the Framework must always use the non-localized versions of
      headers that have Framework semantics.</para>

      <para>A localization key can be specified as the value of a bundle's
      manifest header using the following syntax:</para>

      <programlisting>header-value ::= '%'text
text ::= &lt; any value which is both a valid manifest headervalue
   and a valid property key name &gt;</programlisting>

      <para>For example, consider the following bundle manifest
      entries:</para>

      <programlisting>Bundle-Name: %acme bundle
Bundle-Vendor: %acme corporation
Bundle-Description: %acme description
Bundle-Activator: com.acme.bundle.Activator
Acme-Defined-Header: %acme special header</programlisting>

      <para>User-defined headers can also be localized. Spaces in the
      localization keys are explicitly allowed.</para>

      <para>The previous example manifest entries could be localized by the
      following entries in the manifest localization entry
      OSGI-INF/l10n/bundle.properties.</para>

      <programlisting># bundle.properties
acme\ bundle=The ACME Bundle
acme\ corporation=The ACME Corporation
acme\ description=The ACME Bundle provides all of the ACME\ services
acme\ special\ header=user-defined Acme Data</programlisting>

      <para>The above manifest entries could also have French localizations in
      the manifest localization entry
      <code>OSGI-INF/l10n/bundle_fr_FR.properties</code>.</para>
    </section>
  </section>

  <section xml:id="framework.module.bundle.validity">
    <title>Bundle Validity</title>

    <para>If the Bundle-ManifestVersion is not specified, then the bundle
    manifest version defaults to 1, and certain Release 4 syntax, such as a
    new manifest header, is ignored rather than causing an error. Release 3
    bundles must be treated according to the Release 3 specification.</para>

    <para>The following (non-exhaustive) list of errors causes a bundle to
    fail to install:</para>

    <itemizedlist>
      <listitem>
        <para>Missing Bundle-SymbolicName.</para>
      </listitem>

      <listitem>
        <para>Duplicate attribute or duplicate directive (except in the
        Bundle-Native code clause).</para>
      </listitem>

      <listitem>
        <para>Multiple imports of a given package.</para>
      </listitem>

      <listitem>
        <para>Export of <code>java.*</code> packages.</para>
      </listitem>

      <listitem>
        <para>Export-Package, Bundle-SymbolicName, or Fragment-Host with a
        mandatory attribute that is not defined.</para>
      </listitem>

      <listitem>
        <para>Installing or updating a bundle to a bundle that has the same
        symbolic name and version as another installed bundle (unless this is
        allowed, see <xref
        linkend="framework.lifecycle.bundleidentifiers"/>).</para>
      </listitem>

      <listitem>
        <para>Any syntactic error (for example, improperly formatted version
        or bundle symbolic name, unrecognized directive value, etc.).</para>
      </listitem>

      <listitem>
        <para>Specification-version and version specified together (for the
        same package(s)) but with different values on manifest headers that
        treat them as synonyms. For example:</para>

        <programlisting>    Import-Package p;specification-version=1;version=2</programlisting>

        <para>would fail to install, but:</para>

        <programlisting>    Import-Package p;specification-version=1,q;version=2</programlisting>

        <para>would not be an error.</para>
      </listitem>

      <listitem>
        <para>The manifest lists a <code>OSGI-INF/permissions.perm</code> file
        but no such file is present.</para>
      </listitem>

      <listitem>
        <para>Bundle-ManifestVersion value not equal to 2, unless the
        Framework specifically recognizes the semantics of a later
        release.</para>
      </listitem>

      <listitem>
        <para>Requiring the same bundle symbolic name more than once.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="framework.module.requiringbundles">
    <title>Requiring Bundles</title>

    <para>The Framework supports a mechanism where bundles can be directly
    wired to other bundles. The following sections define the relevant headers
    and then discuss the possible scenarios. At the end, some of the
    (sometimes unexpected) consequences of using Require-Bundle are
    discussed.</para>

    <section xml:id="framework.module.requirebundle">
      <title>Require-Bundle</title>

      <para>The Require-Bundle manifest header contains a list of required
      bundle symbolic names, with optional attribute assertions. These bundles
      are searched after the imports are searched but before the bundle's
      class path is searched. Fragment or extension bundles cannot be
      required.</para>

      <para>The framework must take <emphasis>all</emphasis> exported packages
      from a required bundle, including any packages exported by attached
      fragments, and wire these packages to the requiring bundle.</para>

      <para>The Require-Bundle manifest header must conform to the following
      syntax:</para>

      <programlisting>Require-Bundle      ::= bundle-description 
    ( ',' bundle-description )*
bundle-description  ::= symbolic-name       // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/>
    (';' parameter )*</programlisting>

      <para>The following directives can be used in the Require-Bundle
      header:</para>

      <itemizedlist>
        <listitem>
          <para><code>visibility</code> - If the value is <code>private</code>
          (default), then all visible packages from the required bundles are
          not re-exported. If the value is <code>reexport</code> then bundles
          that require this bundle will transitively have access to these
          required bundle's exported packages. That is, if bundle
          <code>A</code> requires bundle <code>B</code>, and bundle
          <code>B</code> requires bundle <code>C</code> with
          <code>visibility:=reexport</code> then bundle <code>A</code> will
          have access to all bundle <code>C</code>'s exported packages as if
          bundle <code>A</code> had required bundle <code>C</code>.</para>
        </listitem>

        <listitem>
          <para><code>resolution</code> - If the value is
          <code>mandatory</code> (default) then the required bundle must exist
          for this bundle to resolve. If the value is <code>optional</code>,
          the bundle will resolve even if the required bundle does not
          exist.</para>
        </listitem>
      </itemizedlist>

      <para>The following matching attribute is architected by the
      Framework:</para>

      <itemizedlist>
        <listitem>
          <para><code>bundle-version</code> - The value of this attribute is a
          version range to select the bundle version of the required bundle.
          See <xref linkend="i3189032"/>. The default value is
          <code>[0.0.0,</code><phrase
          role="symbol">∞</phrase><code>)</code>.</para>
        </listitem>
      </itemizedlist>

      <para>The Bundle-SymbolicName header can specify further arbitrary
      attributes that must be matched before a bundle is eligible.</para>

      <para>A specific symbolic name can only be required once, listing the
      same symbolic name multiple times must be regarded as an install
      error.</para>

      <para>Requiring bundles must get wired to all exported packages of all
      their required bundles including exported packages from their attached
      fragments. This means that any mandatory attributes on these exports
      must be ignored. However, if a required bundle's exported package is
      substituted for an imported package, then the requiring bundles must get
      wired to the same exported package that the required bundle is wired to
      ensure class space consistency.</para>

      <para>For example, assume that bundle <code>A</code> exports and imports
      package <code>p</code> and bundle <code>B</code> requires bundle
      <code>A</code>:</para>

      <programlisting>Bundle A
Export-Package: p;x=1;mandatory:=x
Import-Package: p

Bundle B
Require-Bundle: A</programlisting>

      <para>In this constellation, bundle <code>B</code> will get package
      <code>p</code> from the same source as bundle A. Bundle <code>A</code>
      can get the package from itself if it is chosen as an exporter for p,
      but it can also get the package from another bundle because it also
      imports it. In all cases, bundle <code>B</code> must use exactly the
      same exporter for package <code>p</code> as bundle
      <code>A</code>.</para>

      <para>A given package may be available from more than one of the
      required bundles. Such packages are named <emphasis>split
      packages</emphasis> because they derive their contents from different
      bundles. If these different bundles provide the same classes
      unpredictable shadowing of classes can arise, see <xref
      linkend="i3198951"/>. However, split packages without shadowing are
      explicitly permitted.</para>

      <para>For example, take the following setup:</para>

      <programlisting>A:  Require-Bundle: B
    Export-Package: p
B:  Export-Package: p;partial=true;mandatory:=partial</programlisting>

      <para>If bundle <code>C</code> imports package <code>p</code>, it will
      be wired to package <code>A.p</code>, however the contents will come
      from <code>B.p</code> &gt; <code>A.p</code>. The mandatory attribute on
      bundle <code>B</code>'s export definition ensures that bundle
      <code>B</code> is not accidentally selected as exporter for package
      <code>p</code>. Split packages have a number of drawbacks that are
      discussed in <xref linkend="i3198951"/>.</para>

      <para>Resources and classes from a split package must be searched in the
      order in which the required bundles are specified in the
      <code>Require-Bundle</code> header.</para>

      <para>As an example, assume that a bundle requires a number of required
      bundles and a number of language resources (also bundles) that are
      optional.</para>

      <programlisting>Require-Bundle: com.acme.facade;visibility:=reexport, «
 com.acme.bar.one;visibility:=reexport, «
 com.acme.bar.two;visibility:=reexport, «
 com.acme.bar._nl;visibility:=reexport;resolution:=optional, «
 com.acme.bar._en;visibility:=reexport;resolution:=optional</programlisting>

      <para>A bundle may both import packages (via Import-Package) and require
      one or more bundles (via Require-Bundle), but if a package is imported
      via Import-Package, it is not also visible via Require-Bundle:
      Import-Package takes priority over Require-Bundle, and packages which
      are exported by a required bundle and imported via Import-Package must
      <emphasis>not</emphasis> be treated as split packages.</para>

      <para>In order to be allowed to require a named bundle, the requiring
      bundle must have <code>BundlePermission[&lt;bundle symbolic name&gt;,
      REQUIRE]</code>, where the bundle symbolic name is the name of the
      bundle that is required. The required bundle must be able to provide the
      bundle and must therefore have <code>BundlePermission[&lt;bundle
      symbolic name&gt;, PROVIDE]</code>, where the name designates the
      requiring bundle. In the case a fragment bundle requires another bundle,
      the Bundle Permission must be checked against the fragment bundle's
      Protection Domain.</para>
    </section>

    <section>
      <title>Split Package Compatibility</title>

      <para>A package is a split package whenever there are multiple
      <emphasis>sources</emphasis> for the package; only bundles using the
      Require-Bundle header can have split packages.</para>

      <para>A source is a bundle that provides the given package. Both the
      required bundles as well as the requiring bundle can act as a source.
      The required bundles and the requiring bundle can only contribute their
      exported packages.</para>

      <para>Exported split packages from two bundles are compatible if the
      package sources for one are a subset of the other.</para>
    </section>

    <section xml:id="i3198951">
      <title>Issues With Requiring Bundles</title>

      <para>The preferred way of wiring bundles is to use the
      <code>Import-Package</code> and <code>Export-Package</code> headers
      because they couple the importer and exporter to a much lesser extent.
      Bundles can be refactored to have a different package composition
      without causing other bundles to fail.</para>

      <para>The Require-Bundle header provides a way for a bundle to bind to
      all the exports of another bundle, regardless of what those exports are.
      Though this can seem convenient at first, it has a number of
      drawbacks:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Split Packages</emphasis> - Classes from the same
          package can come from different bundles with Require bundle, such a
          package is called a split package. Split packages have the following
          drawbacks:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>Completeness</emphasis> - Split packages are
              open ended, it is difficult to guarantee that all the intended
              pieces of a split package have actually been included.</para>
            </listitem>

            <listitem>
              <para><emphasis>Ordering</emphasis> - If the same classes are
              present in more than one required bundle, then the ordering of
              Require-Bundle is significant. A wrong ordering can cause hard
              to trace errors, similar to the traditional class path model of
              Java.</para>
            </listitem>

            <listitem>
              <para><emphasis>Performance</emphasis> - A class must be
              searched in all providers when packages are split. This
              potentially increases the number of times that a
              <code>ClassNotFoundException</code> must be thrown which can
              potentially introduce a significant overhead.</para>
            </listitem>

            <listitem>
              <para><emphasis>Confusing</emphasis> - It is easy to find a
              setup where there is lots of potential for confusion. For
              example, the following setup is non-intuitive.</para>

              <programlisting>   A: Export-Package: p;uses:=q
      Import-Package: q
   B: Export-Package: q
   C: Export-Package: q
   D: Require-Bundle: B, C
      Import-Package: p</programlisting>
            </listitem>
          </itemizedlist>

          <figure>
            <title>Split packages and package constraints</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="1.561in"
                           contentwidth="7.418in" fileref="split-packages.svg"/>
              </imageobject>
            </mediaobject>
          </figure>

          <para>In this example, bundle <code>D</code> merges the split
          package <code>q</code> from bundles <code>B</code> and bundle
          <code>C</code>, however, importing package <code>p</code> from
          bundle <code>A</code> puts a uses constraint on package
          <code>p</code> for package <code>q</code>. This implies that bundle
          <code>D</code> can see the valid package <code>q</code> from bundle
          <code>B</code> but also the invalid package <code>q</code> from
          bundle <code>C</code>. This wiring is allowed because in almost all
          cases there will be no problem. However, the consistency can be
          violated in the rare case when package <code>C.q</code> contains
          classes that are also in package <code>B.q</code>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Mutable Exports</emphasis> - The feature of
          <code>visibility:=reexport</code> that the export signature of the
          requiring bundle can unexpectedly change depending on the export
          signature of the required bundle.</para>
        </listitem>

        <listitem>
          <para><emphasis>Shadowing</emphasis> - The classes in the requiring
          bundle that are shadowed by those in a required bundle depend on the
          export signature of the required bundle and the classes the required
          bundle contains. (By contrast, Import-Package, except with
          <code>resolution:=optional</code>, shadows whole packages regardless
          of the exporter.)</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="framework.module.fragmentbundles">
    <title>Fragment Bundles</title>

    <para>Fragments are bundles that can be <emphasis>attached</emphasis> to
    one or more <emphasis>host bundles</emphasis> by the Framework. Attaching
    is done as part of resolving: the Framework appends the relevant
    definitions of the fragment bundles to the host's definitions before the
    host is resolved. Fragments are therefore treated as part of the host,
    including any permitted headers; they must not have their own class loader
    though fragments must have their own Protection Domain.</para>

    <para>Fragments can be attached to multiple hosts with the same symbolic
    name but different versions. If multiple fragments with the same symbolic
    name match the same host, then the Framework must only select one
    fragment, this must be the fragment with the highest version.</para>

    <para>A key use case for fragments is providing translation files for
    different locales. This allows the translation files to be treated and
    shipped independently from the main application bundle.</para>

    <para>When an attached fragment is updated, the content of the previous
    fragment must remain attached to its host bundles. The new content of the
    updated fragment must not be allowed to attach to the host bundles until
    the Framework is restarted or the host bundle is refreshed. During this
    time, an attached fragment will have two versions: the old version,
    attached to the old version of the host, and a new fragment bundle that
    can get attached to a new version or to a different host bundle. The exact
    configuration can be discovered with the <xref
    linkend="framework.wiring"/>.</para>

    <para>When attaching a fragment bundle to a host bundle the Framework must
    perform the following steps:</para>

    <orderedlist>
      <listitem>
        <para>Append the import definitions for the Fragment bundle that do
        not <emphasis>conflict</emphasis> with an import definition of the
        host to the import definitions of the host bundle. A Fragment can
        provide an import statement for a private package of the host. The
        private package in the host is hidden in that case.</para>
      </listitem>

      <listitem>
        <para>Append the Require-Bundle entries of the fragment bundle that do
        not conflict with a Require-Bundle entry of the host to the
        Require-Bundle entries of the host bundle.</para>
      </listitem>

      <listitem>
        <para>Append the export definitions of a Fragment bundle to the export
        definitions of the host bundle unless the exact definition (directives
        and attributes must match) is already present in the host. Fragment
        bundles can therefore add additional exports for the same package
        name.</para>
      </listitem>

      <listitem>
        <para>Append the Provide-Capability clauses of the fragment to the
        Provide-Capability clauses of the host</para>
      </listitem>

      <listitem>
        <para>Append the Require-Capability clauses of the fragment to the
        Require-Capability clauses of the host</para>
      </listitem>
    </orderedlist>

    <para>A host and a fragment conflict when they cannot resolve to provide a
    consistent class space. If a conflict is found, the Fragment bundle is not
    attached to the host bundle.</para>

    <para>A Fragment bundle must enter the resolved state only if it has been
    successfully attached to at least one host bundle.</para>

    <para>During runtime, the fragment's JAR is searched after the host's
    bundle class path as described in <xref linkend="i3076126"/>.</para>

    <para>A Fragment bundle can not be required by another bundle with the
    Require-Bundle header.</para>

    <section xml:id="framework.module.fragmenthost">
      <title>Fragment-Host</title>

      <para>The Fragment-Host manifest header links the fragment to its
      potential hosts. It must conform to the following syntax:</para>

      <programlisting>Fragment-Host       ::= bundle-description
bundle-description  ::= symbolic-name 
                            ( ';' parameter )* // See <xref
          linkend="framework.general.syntax" xrefstyle="template:%n"/></programlisting>

      <para>The following directives are architected by the Framework for
      Fragment-Host:</para>

      <itemizedlist>
        <listitem>
          <para><code>extension</code> - Indicates this extension is a system
          or boot class path extension. It is only applicable when the
          Fragment-Host is the System Bundle. This is discussed in <xref
          linkend="framework.module.extensionbundles"/>. The following values
          are supported:</para>

          <itemizedlist>
            <listitem>
              <para><code>framework</code> - The fragment bundle is a
              Framework extension bundle.</para>
            </listitem>
          </itemizedlist>

          <para>The fragment must be the bundle symbolic name of the
          implementation specific system bundle or the alias
          <code>system.bundle</code>. The Framework should fail to install an
          extension bundle when the bundle symbolic name is not referring to
          the system bundle.</para>
        </listitem>
      </itemizedlist>

      <para>The following attributes are architected by the Framework for
      Fragment-Host:</para>

      <itemizedlist>
        <listitem>
          <para><code>bundle-version</code> - The version range to select the
          host bundle. If a range is used, then the fragment can attach to
          multiple hosts. See <xref
          linkend="framework.module-semantic.versioning"/>. The default value
          is <code>[0.0.0,</code><phrase
          role="symbol">∞</phrase><code>)</code>.</para>
        </listitem>
      </itemizedlist>

      <para>The Fragment-Host header can assert arbitrary attributes that must
      be matched before a host is eligible.</para>

      <para>When a fragment bundle is attached to a host bundle, it logically
      becomes part of it. All classes and resources within the fragment bundle
      must be loaded using the class loader (or <code>Bunde</code> object) of
      its host bundle. The fragment bundles of a host bundle must be attached
      to a host bundle in the order that the fragment bundles are installed,
      which is in ascending bundle ID order. If an error occurs during the
      attachment of a fragment bundle then the fragment bundle must not be
      attached to the host. A fragment bundle must enter the resolved state
      only if it has been successfully attached to one or more host
      bundles.</para>

      <para>In order for a host bundle to allow fragments to attach, the host
      bundle must have <code>BundlePermission[&lt;bundle symbolic
      name&gt;,HOST]</code>. In order to be allowed to attach to a host
      bundle, a fragment bundle must have <code>BundlePermission[&lt;bundle
      symbolic name&gt;,FRAGMENT]</code>.</para>
    </section>

    <section xml:id="i3076126">
      <title>Fragments During Runtime</title>

      <para>All class or resource loading of a fragment is handled through the
      host's class loader or <code>Bundle</code> object, a fragment must never
      have its own class loader, it therefore fails the class and resource
      loading methods of the <code>Bundle</code> object. Fragment bundles are
      treated as if they are an intrinsic part of their hosts.</para>

      <para>Though a fragment bundle does not have its own class loader, it
      still must have a separate Protection Domain when it is not an extension
      fragment. Each fragment can have its own permissions linked to the
      fragment bundle's location and signer.</para>

      <para>A host bundle's class path is searched before a fragment's class
      path. This implies that packages can be split over the host and any of
      its fragments. Searching the fragments must be done in ascending bundle
      ID order. This is the order that the fragment bundles were
      installed.</para>

      <figure xml:id="i3076132">
        <title>Resource/class searching with fragments</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.455in"
                       contentwidth="7.418in"
                       fileref="fragment-resource-searching.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para><xref linkend="i3076132"/> shows a setup with two fragments.
      Bundle <code>B</code> is installed before bundle <code>C</code> and both
      bundle <code>B</code> and bundle <code>C</code> attach to bundle
      <code>A</code>. The following table shows where different packages
      originate in this setup. Note that the order of the append (&gt;) is
      significant.</para>

      <table>
        <title>Effect of fragments on searching</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="2.5*"/>

          <thead>
            <row>
              <entry>Package Requested</entry>

              <entry>From</entry>

              <entry>Remark</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>p</code></entry>

              <entry><code>A.p &gt; B.p</code></entry>

              <entry><para>Bundle <code>A</code> exports package
              <code>p</code>, therefore, it will search its class path for
              <code>p</code>. This class path consists of the JAR and then its
              Fragment bundles.</para></entry>
            </row>

            <row>
              <entry><code>q</code></entry>

              <entry><code>D.q</code></entry>

              <entry><para>The import does not handle split packages and
              package <code>q</code> is imported from bundle <code>D</code>.
              Therefore, <code>C.q</code> is not found.</para></entry>
            </row>

            <row>
              <entry><code>r</code></entry>

              <entry><code>A.r &gt; B.r</code></entry>

              <entry><para>Package <code>r</code> is not imported and
              therefore comes from the class path.</para></entry>
            </row>

            <row>
              <entry><code>s</code></entry>

              <entry><code>C.s</code></entry>

              <entry><para/></entry>
            </row>

            <row>
              <entry><code>t</code></entry>

              <entry><code>B.t &gt; C.t</code></entry>

              <entry><para/></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In the example above, if package <code>p</code> had been imported
      from bundle <code>D</code>, the table would have looked quite different.
      Package p would have come from bundle <code>D</code>, and bundle
      <code>A</code>'s own contents as well as the contents of bundle
      <code>B</code> would have been ignored.</para>

      <para>If package <code>q</code> had bundle <code>D</code>, then the
      class path would have to be searched, and <code>A.q</code> would have
      consisted of <code>A.q &gt; C.q</code>.</para>

      <para>Fragments must remain attached to a host as long as the host
      remains resolved. When a host bundle becomes unresolved, then all its
      attached Fragment bundles must be detached from the host bundle. When a
      fragment bundle becomes unresolved the Framework must:</para>

      <itemizedlist>
        <listitem>
          <para>Detach it from the host</para>
        </listitem>

        <listitem>
          <para>Re-resolve the host bundles</para>
        </listitem>

        <listitem>
          <para>Reattach the remaining attached fragment bundles.</para>
        </listitem>
      </itemizedlist>

      <para>A Fragment bundle can become unresolved by calling the <xref
      linkend="org.osgi.framework.wiring.FrameworkWiring.refreshBundles-Collection-FrameworkListener...-"
      xrefstyle="hyperlink"/> method.</para>
    </section>

    <section>
      <title>Illegal Manifest Header for Fragment Bundles</title>

      <para>The following list contains the headers that must not be used in a
      fragment bundle:</para>

      <itemizedlist>
        <listitem>
          <para><code>Bundle-Activator</code></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="framework.module.extensionbundles">
    <title>Extension Bundles</title>

    <para>Extension bundles can deliver optional parts of the Framework
    implementation. The contents of extension bundles cannot be provided by
    the normal bundles because they need to be loaded by the framework
    implementation.</para>

    <para>Framework extensions are necessary to provide implementation aspects
    of the Framework. For example, a Framework vendor could supply the
    optional services like Permission Admin service and Start Level API with
    Framework extension bundles.</para>

    <para>An extension bundle should use the bundle symbolic name of the
    implementation system bundle, or it can use the alias of the system
    bundle, which is <code>system.bundle</code>.</para>

    <para>The following example uses the Fragment-Host manifest header to
    specify an extension bundle for any Framework implementation.</para>

    <programlisting>Fragment-Host: system.bundle</programlisting>

    <para>The following example uses the Fragment-Host manifest header to
    specify an extension bundle for a specific Framework
    implementation.</para>

    <programlisting>Fragment-Host: com.acme.impl.framework</programlisting>

    <para>The following describe the life cycle of an extension bundle:</para>

    <orderedlist>
      <listitem>
        <para>When an extension bundle is installed it enters the
        <code>INSTALLED</code> state.</para>
      </listitem>

      <listitem>
        <para>The extension bundle is allowed to enter the
        <code>RESOLVED</code> state at the frameworks discretion. For example,
        a framework may choose to immediately resolve the extension after it
        has entered the <code>INSTALLED</code> state. If all requirements of
        an extension bundle are satisfied then resolving the extension bundle
        must not require a framework restart.</para>
      </listitem>

      <listitem>
        <para>If a <code>RESOLVED</code> extension bundle is refreshed then
        the framework must shutdown and the framework must be re-launched. In
        this case a Framework Event is fired of type <xref
        linkend="org.osgi.framework.FrameworkEvent.STOPPED_SYSTEM_REFRESHED"
        xrefstyle="hyperlink"/>.</para>
      </listitem>

      <listitem>
        <para>When a <code>RESOLVED</code> extension bundle is updated or
        <code>UNINSTALLED</code>, it is not allowed to re-enter the
        <code>RESOLVED</code> state. If the extension bundle is refreshed then
        the Framework must shutdown and the framework must be re-launched. In
        this case a Framework Event is fired of type <xref
        linkend="org.osgi.framework.FrameworkEvent.STOPPED_SYSTEM_REFRESHED"
        xrefstyle="hyperlink"/>.</para>
      </listitem>
    </orderedlist>

    <para>It is valid to update an extension bundle to a bundle of another
    type. If the old extension bundle is resolved then it must be attached as
    a fragment to the system bundle. When this bundle is updated the old
    content of the bundle must remain attached to the system bundle until the
    system bundle is refreshed or the extension bundle is refreshed (using the
    Wiring API). This must initiate and Framework shutdown and restart. When
    the framework comes back up the new content of the bundle may be
    resolved.</para>

    <para>All Bundle events should be dispatched for extension bundles as for
    ordinary bundles.</para>

    <section>
      <title>Illegal Manifest Headers for Extension Bundles</title>

      <para>An extension bundle must throw a Bundle Exception if it is
      installed or updated and it specifies any of the following
      headers.</para>

      <itemizedlist>
        <listitem>
          <para><code>Require-Bundle</code></para>
        </listitem>

        <listitem>
          <para><code>Bundle-NativeCode</code></para>
        </listitem>

        <listitem>
          <para><code>DynamicImport-Package</code></para>
        </listitem>

        <listitem>
          <para><code>Bundle-Activator</code></para>
        </listitem>
      </itemizedlist>

      <para>Extension bundles are permitted to specify an Export-Package
      header. Any exported packages specified by an extension bundle must be
      hosted (exported) by the System Bundle when the extension bundle is
      resolved.</para>

      <para>Extension bundles are permitted to specify Import-Package and
      Require-Capability headers to declare dependencies on packages and
      capabilities.</para>
    </section>

    <section>
      <title>Resolving Extensions</title>

      <para>Extension bundles may specify requirements on packages
      (Import-Package) and capabilities (Require-Capability). An extension
      bundle is allowed to become resolved when all of its mandatory
      requirements are wired to valid packages or capabilities.</para>

      <para>Extension bundle requirements may only be wired to packages and
      capabilities provided by the system bundle or another extension bundle
      that is also attached to the system bundle. All other capabilities are
      considered invalid for resolving an extension bundle. This ensures that
      the system bundle wiring never hosts a requirement from an extension
      bundle which is wired to a capability hosted by another bundle other
      than the system bundle.</para>
    </section>

    <section xml:id="framework.module.extensionClassPath">
      <title>Class Path Treatment</title>

      <para>A extension bundle's JAR is appended to the class path of the
      Framework. Extension bundles that are resolved together must have their
      JAR appended in the order in which the extension bundles are installed:
      that is, ascending bundle ID order.</para>
    </section>

    <section xml:id="framework.module.extensionActivator">
      <title>Extension Bundle Activator</title>

      <para>A extension may hook into the Framework initialization and
      shutdown process by specifying an Extension Bundle Activator. The <xref
      linkend="org.osgi.framework.BundleActivator" xrefstyle="hyperlink"/>
      interface defines methods that the Framework invokes when the Framework
      is initialized and shutdown.</para>

      <para>To inform the OSGi environment of a fully qualified class name
      serving as its Extension Bundle Activator, a framework extension
      developer must declare an <code>ExtensionBundle-Activator</code>
      manifest header in the framework extension bundle's manifest file. The
      following is an example of an ExtensionBundle-Activator:</para>

      <programlisting>ExtensionBundle-Activator: com.acme.Activator</programlisting>

      <para>The class acting as an Extension Bundle Activator must implement
      the <code>BundleActivator</code> interface, be declared public, and have
      a public default constructor so an instance of it may be created with
      <code>Class.newInstance</code>.</para>

      <para>Supplying an Extension Bundle Activator is optional and only valid
      for Extension Bundles. For normal Bundles and Fragments, the
      <code>ExtensionBundle-Activator</code> must be ignored.</para>

      <section>
        <title>Framework Initialization and Shutdown</title>

        <para>An Extension Bundle Activator allows a framework extension to
        hook into the Framework initialization and shutdown process. <xref
        linkend="framework.lifecycle.initializing"/> describes how the
        <code>start</code> method for Extension Bundle Activators is called
        during Framework initialization. <xref
        linkend="framework.lifecycle.stopping"/> describes how the
        <code>stop</code> method for Extension Bundle Activators is called
        during Framework shutdown.</para>
      </section>

      <section>
        <title>Installing</title>

        <para>When an extension bundle is installed, the Framework must allow
        the extension to become resolved dynamically, without a Framework
        restart. When an extension bundle is resolved dynamically after
        Framework initialization, then the Extension Bundle Activator start
        method must be called as soon as the extension bundle is resolved.
        This must happen before the Bundle Event of type <code>RESOLVED</code>
        is fired for the extension bundle.</para>
      </section>

      <section>
        <title>Update and Uninstall</title>

        <para>Unlike normal bundles, updating or uninstalling an extension
        bundle does not take effect until the Framework is shutdown and
        restarted. The original content of the extension bundle must remain
        attached to the system bundle and the Extension Bundle Activator must
        not have its stop method called until the Framework is
        shutdown.</para>
      </section>
    </section>

    <section>
      <title>Support Properties</title>

      <para>Frameworks must implement fragments, require bundle, and
      extensions. They must therefore set the following properties to
      <code>true</code>.</para>

      <itemizedlist>
        <listitem>
          <para><code>org.osgi.supports.framework.requirebundle</code></para>
        </listitem>

        <listitem>
          <para><code>org.osgi.supports.framework.fragments</code></para>
        </listitem>

        <listitem>
          <para><code>org.osgi.supports.framework.extension</code></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Security</title>

    <section>
      <title>Extension Bundles</title>

      <para>In an environment that has Java security enabled the Framework
      must perform an additional security check before allowing an extension
      bundle to be installed. In order for an extension bundle to successfully
      install, the Framework must check that the extension bundle has All
      Permission assigned to it. This means that the permissions of an
      extension bundle must be setup before the extension bundle is
      installed.</para>

      <para>All Permission must be granted to extension bundles because they
      will be loaded under the Protection Domain of either the boot class path
      or the Framework implementation. Both of these Protection Domains have
      All Permission granted to them. Attempting to install an extension
      bundle that has not already been granted All Permission must result in a
      Bundle Exception.</para>

      <para>The installer of an extension bundle must have
      <code>AdminPermission[&lt;extension
      bundle&gt;,EXTENSIONLIFECYCLE]</code> to install an extension
      bundle.</para>
    </section>

    <section xml:id="i3174729">
      <title>Bundle Permission</title>

      <para>Most package sharing permissions are based on Package Permission.
      However, fragments and required bundles use the bundle symbolic name to
      handle sharing. The Bundle Permission is used to control this type of
      package sharing.</para>

      <para>The name parameter of the Bundle Permission is a bundle symbolic
      name. The symbolic name is used as the identifier for the
      <emphasis>target bundle</emphasis>. A wild card (<code>".*"
      \u002E,\u002A</code>) is permitted at the end of the name.</para>

      <para>For example, for fragment bundle A to attach to its host bundle
      <code>B</code> then fragment bundle A requires
      <code>BundlePermission("B", "fragment")</code> so that A is permitted to
      target host bundle <code>B</code>. The direction of the actions is
      depicted in <xref linkend="i2970717"/>.</para>

      <figure xml:id="i2970717">
        <title>Permissions and bundle sharing</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="0.825in"
                       contentwidth="4.811in"
                       fileref="permissions-bundle-sharing.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The following actions are architected:</para>

      <itemizedlist>
        <listitem>
          <para><code>provide</code> - Permission to provide packages to the
          target bundle.</para>
        </listitem>

        <listitem>
          <para><code>require</code> - Permission to require packages from the
          target bundle.</para>
        </listitem>

        <listitem>
          <para><code>host</code> - Permission to attach to the target
          fragment bundle.</para>
        </listitem>

        <listitem>
          <para><code>fragment</code> - Permission to attach as a fragment to
          the target host bundle.</para>
        </listitem>
      </itemizedlist>

      <para>When a fragment contains a Require-Bundle header, the Framework
      must check the permission against the domain of the fragment.</para>
    </section>

    <section xml:id="i3119557">
      <title>Package Permission</title>

      <para>Bundles can only import and export packages for which they have
      the required permission. A <code>PackagePermission</code> must be valid
      across all versions of a package.</para>

      <para>A <code>PackagePermission</code> has two parameters:</para>

      <itemizedlist>
        <listitem>
          <para>The name, either the name of the target package (with a
          possible wildcard character at the end) or a filter expression that
          can verify the exporting bundle. A filter expression can test for
          the package name with the <code>package.name</code> key. A filter
          can only be used for an <code>IMPORT</code> action. Filters are
          described in <xref
          linkend="framework.security.filterbasedpermissions"/>.</para>
        </listitem>

        <listitem>
          <para>The action, either <code>IMPORT</code> or
          <code>EXPORTONLY</code>.</para>
        </listitem>
      </itemizedlist>

      <para>For example, the following Package Permission permits to import
      any package from a bundle downloaded from ACME:</para>

      <programlisting>PackagePermission("(location=http://www.acme.com/*",IMPORT)</programlisting>

      <para>When a fragment adds imports and exports to the host, the
      framework must check the protection domain of the fragment and not of
      the related host.</para>
    </section>

    <section xml:id="i3188274">
      <title>Resource Permissions</title>

      <para>A Framework must always give a bundle the <code>RESOURCE,
      METADATA, and CLASS AdminPermission</code> actions to access the
      resources contained within:</para>

      <itemizedlist>
        <listitem>
          <para>Itself</para>
        </listitem>

        <listitem>
          <para>Any attached fragments</para>
        </listitem>

        <listitem>
          <para>Any resources from imported packages</para>
        </listitem>
      </itemizedlist>

      <para>A resource in a bundle may also be accessed by using certain
      methods on <code>Bundle</code>. The caller of these methods must have
      <code>AdminPermission[bundle, RESOURCE]</code>.</para>

      <para>If the caller does not have the necessary permission, a resource
      is not accessible and <code>null</code> must be returned. Otherwise, a
      <code>URL</code> object to the resource must be returned. These URLs are
      called <emphasis>bundle resource URLs</emphasis>. Once the
      <code>URL</code> object is returned, no further permission checks are
      performed when the contents of the resource are accessed. The
      <code>URL</code> object must use a scheme defined by the Framework
      implementation.</para>

      <para>Bundle resource URLs are normally created by the Framework,
      however, in certain cases bundles need to manipulate the URL to find
      related resources. For example, a URL can be constructed to a resource
      that is in the same directory as a given resource.</para>

      <para>URLs that are not constructed by the Framework must follow
      slightly different security rules due to the design of the
      <code>java.net.URL</code> class. Not all constructors of the URL class
      interact with the URL Stream Handler classes (the implementation
      specific part). Other constructors call at least the
      <code>parseURL</code> method in the URL Stream Handler where the
      security check can take place. This design makes it impossible for the
      Framework check the permissions during construction of a bundle resource
      URL.</para>

      <para>The following constructors use the <code>parseURL</code> method
      and are therefore checked when a bundle resource URL is
      constructed.</para>

      <programlisting>URL(String spec)
URL(URL context, String spec)
URL(URL context, String spec, URLStreamHandler handler)</programlisting>

      <para>When one of these constructors is called for a bundle resource
      URL, the implementation of the Framework must check the caller for the
      necessary permissions in the <code>parseURL</code> method. If the caller
      does not have the necessary permissions then the <code>parseURL</code>
      method must throw a Security Exception. This will cause a Malformed URL
      Exception to be thrown by the URL constructor. If the caller has the
      necessary permissions, then the URL object is setup to access the bundle
      resource without further checks.</para>

      <para>The following java.net.URL constructors do not call the
      <code>parseURL</code> method in the URL Stream Handler, making it
      impossible for the Framework to verify the permission during
      construction.</para>

      <programlisting>URL(String protocol, String host, int port,String file)
URL(String protocol, String host, int port, String file, URLStreamHandlerhandler)
URL(String protocol, String host, String file)</programlisting>

      <para>Bundle resource URLs that are created with these constructors
      cannot perform the permission check during creation and must therefore
      delay the permission check. When the content of the URL is accessed, the
      Framework must throw a Security Exception if the caller does not have
      <code>AdminPermission[bundle, RESOURCE]</code> for the bundle referenced
      by the URL.</para>
    </section>

    <section>
      <title>Capability Permission</title>

      <para>The Capability Permission provides a means to limit access to
      certain Capabilities when security is on. A Capability Permission is a
      Filter based Permission, as described in <xref
      linkend="framework.security.filterbasedpermissions"/>, giving access to
      the following additional property:</para>

      <itemizedlist>
        <listitem>
          <para><code>capability.namespace</code> - The namespace of the
          requirement or provided capability.</para>
        </listitem>
      </itemizedlist>

      <para>The filter can also assert information from the
      <emphasis>target</emphasis> bundle. The target bundle is always the
      bundle that provides the capability. This means that a requirer can be
      restricted to receive a capability from a specific bundle.</para>

      <para>Capabilities in a namespace for which the resolving bundle has no
      permission are not available to other bundles. Requirements in a
      namespace for which a bundle has no permission can never be
      satisfied.</para>

      <para>The Capability Permission has the following actions:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.framework.CapabilityPermission.REQUIRE"
          xrefstyle="hyperlink"/> - Imply permission to require the given
          namespace. The target bundle that can be asserted in the filter is
          the bundle providing the capability.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.CapabilityPermission.PROVIDE"
          xrefstyle="hyperlink"/> - Imply permission to provide a capability
          in the given namespace, the target bundle is the bundle that is
          checked for the permission.</para>
        </listitem>
      </itemizedlist>

      <para>The Capability Permission has the following constructors:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.framework.CapabilityPermission.CapabilityPermission-String-String-"
          xrefstyle="hyperlink"/> - Constructor to set the filter and actions.
          This constructor is also used to verify the <code>provide</code>
          action.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.framework.CapabilityPermission.CapabilityPermission-String-Map-Bundle-String-"
          xrefstyle="hyperlink"/> - Special constructor to verify the
          permission against the namespace. The bundle is the bundle providing
          the capability.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Permission Checks</title>

      <para>Since multiple bundles can export permission classes with the same
      class name, the Framework must make sure that permission checks are
      performed using the correct class. For example, a bundle that calls the
      checkPermission method provides an instance of the Permission
      class:</para>

      <programlisting>void foo(String name) {
   checkPermission(new FooPermission(name,"foo"));
}</programlisting>

      <para>This class of this Permission instance comes from a particular
      source. Permissions can only be tested against instances that come from
      the same source.</para>

      <para>Therefore, the Framework needs to look up permissions based on
      <emphasis>class</emphasis> rather than <emphasis>class name</emphasis>.
      When it needs to instantiate a permission it must use the class of the
      permission being checked to do the instantiation. This is a complication
      for Framework implementers; bundle programmers are not affected.</para>

      <para>Consider the following example:</para>

      <programlisting>  Bundle A 
        Import-Package: p
       Export-Package: q
  Bundle B 
        Import-Package: p</programlisting>

      <itemizedlist>
        <listitem>
          <para>Bundle <code>A</code> uses a <code>p.FooService</code>. Usage
          of this class checks <code>q.FooPermission</code> whenever one of
          its methods is invoked.</para>
        </listitem>

        <listitem>
          <para>Bundle <code>B</code> has a <code>FooPermission</code> in its
          Protection Domain in a (Conditional) Permission Info object.</para>
        </listitem>

        <listitem>
          <para>Bundle <code>B</code> invokes a method in the
          <code>FooService</code> that was given by bundle
          <code>A</code>.</para>
        </listitem>

        <listitem>
          <para>The <code>FooService</code> calls the
          <code>checkPermission</code> method with a new
          <code>FooPermission</code> instance.</para>
        </listitem>

        <listitem>
          <para>The Framework must use a <code>FooPermission</code> object
          that is from the same class loader as the given
          <code>FooPermission</code> object before it can call the
          <code>implies</code> method. In this case, the
          <code>FooPermission</code> class comes from package
          <code>A.q</code>.</para>
        </listitem>
      </itemizedlist>

      <para>After the permission check, bundle <code>B</code> will have a
      <code>FooPermission</code> instantiated using a class from a package it
      does not import. It is therefore possible that the Framework has to
      instantiate multiple variations of the <code>FooPermission</code> class
      to satisfy the needs of different bundles.</para>
    </section>
  </section>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i3311293"><title>Java Virtual Machine
      Specification</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/specs/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024180"><title>The Standard for the Format of
      ARPA Internet Text Messages</title>STD 11, RFC 822, UDEL, August
      1982<?line-break ?><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc822.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024184"><title>The Hypertext Transfer Protocol -
      HTTP/1.1</title>RFC 2068 DEC, MIT/LCS, UC Irvine, January
      1997<?line-break ?><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc2068.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024191"><title>Java Language Specification: Java
      SE 8 Edition</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024195"><title>A String Representation of LDAP
      Search Filters</title>RFC 1960, UMich, 1996<?line-break ?><biblioid
      class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc1960.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024199"><title>Java Security
      Architecture</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/spec/security-spec.doc.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024203"><title>Java Package Versioning
      Specification</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/8/docs/technotes/guides/versioning/index.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024206"><title>Codes for the Representation of
      Names of Languages</title>ISO 639, International Standards
      Organization<?line-break ?><biblioid class="uri"><link
      xlink:href="https://www.loc.gov/standards/iso639-2/langhome.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3100827"><title>Zip File Format</title>The Zip
      file format as defined by the java.util.zip package.</bibliomixed>

      <bibliomixed xml:id="i3024211"><title>Manifest Format</title><biblioid
      class="uri"><link
      xlink:href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#JAR_Manifest"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024215"><title>W3C EBNF</title><biblioid
      class="uri"><link
      xlink:href="https://www.w3c.org/TR/REC-xml#sec-notation"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3024221"><title>Interval
      (Mathematics)</title><biblioid class="uri"><link
      xlink:href="https://en.wikipedia.org/wiki/Interval_(mathematics)"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3086040"><title>RFC 2396 Uniform Resource
      Identifiers URI: Generic Syntax</title><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc2396.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3211606"><title>OSGi IANA Mime
      Type</title><biblioid class="uri"><link
      xlink:href="https://www.iana.org/assignments/media-types/application/vnd.osgi.bundle"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3215677"><title>OSGi Header
      Registry</title><biblioid class="uri"><link
      xlink:href="https://docs.osgi.org/reference/bundle-headers.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="framework.module.namespace-registry"><title>OSGi
      Namespace Registry</title><biblioid class="uri"><link
      xlink:href="https://docs.osgi.org/reference/capability-namespaces.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3219167"><title>Portable Network Graphics (PNG)
      Specification (Second Edition)</title><biblioid class="uri"><link
      xlink:href="https://www.w3.org/TR/2003/REC-PNG-20031110/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3222193"><title>Open Source
      Initiative</title><biblioid class="uri"><link
      xlink:href="https://www.opensource.org/"/></biblioid></bibliomixed>

      <bibliomixed><title>OSGi Semantic Versioning</title><biblioid
      class="uri"><link
      xlink:href="https://docs.osgi.org/whitepaper/semantic-versioning/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3242547"><title>Specification
      References</title><biblioid class="uri"><link
      xlink:href="https://docs.osgi.org/reference/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3246261"><title>Google Android</title><biblioid
      class="uri"><link
      xlink:href="https://developer.android.com/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3246276"><title>Google App Engine</title><biblioid
      class="uri"><link
      xlink:href="https://cloud.google.com/appengine/docs/standard/java"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i3246284"><title>Google Web
      Toolkit</title><biblioid class="uri"><link
      xlink:href="https://www.gwtproject.org/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="framework.module-spdx.license.list"><title>Software
      Package Data Exchange (SPDX) License List</title><biblioid
      class="uri"><link
      xlink:href="https://spdx.org/licenses/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="framework.module-maven.pom.developers"><title>Maven
      POM Reference, Developers</title><biblioid class="uri"><link
      xlink:href="https://maven.apache.org/pom.html#Developers"/></biblioid></bibliomixed>

      <bibliomixed xml:id="framework.module-maven.pom.scm"><title>Maven POM
      Reference, SCM</title><biblioid class="uri"><link
      xlink:href="https://maven.apache.org/pom.html#SCM"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="framework.module-ref.multireleasejar"><title>Multi-release JAR
      File</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/en/java/javase/17/docs/specs/jar/jar.html#multi-release-jar-files"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
