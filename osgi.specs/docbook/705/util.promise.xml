<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->
<chapter label="705"
         revision="$Id$"
         version="5.0" xml:id="util.promise"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Promises Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.util.promise-version"
    linkend="org.osgi.util.promise"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>One of the fundamental pieces of an asynchronous programming model
    is the mechanism by which clients retrieve the result of the asynchronous
    task. Since Java 5, there has been a
    <code>java.util.concurrent.Future</code> interface available in the Java
    class libraries, which means that it is the <emphasis>de facto</emphasis>
    API in Java for handling the result of an asynchronous task. Futures have
    some limitations however in that they have no mechanism for registering
    callbacks. Java 8 introduces the class
    <code>java.util.concurrent.CompletableFuture</code> which addresses this
    but it is a complex API.</para>

    <para>This specification defines a Promises API which is independent of
    all other OSGi specifications including the OSGi Framework and thus can be
    easily used outside of the OSGi environment.</para>

    <para>A Promise object holds the result of a potentially asynchronous
    task. The receiver of a Promise object can register callbacks on the
    Promise to be notified when the result is available or can block on the
    result becoming available. Promises can be chained together in powerful
    ways to handle asynchronous work flows and recovery.</para>

    <para>Promises capture the effects of latency and errors by making these
    explicit in the API signatures. Latency is represented by callbacks which
    will eventually be called. Errors are represented by the failure member.
    In essence, this is what sets Promises apart from things such as RPC calls
    where such effects are not explicitly captured but rather attempted to be
    transparently handled.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Common concepts</emphasis> - The API is inspired by
          the Promises work in JavaScript and uses the same basic concepts.
          See <xref linkend="util.promise-ref.javascript"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Independent</emphasis> - The design is independent
          of all other OSGi specifications and can be used outside of an OSGi
          environment.</para>
        </listitem>

        <listitem>
          <para><emphasis>Asynchronous</emphasis> - The design supports
          asynchronous tasks.</para>
        </listitem>

        <listitem>
          <para><emphasis>Small</emphasis> - The API and implementation are
          very compact.</para>
        </listitem>

        <listitem>
          <para><emphasis>Complete</emphasis> - The design provides a very
          complete set of operations for Promise which are primitives that can
          be used to address most use cases.</para>
        </listitem>

        <listitem>
          <para><emphasis>Monad</emphasis> - The design supports monadic
          programming. See <xref linkend="util.promise-ref.monad"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resolution</emphasis> - A Promise can be resolved
          successfully with a value or unsuccessfully with an
          exception.</para>
        </listitem>

        <listitem>
          <para><emphasis>Generified</emphasis> - Generics are used to promote
          type safety.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Promise</emphasis> - A Promise object holds the
          eventual result of a potentially asynchronous task.</para>
        </listitem>

        <listitem>
          <para><emphasis>Callback</emphasis> - The receiver of a Promise can
          register callbacks on the Promise to be notified when the task is
          completed.</para>
        </listitem>

        <listitem>
          <para><emphasis>Deferred</emphasis> - A Deferred object represents
          the potentially asynchronous task and is used to resolve the
          Promise.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Class diagram of org.osgi.util.promise</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.227in"
                       contentwidth="7.000in" fileref="promise-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Promise</title>

    <para>A <xref linkend="org.osgi.util.promise.Promise"
    xrefstyle="hyperlink"/> object holds the eventual result of a potentially
    asynchronous task. A Promise is either unresolved or resolved. An
    <emphasis>unresolved</emphasis> Promise does not have the result of the
    associated task available while a <emphasis>resolved</emphasis> Promise
    has the result of the associated task available. The <xref
    linkend="org.osgi.util.promise.Promise.isDone--" xrefstyle="hyperlink"/>
    method must return <code>true</code> if the Promise is resolved and
    <code>false</code> if the Promise is unresolved. A Promise must only be
    resolved once.</para>

    <para>A resolved Promise can be either resolved with a value, which means
    the associated task <emphasis>completed successfully</emphasis> and
    supplied a result, or resolved with a failure, which means the associated
    task <emphasis>completed unsuccessfully</emphasis> and supplied an
    exception. The <xref linkend="org.osgi.util.promise.Promise.getFailure--"
    xrefstyle="hyperlink"/> method can be called to determine if the resolved
    Promise completed successfully with a value or unsuccessfully with a
    failure. If the <xref linkend="org.osgi.util.promise.Promise.getFailure--"
    xrefstyle="hyperlink"/> method returns a <code>Throwable</code>, the
    Promise resolved unsuccessfully with a failure. If the <xref
    linkend="org.osgi.util.promise.Promise.getFailure--"
    xrefstyle="hyperlink"/> method returns <code>null</code>, the Promise
    resolved successfully with a value that can be obtained from <xref
    linkend="org.osgi.util.promise.Promise.getValue--"
    xrefstyle="hyperlink"/>.</para>

    <para>If the Promise is unresolved, then calling <xref
    linkend="org.osgi.util.promise.Promise.getFailure--"
    xrefstyle="hyperlink"/> or <xref
    linkend="org.osgi.util.promise.Promise.getValue--" xrefstyle="hyperlink"/>
    must block until the Promise is resolved. In general, these two methods
    should not be used outside of a callback. Use callbacks to be notified
    when the Promise is resolved. See <xref
    linkend="util.promise-callbacks"/>.</para>
  </section>

  <section>
    <title>Deferred</title>

    <para><xref linkend="org.osgi.util.promise.Promise"
    xrefstyle="hyperlink"/> is an interface which can allow for many Promise
    implementations. This API contains the <xref
    linkend="org.osgi.util.promise.Deferred" xrefstyle="hyperlink"/> class
    which provides access to the standard Promise implementation. A Deferred
    object can be created by calling the <xref
    linkend="org.osgi.util.promise.PromiseFactory.deferred--"
    xrefstyle="hyperlink"/> method on a <xref
    linkend="org.osgi.util.promise.PromiseFactory" xrefstyle="hyperlink"/>
    object.</para>

    <para>A <xref linkend="org.osgi.util.promise.PromiseFactory"
    xrefstyle="hyperlink"/> object is created with a specified callback
    executor and a specified scheduled executor to use for created Promise
    objects and the Promise objects associated with created Deferred objects.
    If the callback executor or the scheduled executor is not specified or is
    specified as <code>null</code>, then implementation default executors will
    be used. The <xref linkend="org.osgi.util.promise.Deferred.Deferred--"
    xrefstyle="hyperlink"/> constructor will create a Deferred whose
    associated Promise uses the default Promise Factory which uses the
    implementation default executors. All Promise objects created by a Promise
    must use the same Promise Factory as the creating Promise. Callbacks must
    be called using the callback executor of the Promise Factory associated
    with the Promise if the Promise Factory was created with the <xref
    linkend="org.osgi.util.promise.PromiseFactory.Option.CALLBACKS_EXECUTOR_THREAD"
    xrefstyle="hyperlink"/> option. Otherwise, when the Promise is already
    resolved, the current thread may be used to call the callback to avoid a
    thread context switch. If the callback executor rejects the execution, the
    current thread will be used to call the callback to avoid loss of the
    callback operation. The scheduled executor must be used by the <xref
    linkend="org.osgi.util.promise.Promise.timeout-long-"
    xrefstyle="hyperlink"/> and <xref
    linkend="org.osgi.util.promise.Promise.delay-long-"
    xrefstyle="hyperlink"/> operations. The <xref
    linkend="org.osgi.util.promise.PromiseFactory.inlineExecutor--"
    xrefstyle="hyperlink"/> method can be used to obtain an executor which
    runs callbacks immediately on the thread calling the
    <code>Executor.execute</code> method. This behavior is similar to how
    callbacks were executed in the default Promise implementation of Promise
    1.0 specification.</para>

    <para>The Promise associated with a Deferred object can be obtained using
    <xref linkend="org.osgi.util.promise.Deferred.getPromise--"
    xrefstyle="hyperlink"/>. This Promise can then be supplied to other
    parties who can use it to be notified of and obtain the eventual
    result.</para>

    <programlisting>public Promise&lt;String&gt; getTimeConsumingAnswer() {
  Deferred&lt;String&gt; deferred = factory.deferred();
  asynchronously(() -&gt; doTask(deferred));
  return deferred.getPromise();
}</programlisting>

    <para>A Deferred object can later be used to resolve the associated
    Promise successfully by calling <xref
    linkend="org.osgi.util.promise.Deferred.resolve-T-"
    xrefstyle="hyperlink"/> or unsuccessfully by calling <xref
    linkend="org.osgi.util.promise.Deferred.fail-Throwable-"
    xrefstyle="hyperlink"/>.</para>

    <programlisting>private void doTask(Deferred&lt;String&gt; deferred) {
  try {
    String answer = computeTimeConsumingAnswer();
    deferred.resolve(answer); // successfully resolve with value
  } catch (Exception e) {
    deferred.fail(e); // unsuccessfully resolve with exception
  }
}</programlisting>

    <para>A Deferred object can also be used to resolve the associated Promise
    with the eventual result of another Promise by calling <xref
    linkend="org.osgi.util.promise.Deferred.resolveWith-Promise-"
    xrefstyle="hyperlink"/> or the result of a CompletionStage by calling
    <xref
    linkend="org.osgi.util.promise.Deferred.resolveWith-CompletionStage-"
    xrefstyle="hyperlink"/>.</para>

    <programlisting>private void doTask(Deferred&lt;String&gt; deferred) {
  try {
    Promise&lt;String&gt; promise = getPromiseWithTheAnswer();
    deferred.resolveWith(promise); // resolve with another Promise
  } catch (Exception e) {
    deferred.fail(e); // unsuccessfully resolve with exception
  }
}</programlisting>

    <para>If <xref linkend="org.osgi.util.promise.Deferred.resolve-T-"
    xrefstyle="hyperlink"/> or <xref
    linkend="org.osgi.util.promise.Deferred.fail-Throwable-"
    xrefstyle="hyperlink"/> is called when the Promise associated with the
    Deferred is already resolved, then an Illegal State Exception must be
    thrown.</para>

    <para>Care must be taken in sharing a Deferred object with other parties
    since the other parties can resolve the associated Promise. A Deferred
    object should be made available only to the party that will responsible
    for resolving the associated Promise.</para>
  </section>

  <section xml:id="util.promise-callbacks">
    <title>Callbacks</title>

    <para>To be notified when a Promise has been resolved, callbacks are used.
    The Promise API provides two forms of callbacks: the basic
    <code>Runnable</code> and <xref linkend="org.osgi.util.function.Consumer"
    xrefstyle="hyperlink"/> callbacks and the more specialized <xref
    linkend="org.osgi.util.promise.Success" xrefstyle="hyperlink"/> and <xref
    linkend="org.osgi.util.promise.Failure" xrefstyle="hyperlink"/>
    callbacks.</para>

    <para>A callback may be called on a different thread than the thread which
    registered the callback. So the callback must be thread safe but can rely
    upon that the registration of the callback
    <emphasis>happens-before</emphasis> the callback is called.</para>

    <para>Resolving a Promise <emphasis>happens-before</emphasis> any
    registered callback is called. That is, for the resolved Promise, in a
    registered callback <xref linkend="org.osgi.util.promise.Promise.isDone--"
    xrefstyle="hyperlink"/> must return <code>true</code> and <xref
    linkend="org.osgi.util.promise.Promise.getValue--" xrefstyle="hyperlink"/>
    and <xref linkend="org.osgi.util.promise.Promise.getFailure--"
    xrefstyle="hyperlink"/> must not block.</para>

    <para>Callbacks may be registered at any time including before and after a
    Promise has been resolved. If a callback is registered before the Promise
    is resolved, it will be called later when the Promise is resolved. If a
    callback is registered on an already resolved Promise, it will be called
    right away.</para>

    <section>
      <title>Runnable</title>

      <para>The <xref
      linkend="org.osgi.util.promise.Promise.onResolve-Runnable-"
      xrefstyle="hyperlink"/> method is used to register a
      <code>Runnable</code> with the Promise which must be called when the
      Promise is resolved either successfully with a value or unsuccessfully
      with a failure. The resolved Promise is not passed to the Runnable, so
      if the Runnable implementation needs access to the resolved Promise, it
      must take care to ensure it has access.</para>

      <programlisting>final Promise&lt;String&gt; answer = getTimeConsumingAnswer();
answer.onResolve(() -&gt; doSomethingWithAnswer(answer));</programlisting>

      <para>The <xref
      linkend="org.osgi.util.promise.Promise.onResolve-Runnable-"
      xrefstyle="hyperlink"/> method returns the Promise object upon which it
      is called.</para>
    </section>

    <section xml:id="util.promise-callbacks.consumer">
      <title>Consumer</title>

      <para>The <xref
      linkend="org.osgi.util.promise.Promise.thenAccept-Consumer-"
      xrefstyle="hyperlink"/> method is used to register a <xref
      linkend="org.osgi.util.function.Consumer" xrefstyle="hyperlink"/> with
      the Promise which must be called when the Promise is resolved
      successfully with a value. The value of the resolved Promise is passed
      to the <xref linkend="org.osgi.util.function.Consumer"
      xrefstyle="hyperlink"/>.</para>

      <programlisting>final Promise&lt;String&gt; answer = getTimeConsumingAnswer().thenAccept(s -&gt;
    doSomethingWithAnswer(s)
);</programlisting>

      <para>The <xref
      linkend="org.osgi.util.promise.Promise.thenAccept-Consumer-"
      xrefstyle="hyperlink"/> method returns a new Promise which will be
      resolved with either the exception thrown from the <xref
      linkend="org.osgi.util.function.Consumer" xrefstyle="hyperlink"/>, if
      one is thrown, or with the Promise.</para>

      <para>The <xref
      linkend="org.osgi.util.promise.Promise.onSuccess-Consumer-"
      xrefstyle="hyperlink"/> method is used to register a <xref
      linkend="org.osgi.util.function.Consumer" xrefstyle="hyperlink"/> with
      the Promise which must be called when the Promise is resolved
      successfully with a value. The value of the resolved Promise is passed
      to the <xref linkend="org.osgi.util.function.Consumer"
      xrefstyle="hyperlink"/>. The <xref
      linkend="org.osgi.util.promise.Promise.onSuccess-Consumer-"
      xrefstyle="hyperlink"/> method returns the Promise object upon which it
      is called.</para>

      <para>The <xref
      linkend="org.osgi.util.promise.Promise.onFailure-Consumer-"
      xrefstyle="hyperlink"/> method is used to register a <xref
      linkend="org.osgi.util.function.Consumer" xrefstyle="hyperlink"/> with
      the Promise which must be called when the Promise is resolved
      unsuccessfully with a failure. The failure of the resolved Promise is
      passed to the <xref linkend="org.osgi.util.function.Consumer"
      xrefstyle="hyperlink"/>. The <xref
      linkend="org.osgi.util.promise.Promise.onFailure-Consumer-"
      xrefstyle="hyperlink"/> method returns the Promise object upon which it
      is called.</para>

      <para>The <xref
      linkend="org.osgi.util.promise.Promise.onFailure-Consumer-Class-"
      xrefstyle="hyperlink"/> method is used to register a <xref
      linkend="org.osgi.util.function.Consumer" xrefstyle="hyperlink"/> with
      the Promise which must be called when the Promise is resolved
      unsuccessfully with a failure of a specified type. The failure of the
      resolved Promise is passed to the <xref
      linkend="org.osgi.util.function.Consumer" xrefstyle="hyperlink"/>. If
      the Promise is unsuccessfully resolved with a failure which is not of
      the specified type, the <xref linkend="org.osgi.util.function.Consumer"
      xrefstyle="hyperlink"/> argument is not called. The <xref
      linkend="org.osgi.util.promise.Promise.onFailure-Consumer-Class-"
      xrefstyle="hyperlink"/> method returns the Promise object upon which it
      is called.</para>
    </section>

    <section>
      <title>Success and Failure</title>

      <para>The <xref linkend="org.osgi.util.promise.Promise.then-Success-"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.util.promise.Promise.then-Success-Failure-"
      xrefstyle="hyperlink"/> methods can be used to register the more
      specialized <xref linkend="org.osgi.util.promise.Success"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.util.promise.Failure" xrefstyle="hyperlink"/>
      callbacks. The <xref linkend="org.osgi.util.promise.Success"
      xrefstyle="hyperlink"/> callback is only called if the Promise is
      successfully resolved with a value. The <xref
      linkend="org.osgi.util.promise.Failure" xrefstyle="hyperlink"/> callback
      is only called if the Promise is unsuccessfully resolved with a
      failure.</para>

      <programlisting>Promise&lt;String&gt; answer = getTimeConsumingAnswer();
answer.then(p -&gt; processResult(p.getValue()), p -&gt; handleFailure(p.getFailure()));</programlisting>

      <para>The <code>then</code> methods return a new Promise which can be
      used to chain Promises together.</para>
    </section>
  </section>

  <section xml:id="util.promise-chaining.promises">
    <title>Chaining Promises</title>

    <para>The <xref linkend="org.osgi.util.promise.Promise.then-Success-"
    xrefstyle="hyperlink"/>, <xref
    linkend="org.osgi.util.promise.Promise.then-Success-Failure-"
    xrefstyle="hyperlink"/>, and <xref
    linkend="org.osgi.util.promise.Promise.thenAccept-Consumer-"
    xrefstyle="hyperlink"/> methods also provide a means to chain Promises
    together. These methods return a new Promise which is chained to the
    original Promise upon which the method was called. The returned Promise
    must be resolved when the original Promise is resolved after the specified
    Success, Failure, or Consumer callback is executed. The result of the
    executed callback must be used to resolve the returned Promise. A sequence
    of calls to the <code>then</code> methods can be used to create a chain of
    promises which are resolved in sequence.</para>

    <para>For the <xref linkend="org.osgi.util.promise.Promise.then-Success-"
    xrefstyle="hyperlink"/> or <xref
    linkend="org.osgi.util.promise.Promise.then-Success-Failure-"
    xrefstyle="hyperlink"/> methods, if the original Promise is successfully
    resolved, the Success callback is executed and the Promise returned by the
    Success callback, if any, or thrown exception is used to resolve the
    Promise returned from the method. If the original Promise is resolved with
    a failure, the Failure callback is executed and the Promise returned from
    the method is resolved with a failure.</para>

    <para>For the <xref
    linkend="org.osgi.util.promise.Promise.thenAccept-Consumer-"
    xrefstyle="hyperlink"/> method, if the original Promise is successfully
    resolved, the Consumer callback is executed and the value of the original
    Promise or thrown exception is used to resolve the Promise returned from
    the method. If the original Promise is resolved with a failure, the
    Consumer callback is not executed and the Promise returned from the method
    is resolved with the failure of the original Promise.</para>

    <para>In the following example, a Promise which will supply the name of
    the file to download is chained to a Promise which will return a mirror
    URL to use to download the file which is then further chained to a Promise
    which will return an Input Stream from which to read the download
    file.</para>

    <programlisting>Promise&lt;String&gt; name = getDownloadName();
Promise&lt;URL&gt; mirror = name.then(p -&gt; getMirror(p.getValue()));
Promise&lt;InputStream&gt; in = mirror.then(p -&gt; getStream(p.getValue()));</programlisting>

    <para>Since we probably do not need the intermediate Promises, we can
    collapse the chain into a single statement.</para>

    <programlisting>Promise&lt;InputStream&gt; in = getDownloadName().then(p -&gt; getMirror(p.getValue()))
                                           .then(p -&gt; getStream(p.getValue()));</programlisting>

    <para>The chain of Promises will also propagate any exceptions that occur
    to resolve the last Promise in the chain which means we do not need to do
    any exception handling in the intermediate tasks. Promises can also be
    chained by using the monadic programming methods in <xref
    linkend="util.promise-monad.programming"/>.</para>
  </section>

  <section xml:id="util.promise-monad.programming">
    <title>Monad</title>

    <para>The Promise API supports monadic programming. See <xref
    linkend="util.promise-ref.monad"/>. The <xref
    linkend="org.osgi.util.promise.Promise" xrefstyle="hyperlink"/> interface
    defines a number of interesting methods including <code>map</code>,
    <code>flatMap</code> and <code>filter</code>.</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.util.promise.Promise.filter-Predicate-"
        xrefstyle="hyperlink"/> - Filter the value of the Promise.</para>

        <para>If the Promise is successfully resolved, the predicate argument
        is called with the value of the Promise. If the predicate accepts the
        value, then the value is used to successfully resolve the Promise
        returned by the filter method. If the predicate does not accept the
        value, the Promise returned by the filter method is unsuccessfully
        resolved with a No Such Element Exception. If the predicate throws an
        exception, the Promise returned by the filter method is unsuccessfully
        resolved with that exception.</para>

        <para>If the Promise is unsuccessfully resolved, the predicate
        argument is not called and the Promise returned by the filter method
        is unsuccessfully resolved with the failure of the Promise.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.util.promise.Promise.map-Function-"
        xrefstyle="hyperlink"/> - Map the value of the Promise.</para>

        <para>If the Promise is successfully resolved, the function argument
        is called with the value of the Promise. The value returned by the
        function is used to successfully resolve the Promise returned by the
        map method. If the function throws an exception, the Promise returned
        by the map method is unsuccessfully resolved with that
        exception.</para>

        <para>If the Promise is unsuccessfully resolved, the function argument
        is not called and the Promise returned by the map method is
        unsuccessfully resolved with the failure of the Promise.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.util.promise.Promise.flatMap-Function-"
        xrefstyle="hyperlink"/> - FlatMap the value of the Promise.</para>

        <para>If the Promise is successfully resolved, the function argument
        is called with the value of the Promise. The Promise returned by the
        function is used to resolve the Promise returned by the flatMap
        method. If the function throws an exception, the Promise returned by
        the flatMap method is unsuccessfully resolved with that
        exception.</para>

        <para>If the Promise is unsuccessfully resolved, the function argument
        is not called and the Promise returned by the flatMap method is
        unsuccessfully resolved with the failure of the Promise.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.util.promise.Promise.recover-Function-"
        xrefstyle="hyperlink"/> - Recover from the unsuccessful resolution of
        the Promise with a recovery value.</para>

        <para>If the Promise is successfully resolved, the function argument
        is not called and the Promise returned by the recover method is
        resolved with the value of the Promise.</para>

        <para>If the Promise is unsuccessfully resolved, the function argument
        is called with the Promise to supply a recovery value. If the recovery
        value is not <code>null</code>, the Promise returned by the recover
        method is successfully resolved with the recovery value. If the
        recovery value is <code>null</code>, the Promise returned by the
        recover method is unsuccessfully resolved with the failure of the
        Promise. If the function throws an exception, the Promise returned by
        the recover method is unsuccessfully resolved with that
        exception.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.util.promise.Promise.recover-Function-Class-"
        xrefstyle="hyperlink"/> - Recover from the unsuccessful resolution of
        the Promise with a recovery value when the failure is of a specified
        type.</para>

        <para>The <xref
        linkend="org.osgi.util.promise.Promise.recover-Function-Class-"
        xrefstyle="hyperlink"/> method provides the same behavior as <xref
        linkend="org.osgi.util.promise.Promise.recover-Function-"
        xrefstyle="hyperlink"/> but only when the failure is of the specified
        type. If the Promise is unsuccessfully resolved with a failure which
        is not of the specified type, the function argument is not called and
        the Promise returned by the recover method is resolved with the
        failure of the Promise.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.util.promise.Promise.recoverWith-Function-"
        xrefstyle="hyperlink"/> - Recover from the unsuccessful resolution of
        the Promise with a recovery Promise.</para>

        <para>If the Promise is successfully resolved, the function argument
        is not called and the Promise returned by the recover method is
        resolved with the value of the Promise.</para>

        <para>If the Promise is unsuccessfully resolved, the function argument
        is called with the Promise to supply a recovery Promise. If the
        recovery Promise is not <code>null</code>, the Promise returned by the
        recover method is resolved with the recovery Promise. If the recovery
        Promise is <code>null</code>, the Promise returned by the recover
        method is unsuccessfully resolved with the failure of the Promise. If
        the function throws an exception, the Promise returned by the recover
        method is unsuccessfully resolved with that exception.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.util.promise.Promise.recoverWith-Function-Class-"
        xrefstyle="hyperlink"/> - Recover from the unsuccessful resolution of
        the Promise with a recovery Promise when the failure is of a specified
        type.</para>

        <para>The <xref
        linkend="org.osgi.util.promise.Promise.recoverWith-Function-Class-"
        xrefstyle="hyperlink"/> method provides the same behavior as <xref
        linkend="org.osgi.util.promise.Promise.recoverWith-Function-"
        xrefstyle="hyperlink"/> but only when the failure is of the specified
        type. If the Promise is unsuccessfully resolved with a failure which
        is not of the specified type, the function argument is not called and
        the Promise returned by the recover method is resolved with the
        failure of the Promise.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.util.promise.Promise.fallbackTo-Promise-"
        xrefstyle="hyperlink"/> - Fall back to the value of the Promise
        argument if the Promise unsuccessfully resolves.</para>

        <para>If the Promise is successfully resolved, the Promise argument is
        not used and the Promise returned by the fallbackTo method is resolved
        with the value of the Promise.</para>

        <para>If the Promise is unsuccessfully resolved, the Promise argument
        is used to provide a fallback value when it becomes resolved. If the
        Promise argument is successfully resolved, the Promise returned by the
        fallbackTo method is resolved with the value of the Promise argument.
        If the Promise argument is unsuccessfully resolved, the Promise
        returned by the fallbackTo method is unsuccessfully resolved with the
        failure of the Promise.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.util.promise.Promise.fallbackTo-Promise-Class-"
        xrefstyle="hyperlink"/> - Fall back to the value of the Promise
        argument if the Promise unsuccessfully resolves with a failure of a
        specified type.</para>

        <para>The <xref
        linkend="org.osgi.util.promise.Promise.fallbackTo-Promise-Class-"
        xrefstyle="hyperlink"/> method provides the same behavior as <xref
        linkend="org.osgi.util.promise.Promise.fallbackTo-Promise-"
        xrefstyle="hyperlink"/> but only when the failure is of the specified
        type. If the Promise is unsuccessfully resolved with a failure which
        is not of the specified type, the Promise argument is not used and the
        Promise returned by the fallbackTo method is resolved with the failure
        of the Promise.</para>
      </listitem>
    </itemizedlist>

    <para>These functions can be used to build pipelines of chained Promises
    that are processed in sequence. For example, in the following chain, the
    value of the original promise, once resolved, is filtered for acceptable
    values. If the filter says the value is not acceptable, the recover method
    will be used to replace it with a default value.</para>

    <programlisting>return promise.filter(v -&gt; isValueOk(v)).recover(p -&gt; getDefaultValue())</programlisting>

    <para>With these chains, one can write powerful programs without the need
    to resort to complex if/else and try/catch logic.</para>
  </section>

  <section xml:id="util.promise-timing.methods">
    <title>Timing</title>

    <para>The Promise API provides methods to affect the timing of resolving
    Promises.</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.util.promise.Promise.timeout-long-"
        xrefstyle="hyperlink"/> - Time out the resolution of the
        Promise.</para>

        <para>If the Promise is successfully resolved before the timeout, the
        returned Promise is resolved with the value of the Promise. If the
        Promise is resolved with a failure before the timeout, the returned
        Promise is resolved with the failure of the Promise. If the timeout is
        reached before the Promise is resolved, the returned Promise is failed
        with a <xref linkend="org.osgi.util.promise.TimeoutException"
        xrefstyle="hyperlink"/>.</para>
      </listitem>

      <listitem>
        <para><xref linkend="org.osgi.util.promise.Promise.delay-long-"
        xrefstyle="hyperlink"/> - Delay after the resolution of the
        Promise.</para>

        <para>Once the Promise is resolved, resolve the returned Promise with
        the Promise after the specified delay.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Functional Interfaces</title>

    <para>In Java 8, the concept of Functional Interfaces is introduced. See
    <xref linkend="util.promise-ref.functional.interfaces"/>. Functional
    interfaces are types with a single abstract method. Instances of
    functional interfaces can be created with lambda expressions, method
    references, or constructor references. Many methods on <xref
    linkend="org.osgi.util.promise.Promise" xrefstyle="hyperlink"/> take
    functional interface arguments and so are suitable for use with lambda
    expressions and method references in Java 8.</para>

    <para>Four of these functional interfaces are <xref
    linkend="org.osgi.util.function.Function" xrefstyle="hyperlink"/>, <xref
    linkend="org.osgi.util.function.Predicate" xrefstyle="hyperlink"/>, <xref
    linkend="org.osgi.util.function.Supplier" xrefstyle="hyperlink"/>, and
    <xref linkend="org.osgi.util.function.Consumer" xrefstyle="hyperlink"/>.
    These are equivalent to functional interfaces which are part of the
    <code>java.util.function</code> package introduced in Java 8 with
    additional static methods to support interoperation. OSGi defines these
    interfaces to allow throwing checked exceptions which can be propagated in
    a chain of Promises.</para>
  </section>

  <section>
    <title>Utility Methods</title>

    <para>The API also provides several useful utility methods when working
    with Promises.</para>

    <para>Often, you may need to create an already resolved Promise to return
    or chain with another Promise. The <xref
    linkend="org.osgi.util.promise.PromiseFactory.resolved-T-"
    xrefstyle="hyperlink"/> method can be used to create a new Promise already
    successfully resolved with the specified value. The <xref
    linkend="org.osgi.util.promise.PromiseFactory.failed-Throwable-"
    xrefstyle="hyperlink"/> method can be used to create a new Promise already
    unsuccessfully resolved with the specified exception. These methods also
    exists as static methods on the <xref
    linkend="org.osgi.util.promise.Promises" xrefstyle="hyperlink"/> class
    returning Promises which use the implementation default executors.</para>

    <programlisting>  return getTimeConsumingAnswer().fallbackTo(factory.resolved("Fallback Value"));</programlisting>

    <para>The <xref
    linkend="org.osgi.util.promise.PromiseFactory.resolvedWith-Promise-"
    xrefstyle="hyperlink"/> method can be used to return a new Promise that
    will be resolved with the specified Promise.</para>

    <para>The <xref
    linkend="org.osgi.util.promise.PromiseFactory.submit-Callable-"
    xrefstyle="hyperlink"/> method can be used to return a new Promise that
    will hold the result of the specified task. The task will be executed on
    the callback executor.</para>

    <para>The <xref
    linkend="org.osgi.util.promise.PromiseFactory.all-Collection-"
    xrefstyle="hyperlink"/> method returns a Promise that is a latch on the
    specified Promises. The returned Promise must resolve only when all of the
    specified Promises have resolved. The <xref
    linkend="org.osgi.util.promise.PromiseFactory.toPromise--"
    xrefstyle="hyperlink"/> method returns a <code>Collector</code> which can
    be used on a <code>Stream</code> of Promises to collect the results of the
    Promises into a latch using the <xref
    linkend="org.osgi.util.promise.PromiseFactory.all-Collection-"
    xrefstyle="hyperlink"/> method as the finisher. The <code>all</code>
    method also exists as a static method on the <xref
    linkend="org.osgi.util.promise.Promises" xrefstyle="hyperlink"/> class
    returning a Promise which uses the implementation default
    executors.</para>

    <para>Interoperation with CompletionStage is supported. The <xref
    linkend="org.osgi.util.promise.PromiseFactory.resolvedWith-CompletionStage-"
    xrefstyle="hyperlink"/> method returns a Promise that is resolved by the
    specified CompletionStage. The <xref
    linkend="org.osgi.util.promise.Promise.toCompletionStage--"
    xrefstyle="hyperlink"/> method returns a CompletionStage that is resolved
    by the receiving Promise.</para>
  </section>

  <section>
    <title>Security</title>

    <para>The Promise API does not define any OSGi services nor does the API
    perform any privileged actions. Therefore, it has no security
    considerations.</para>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.util.promise.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.util.function.xml"/>

  <section xml:id="util.promise.references">
    <title>References</title>

    <bibliolist>
      <bibliomixed><title>JavaScript Promises</title><biblioid
      class="uri"><link
      xlink:href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"/></biblioid></bibliomixed>

      <bibliomixed xml:id="util.promise-ref.javascript"><title>JavaScript
      Promises</title><biblioid class="uri"><link
      xlink:href="https://web.dev/promises/"/></biblioid></bibliomixed>

      <bibliomixed><title>ECMAScript® 2022 Language
      Specification</title><biblioid class="uri"><link
      xlink:href="https://tc39.es/ecma262/#sec-promise-objects"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="util.promise-ref.monad"><title>Monad</title><biblioid
      class="uri"><link
      xlink:href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="util.promise-ref.functional.interfaces"><title>Function
      Interfaces</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.8"/></biblioid></bibliomixed>
    </bibliolist>
  </section>

  <section>
    <title>Changes</title>

    <itemizedlist>
      <listitem>
        <para>Added new overloaded methods <xref
        linkend="org.osgi.util.promise.Promise.onFailure-Consumer-Class-"
        xrefstyle="hyperlink"/>, <xref
        linkend="org.osgi.util.promise.Promise.recover-Function-Class-"
        xrefstyle="hyperlink"/>, <xref
        linkend="org.osgi.util.promise.Promise.recoverWith-Function-Class-"
        xrefstyle="hyperlink"/>, and <xref
        linkend="org.osgi.util.promise.Promise.fallbackTo-Promise-Class-"
        xrefstyle="hyperlink"/>. These overloaded methods allow the caller to
        specify the type of the failure for which they are in effect.</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
