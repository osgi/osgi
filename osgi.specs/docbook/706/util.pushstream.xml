<?xml version="1.0" encoding="utf-8"?>
<chapter label="706"
         revision="$Id$"
         version="5" xml:id="util.pushstream"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Push Stream Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.util.pushstream-version"
    linkend="org.osgi.util.pushstream"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>In large-scale distributed systems <emphasis>events</emphasis> are
    a commonly used communication mechanism for passing data and triggering
    behaviours. Events are typically generated 
    <emphasis>asynchronously</emphasis> rather than at the request of the
    processing system, and once received an event usually undergoes some
    level of transformation before being stored, acted upon, or forwarded to
    another consumer.</para>
    
    <para>Pipelines and streams are a popular and effective model for consuming
    and processing events, with numerous APIs providing this sort of model.
    One of the most well-known processing pipeline APIs is the Java 8 Streams
    API, which provides a functional pipleline for operating on Collections. 
    The Streams API is inherently <emphasis>pull based</emphasis>” as it relies 
    on iterators and spliterators to <emphasis>pull</emphasis> the next entry 
    from the stream. This is the primary difference between synchronous and 
    asynchronous models. In an asynchronous world events are pushed into the 
    pipeline as they are received.</para>

    <para>This specification defines a PushStream API which can be used on
    devices which support the Java 8 compact1 profile. The PushStream API
    defined by this specification depends on OSGi Promises but is 
    independent of all other OSGi specifications, including the OSGi 
    Framework, and thus can be easily used outside of the OSGi environment.</para>

    <para>A PushStream object encapsulates a pipeline of a potentially 
    asynchronous tasks which will be performed when an event arrives. The 
    result of the processing pipeline is represented using a Promise object
    which will resolve when the result has been calculated.</para>

    <para>PushStream capture the effects of errors, finite streams and back 
    pressure by making these explicit in the API signatures. Errors and End 
    of Stream conditions are represented by specific events which are pushed 
    into the stream. Back pressure is represented by a delay value returned
    from the event pipeline stages.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Common concepts</emphasis> - The API is inspired by
          the Streams API in Java 8 and uses the same basic concepts.
          See ## TODO.</para>
        </listitem>

        <listitem>
          <para><emphasis>Independent</emphasis> - The design is independent
          of all other OSGi specifications (except for OSGi Promises) and 
          can be used outside of an OSGi environment.</para>
        </listitem>

        <listitem>
          <para><emphasis>Asynchronous</emphasis> - The design is built
          to handle asynchronously produced events.</para>
        </listitem>

        <listitem>
          <para><emphasis>Back Pressure</emphasis> - The design provides
          a means for event pipelines to communicate back-pressure to
          the Event Source.</para>
        </listitem>

        <listitem>
          <para><emphasis>Complete</emphasis> - The design provides a very
          complete set of operations for PushStreams which are primitives 
          that can be used to address most use cases.</para>
        </listitem>

        <listitem>
          <para><emphasis>Generified</emphasis> - Generics are used to promote
          type safety.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Push Event Source</emphasis> - A PushEventSource
          object represents a source of asynchronous events, and can
          be used to create a PushStream.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>Push Event Consumer</emphasis> - A Push Event Consumer
          object represents a sink for asynchronous events, and can be
          attached to a PushEventSource or a PushStream.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>Push Stream</emphasis> - A PushStream object 
          represents a pipeline for processing asynchronous events.</para>
        </listitem>

        <listitem>
          <para><emphasis>Terminal Operation</emphasis> - The final operation
          of a PushStream pipeline results in a Promise which represents the
          completion state of the pipeline. The operation also begins the
          processing of events.</para>
        </listitem>
      </itemizedlist>

    </section>
  </section>

  <section>
    <title>Asynchronous Eventing Streams</title>
    
    <para>The Push Stream API is built upon the principals of Asynchronous
    Event streams, and therefore requires three basic primitives:</para>
    
    <itemizedlist>
      <listitem><para>An event object</para></listitem>
      <listitem><para>A source of event objects</para></listitem>
      <listitem><para>A consumer of event objects</para></listitem>
    </itemizedlist>
  
    <section>
      <title>The Push Event</title>
      
      <para>The Push Event is an object representing an event. Every
      Push Event has an event type, which has one of three values:</para>
      
      <itemizedlist>
        <listitem>
          <para><code>DATA</code> - A data event encapsulates a
          typed object</para></listitem>
        <listitem>
          <para><code>ERROR</code> - An error event encapsulates
          an exception and indicates a failure in the event stream.</para>
        </listitem>
        <listitem>
          <para><code>CLOSE</code> - A close event represents
          the end of the stream of events.</para>
        </listitem>
      </itemizedlist>
      
      <para>An event stream consists of zero or more data events
      followed by a <emphasis>terminal event</emphasis>. A terminal
      event is either an error or a failure, and it indicates that
      there will be no more events in this stream. Depending on the
      reason for the terminal event it may be possible to re-attach
      to the event source and consume more events.</para>
    </section>
    
    <section>
      <title>The Push Event Source</title>
  
      <para>A Push Event Source object represents a source of asynchronous
      Push Events. The event source defines a single method <xref
      linkend="org.osgi.util.pushstream.PushEventSource.open--" 
      xrefstyle="hyperlink"/> which can be used to connect to the source
      and begin receiving a stream of events.</para>
      
      <para>The <code>open</code> method of the Push Event Source returns 
      an <code>AutoCloseable</code> which can be used to close the event 
      stream. If the <code>close</code> method is called on this object then 
      the stream is terminated by sending a close event. If additional calls 
      are made to the close method then they return without further action. 
      </para>
      
    </section>

    <section>
      <title>The Push Event Consumer</title>
  
      <para>A Push Event Consumer object represents a sink for 
      asynchronous Push Events. The event consumer defines a single method 
      <xref linkend="org.osgi.util.pushstream.PushEventConsumer.accept--" 
      xrefstyle="hyperlink"/> which can be used to receive a stream of 
      events.</para>
      
      <para>The <code>accept</code> method of the Push Event Consumer 
      returns a <code>long</code> representing 
      <emphasis>back pressure</emphasis>. Back pressure is described in
      detail in <xref linkend="util.pushstream.back-pressure" 
      xrefstyle="hyperlink"/>. If the returned long is negative then
      the event stream should be closed by the event source. 
      </para>
    </section>
    
    
    <section>
      <title>Closing the Event Stream</title>
      
      <para>There are three ways in which a stream can be closed:</para>
      
      <para>The Push Event Source may close the stream at any time by
      sending a terminal event to the consumer. Upon receiving a terminal
      event the consumer should clean up any resources and not expect
      to receive further messages. Note that in a multi-threaded system
      the consumer may receive events out of order, and in this case data 
      events may be received after a terminal event. Event processors 
      should be careful to ignore data events that occur after terminal
      events, and to ensure that any downstream consumers receive any
      pending data events before forwarding the terminal event.</para>
        
      <para>The <code>open</code> method of the Push Event Source returns 
      an <code>AutoCloseable</code> which can be used to close the event 
      stream. If the <code>close</code> method is called on this object then 
      the stream is terminated by sending a close event. If additional calls 
      are made to the close method then they return without action. If the 
      close method is called after a terminal event has been sent for any
      other reason then it should return without action.</para>
       
      <para>The <code>accept</code> method of the Push Event Consumer
      returns a long indicating back pressure. If the long is negative
      then the event source should immediately close the stream by sending
      a close event.</para>
    </section>
  </section>

  <section>
    <title>The Push Stream</title>
    
      <para>Simple event passing can be achieved by connecting a Push Event
      Consumer directly to a Push Event Source, however this model forces
      a large amount of flow-control and resource management into a single
      location. Furthermore it is difficult to reuse business logic across
      different event streams.</para>
    
      <para>The Push Stream provides a powerful, flexible pipeline for event
      processing. The Push Stream API shares many concepts with the Java 8 
      Streams API, in particular Push Streams are lazy, they may not consume
      the entire event stream, and they can be composed from functional steps.
      </para>
    
    <section>
      <title>Simple Pipelines</title>

      <para>A Push Stream can be created from a Push Event Source. A
      Push Stream represents a stage in an event processing pipeline. 
      The overall pipeline is constructed from zero or more 
      <code>intermediate operations</code>, and completed with a single 
      terminal operation.</para> 
      
      <para>Each intermediate operation returns a new Push Stream object
      chained to the previous pipeline step. Once a Push Stream object has 
      had an intermediate operation invoked on it then it may not have any 
      other operations chained to it. Terminal operations are either void, 
      or return a <code>Promise</code> representing the future result of 
      the pipeline. These API patterns allow Push Streams to be built using 
      a fluent API.</para>
      
      <para>Push Stream instances are lazy, and so the Push Stream will not be 
      connected to the Push Event Source until a <code>terminal operation</code> is
      invoked on the Push Stream. This means that a push stream object can
      be safely built without events being received when the pipeline is
      partially initialized.</para>
      
      <section>
        <title>Mapping, Flat Mapping and Filtering</title>
  
        <para>The simplest intermediate operations on a Push Stream are 
        <emphasis>mapping</emphasis> and <emphasis>filtering</emphasis>.
        These operations use stateless, non-interfering functions to
        alter the data receieved by the next stage in the pipeline.</para>
        
        <section>
          <title>Mapping</title>
          
          <para>Mapping is the act of transforming an event from one type into
          another. This may involve taking a field from the object, or performing
          some simple processing on it. When mapping there is an 
          <emphasis>one to one</emphasis> relationship between input and output
          events, i.e. each input event is mapped to exactly one output event.</para>
          
          <programlisting>
    PushStream&lt;String&gt; streamOfStrings = getStreamOfStrings();
    
    PushStream&lt;Integer&gt; streamOfLengths = 
            streamOfStrings.map(String::length);
          </programlisting>
          
          <para>If the mapping function throws an Exception then an Error Event
          is propagated down the stream to the next pipeline step. The failure
          in the error event is set to the Exception thrown by the mapping
          function. The current pipeline step is also closed, and the close
          operation is propagated back upstream to the event source by
          returning negative backpressure.</para>
        </section>
        
        <section>
          <title>Flat Mapping</title>
          
          <para>Flat Mapping is the act of transforming an event from one type into
          multiple events of another type. This may involve taking fields from an
          object, or performing some simple processing on it. When flat mapping there 
          is a <emphasis>one to many</emphasis> relationship between input and output
          events, i.e. each input event is mapped to zero or more output events.</para>
          
          <para>A flat mapping function should asynchronously consume the event data
          and return a Push Stream containing the flow of subsequent events.</para>
          
          <programlisting>
    PushStream&lt;String&gt; streamOfStrings = getStreamOfStrings();
    
    PushStream&lt;Character&gt; streamOfCharacters = 
            streamOfStrings.map(s -> {
                    SimplePushEventSource&lt;Character&gt; spes = 
                            getSimplePushEventSource();
                    
                    spes.connectPromise()
                        .onResolve(() ->
                            executor.execute(() -> {
                                    for(int i = 0; i &lt; s.length; i++) {
                                        spes.publish(s.charAt(i));
                                    }
                                });
                    return pushStreamProvider.createStream(spes);
                });
          </programlisting>
          
          <para>If the flat mapping function throws an Exception then an Error Event
          is propagated down the stream to the next pipeline step. The failure
          in the error event is set to the Exception thrown by the mapping
          function. The current pipeline step is also closed, and the close
          operation is propagated back upstream to the event source by
          returning negative backpressure.</para>
        </section>
        
        <section>
          <title>Filtering</title>
          
          <para>Filtering is the act of removing events from the stream based on
          some characteristic of the event data. This may involve inspecting the
          fields of the data object, or performing some simple processing on it. 
          If the filter function returns true for an event then it will be passed
          to the next stage of the pipeline. If the filter function returns false
          then it will be discarded, and not passed to the next pipeline stage.</para>
          
          <programlisting>
    PushStream&lt;String&gt; streamOfStrings = getStreamOfStrings();
    
    PushStream&lt;String&gt; filteredStrings = 
            streamOfStrings.map(s -> s.length() == 42);
          </programlisting>
          
          <para>If the filtering function throws an Exception then an Error Event
          is propagated down the stream to the next pipeline step. The failure
          in the error event is set to the Exception thrown by the filter
          function. The current pipeline step is also closed, and the close
          operation is propagated back upstream to the event source by
          returning negative backpressure.</para>
        </section>
      </section>
      
      <section>
        <title>Stateless and Stateful Intermediate Operations</title>
        
        <para>Intermediate operations are either <emphasis>stateless</emphasis>
         or <emphasis>stateful</emphasis>. Stateless operations are ones
         where the pipeline stage does not need to remember the previous
         data from the stream. Mapping, Flat Mapping and Filtering are
         all stateless operations.</para>
         
         <para>Stateful operations differ from stateless operations in that
         they must remember items from the stream. Sometimes stateful operations
         must remember large numbers of events, or even the entire stream.
         For example the <code>distinct</code> operation remembers the identity
         of each entry in the stream, and filters out duplicate events.</para>
         
         <para>Care should be taken when using Stateful operations with large
         or infinite streams. For example the <code>sorted</code> operation
         must process the <emphasis>entire</emphasis> stream until it receives 
         a close event. At this point the events can be sorted and delivered 
         in order. It is usually a good idea to use the <code>limit</code>
         operation to restrict the length of the stream before performing
         a stateful operation.</para>
         
                 <table>
          <title>Intermediate Operations on the Push Stream</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth="1.6*"/>
        
        <colspec colnum="2" colwidth="0.8*"/>

        <colspec colnum="3" colwidth="4.0*"/>

        <thead>
          <row>
            <entry>Intermediate Operation</entry>

            <entry>Stateful</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>filter()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Register a selection function to be called with each
            data event in the stream. If the function returns <code>true</code>
            then the event will propagated, if <code>false</code> then the event
            will dropped from the stream.</para></entry>
          </row>

          <row>
            <entry><code>distinct()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>A variation of <code>filter</code> which drops data
            from the stream that has already been seen. Specifically if a
            data element <code>equals</code> an element which has previously
            been seen then it will be dropped. This stateful operation must
            remember all data that has been seen.</para></entry>
          </row>

          <row>
            <entry><code>map()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Register a transformation function to be called with each
            data event in the stream. The transformed data is propagated to the
            next stage of the stream.</para></entry>
          </row>

          <row>
            <entry><code>sorted()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Remembers all items in the stream until the stream
            ends. At this point the data in the stream will be propagated to the
            next stage of the stream, in the order defined by the Comparator</para></entry>
          </row>

          <row>
            <entry><code>flatMap()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Register a transformation function to be called with each
            data event in the stream. Each incoming data element is converted into
            a stream of elements. The transformed data is then propagated to the
            next stage of the stream.</para></entry>
          </row>
          
          <row>
            <entry><code>limit(long)</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Limits the length of the stream to the defined number of 
            elements. Once that number of elements are received then a close
            event is propagated to the next stage of the stream.</para></entry>
          </row>

          <row>
            <entry><code>limit(Duration)</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Limits the time that the stream will remain open
            to the supplied Duration. Once that time has elapsed then a close
            event is propagated to the next stage of the stream.</para></entry>
          </row>
          
          <row>
            <entry><code>split()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Register a set of filter functions to select elements that
            should be forwarded downstream. The returned streams correspond to
            the supplied filter functions.</para></entry>
          </row>

          <row>
            <entry><code>skip()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Drops the supplied number of data events from the stream
            and then forwards any further data events.</para></entry>
          </row>

          <row>
            <entry><code>sequential()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Forces data events to be delivered sequentially to the
            next stage of the stream.</para></entry>
          </row>

          <row>
            <entry><code>buffer()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Introduces a buffer before the next stage of the stream.
            The buffer can be used to provide a circuit breaker, or to allow a
            switch of consumer thread(s).</para></entry>
          </row>
          
          <row>
            <entry><code>fork()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Pushes event processing onto one or more threads in
            the supplied <code>Executor</code> returning a fixed backpressure</para></entry>
          </row>

          <row>
            <entry><code>coalesce()</code></entry>

            <entry><code>true</code></entry>

            <entry>
              <para>Register a coalescing function which aggregates one or more data
              events into a single data event which will be passed to the next
              stage of the stream.</para>
            </entry>
          </row>

          <row>
            <entry><code>merge()</code></entry>

            <entry><code>false</code></entry>

            <entry>
              <para>Merges <code>this</code> stream and another stream into a
              single stream. The returned stream will not close until both
              parent streams are closed.</para>
            </entry>
          </row>
          
          <row>
            <entry><code>window()</code></entry>

            <entry><code>true</code></entry>

            <entry>
              <para>Collects events over the specified time-limit, passing them
              to the registered handler function. If no events occur during the
              time limit then no events are propagated</para>
            </entry>
          </row>
          <row>
            <entry><code>timeout()</code></entry>

            <entry><code>true</code></entry>

            <entry>
              <para>Tracks the time since the last event was received. If no
              event is received within the supplied Duration then an error event
              is propagated to the next stage of the stream. The exception in the
              event will be an <code>org.osgi.util.promise.TimeoutException</code>.</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
      </section>
      
      <section>
        <title>Terminal Operations</title>
  
        <para>Terminal operations mark the end of a processing pipeline. Invoking
        a terminal operation causes the PushStream to connect to its underlying
        event source and begin processing.</para>
        
        <para>The simplest terminal operation is the <code>count</code> 
        operation. This method returns a promise that will resolve when the stream
        finishes. If the stream finishes with a close event then the promise will
        resolve with a Long representing the number of events that reached the end 
        of the pipeline. If the stream finishes with an error then the promise will
        fail with that error.</para> 
        
        <para>Some terminal operations, like <code>count</code> require the full
        stream to be processed, others are are able to finish before the end of
        the stream. These are known as <code>short circuiting</code> operations.
        An example of a short-circuiting operation is <code>findFirst</code>. This
        operation resolves the promise with the first event that is received by
        the end of the pipeline. Once a short-circuiting operation has completed
        it propagates negative back-pressure through the pipeline to close the
        source of events.</para>
        
        <table>
          <title>Terminal Operations on the Push Stream</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth="1.6*"/>
        
        <colspec colnum="2" colwidth="0.8*"/>

        <colspec colnum="3" colwidth="4.0*"/>

        <thead>
          <row>
            <entry>Terminal Operation</entry>

            <entry>Short-circuiting</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>forEach()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Register a function to be called back with the data
            from each event in the stream</para></entry>
          </row>

          <row>
            <entry><code>forEachEvent()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Register a <code>PushEventConsumer</code> to be called 
            back with each event in the stream. If negative back-pressure is
            returned then the stream will be closed.</para></entry>
          </row>

          <row>
            <entry><code>toArray()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Collects together all of the event data in a
            single array which is used to resolve the returned promise.</para></entry>
          </row>

          <row>
            <entry><code>reduce()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Uses a Binary Operator function to combine event data
            into a single object. The promise is resolved with the final result
            when the stream finishes.</para></entry>
          </row>

          <row>
            <entry><code>collect()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Uses the Java Collector API to collect the data from
            events into a single Collection, Map, or other type.</para></entry>
          </row>
          
          <row>
            <entry><code>min()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Uses a Comparator to find the smallest data element in
            the stream of data. The promise is resolved with the final result
            when the stream finishes.</para></entry>
          </row>
          
          <row>
            <entry><code>max()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Uses a Comparator to find the largest data element in
            the stream of data. The promise is resolved with the final result
            when the stream finishes.</para></entry>
          </row>

          <row>
            <entry><code>count()</code></entry>

            <entry><code>false</code></entry>

            <entry><para>Counts the number of events that reach the end of
            the stream pipeline.</para></entry>
          </row>

          <row>
            <entry><code>anyMatch()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Resolves with <code>true</code> if any data event reaches
            the end of the stream pipeline and matches the supplied predicate.
            If the stream ends without any data matching the predicate then
            the promise resolves with <code>false</code></para></entry>
          </row>

          <row>
            <entry><code>allMatch()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Resolves with <code>false</code> if any event reaches
            the end of the stream pipeline that does not match the predicate.
            If the stream ends without any data matching the predicate then
            the promise resolves with <code>true</code></para></entry>
          </row>
          
          <row>
            <entry><code>anyMatch()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Resolves with <code>true</code> if any data event reaches
            the end of the stream pipeline and matches the supplied predicate.
            If the stream ends without any data matching the predicate then
            the promise resolves with <code>false</code></para></entry>
          </row>

          <row>
            <entry><code>findFirst()</code></entry>

            <entry><code>true</code></entry>

            <entry><para>Resolves with an Optional representing the data
            from the first event that reaches the end of the pipeline. 
            If the stream ends without any data reaching the end of the
            pipleine then the promise resolves with an empty Optional.</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
        
      </section>
    </section>
    
    <section>
      <title>Buffering, Back pressure and Circuit Breakers</title>
    
      <para>Buffering and Back Pressure are an important part of asynchronous 
      stream processing. Back pressure and buffering are therefore an important
      part of the push stream API.</para>
      
      <section xml:id="util.pushstream.back-pressure">
        <title>Back pressure</title>
        <para>In a synchronous model the producer's thread is held by the consumer 
        until the consumer has finished processing the data. This is not true for 
        asynchronous systems, and so a producer can easily overwhelm a consumer with
        data. Back pressure is therefore used in asynchronous systems to allow 
        consumers to control the speed at which producers provide data.</para>
        
        <para>Back pressure in the asynchronous event processing model is
        is provided by the PushEventConsumer. The value returned by the 
        <code>accept</code> method of the PushEventConsumer is an indication of
        the requested back pressure. A return of zero indicates that event
        delivery may continue immediately. A positive return value indicates
        that the source should delay sending any further events for the
        requested number of milliseconds. A return value of -1 indicates that
        no further events should be sent and that the stream can be closed.</para>
      </section>
    
      <section>
        <title>Buffering</title>
        
        <para>In asynchronous systems events may be produced and consumed at
        different rates. If the consumer is faster than the producer then there
        is no issue, however if the producer is faster than the consumer then
        events must be held somewhere. Backpressure provides some assistance
        here, however some sources do not have control over when events are
        produced. In these cases the data must be buffered until it can be 
        processed.</para>
        
        <para>As well as providing a queue for pending work, introducing buffers
        allows event processing to be moved onto a different thread, and for the 
        number of processing threads to be changed part way through the pipeline. 
        Buffering can therefore protect an PushEventSource from having its event 
        generation thread “stolen” by a consumer which executes a long running 
        operation. As a result the PushEventSource can be written more simply, 
        without a thread switch, if a buffer is used.</para>

        <para>Buffering also provides a “fire break” for back-pressure. Back-pressure
        return values propagate back along a PushStream until they reach a part of 
        the stream that is able to respond. For some PushEventSource implementations 
        it is not possible to slow or delay event generation, however a buffer can 
        always respond to back pressure by not releasing events from the buffer. 
        Buffers can therefore be used to “smooth out” sources that produce bursts of 
        events more quickly than they can be immediately processed. This simplifies 
        the creation of PushEventConsumer instances, which can rely on their 
        back-pressure requests being honoured.</para>
      
        <para>Buffering is provided by the Push Stream using default configuration values,
        either when creating the Push Stream from the Push Stream Provider, or using the
        <code>buffer</code> method. These values can be overridden by using a 
        <code>PushStreamBuilder</code> to explicitly provide the buffering parameters. If 
        no Executor is provided then the PushStream will create its own internal Executor 
        with the same number of threads as the defined parallelism. An internally created 
        Executor will be shut down when the PushStream is closed.</para>
        
        <para>The PushStreamBuilder can be used to customize the buffer at the start of 
        the PushStream, or it can be used to create an unbuffered PushStream. An unbuffered 
        PushStream uses the incoming event delivery thread to process the events, and 
        therefore users must be careful not to block the thread, or perform long-running 
        tasks. The default configuration when buffering is as follows:</para>
        
        <itemizedlist>
          <listitem><para>A parallelism of one</para></listitem>
          <listitem><para>A <code>FAIL</code> QueuePolicy</para></listitem>
          <listitem><para>A <code>LINEAR</code> PushbackPolicy with a maximum pushback of one second</para></listitem>
          <listitem><para>A Buffer with a capacity of 32 elements</para></listitem>
        </itemizedlist>
        

      </section>
        <section>
          <title>Circuit Breakers</title>
          <para>Buffering is a powerful tool in event processing pipelines, however it
          cannot help in the situation where the average event production rate is higher
          than the average processing rate. Rather than having an infinitely growing
          buffer a circuit breaker is used. A circuit breaker is a buffer which fails
          the stream when the buffer is full. This halts event processing and prevents
          the consuming system from being overwhelmed.</para>
          
          <para>The default policy for push stream buffers is the FAIL policy, which
          means that push stream buffers are all circuit breakers by default.</para>
        </section>
    
    </section>
    
    <section>
      <title>Forking</title>
      
      <para>Sometimes the processing that needs to be performed on an event is 
      long-running. An important part of the asynchronous eventing model is that 
      callbacks are short and non-blocking, which means that these callbacks should not 
      run using the primary event thread. One solution to this is to buffer the stream, 
      allowing a thread handoff at the buffer and limiting the impact of the long-running 
      task. Buffering, however, has other consequences, and so it may be the case that a 
      simple thread hand-off is preferable.</para>
      
      <para>Forking allows users to specify a maximum number of concurrent downstream 
      operations. Incoming events will block if this limit has been reached. If there are 
      blocked threads then the returned back pressure for an event will be equal to the 
      number of queued threads multiplied by the supplied timeout value. If there are no 
      blocked threads then the back pressure will be zero.</para>
    </section>
    
    <section>
      <title>Coalescing and Windowing</title>
  
      <para>Coalescing and windowing are both processes by which multiple incoming
      data events are collapsed into a single outgoing event.</para>
      
      <section>
        <title>Coalescing</title>
        <para>There are two main ways to coalesce a stream.</para>
        
        <para> The first mechanism delegates all
        responsibility to the coalescing function, which returns an <code>Optional</code>.
        The coalescing function is called for every data event, and returns an optional
        which either has a value, or is empty. If the optional has a value then this value
        is passed to the next stage of the processing pipeline. If the optional is empty
        then no data event is passed to the next stage.
        </para>

        <para> The second mechanism allows the stream to be configured with a
        (potentially variable) buffer size. The stream then stores values into this
        buffer. When the buffer is full then the stream passes the buffer to the
        handler function, which returns data to be passed to the next stage. If the
        stream finishes when a buffer is partially filled then the partially filled
        buffer will be passed to the handler function.</para>
        
        <para>When coalescing events there is no opportunity for feedback from the 
        event handler while the events are being buffered. As a result back pressure 
        from the handler is zero except when the event triggers a call to the next stage. 
        When the next stage is triggered the back pressure from that stage is returned.</para>
      </section>

      <section>
        <title>Windowing</title>
        <para>Windowing is similar to coalescing, the primary difference between 
        coalescing and windowing is the way in which the next stage of processing
        is triggered. A coalescing stage collects events until it has the correct 
        number and then passes them to the handler function, regardless of how long 
        this takes. A windowing stage collects events for a given amount of time, and 
        then passes the collected events to the handler function, regardless of how many 
        events are collected.</para>
        
        <para>To avoid the need for a potentially infinite buffer a windowing stage may 
        also place a limit on the number of events to be buffered. If this limit is reached 
        then the window finishes early and the buffer is passed to the client, just like a 
        coalescing stage. In this mode of operation the handler function is also passed the 
        length of time for which the window lasted.</para>

        <para>As windowing requires the collected events to be delivered asynchronously 
        there is no opportunity for back-pressure from the previous stage to be applied 
        upstream. Windowing therefore returns zero back-pressure in all cases except when 
        a buffer size limit has been declared and is reached. If a window size limit is 
        reached then the windowing stage returns the remaining window time as back 
        pressure. Applying back pressure in this way means that the event source will 
        tend not to repeatedly over saturate the window.</para>
      </section>
      
    </section>

    <section>
      <title>Merging and Splitting</title>
  
      <para>Merging and Splitting are actions that can be used to combine push streams,
      or to convert one stream into many streams.</para>
      
      <section>
        <title>Merging</title>
        <para>A client may need to consume data from more than one Event Sources. In 
        this case the PushStream may be used to merge two event streams. The returned
        stream will receive events from both parent streams, but will only close when
        <emphasis>both</emphasis> parent streams have delivered terminal events.</para>
      </section>
      
      <section>
        <title>Splitting</title>
        <para>Sometimes it is desirable to split a stream into multiple parallel pipelines. 
        These pipelines are independent from the point at which they are split, but share 
        the same source and upstream pipeline.</para>
        
        <para>Splitting a stream is possible using the 
        <code>split(Predicate&lt;? super T &gt;... predicates)</code> method. For each 
        predicate a PushStream will be returned that receives the events accepted by the 
        predicate.</para>
        
        <para>The lifecycle of a split stream differs from that of a normal stream in two 
        key ways:</para>
        
        <itemizedlist>
          <listitem><para>The stream will begin event delivery when any of the downstream 
          handlers encounters a terminal operation</para></listitem>
          <listitem><para>The stream will only close when all of the downstream handlers 
          are closed</para></listitem>
        </itemizedlist>
      </section>
      
    </section>
    <section>
      <title>Time Limited Streams</title>
        
      <para>An important difference between Push Streams and Java 8 Streams is that 
      events occur over time, there are therefore some operations that do not apply 
      to Java 8 Streams which are relevant to Push Streams.</para>
        
      <para>The <code>limit()</code> operation on a Stream can be used to limit the 
      number of elements that are processed, however on a Push Stream that number of 
      events may never be reached, even though the stream has not closed. Push Streams 
      therefore also have a <code>limit</code> method which takes a <code>Duration</code>. 
      This duration limits the time for which the stream is open, closing it after the 
      duration has elapsed.</para>

      <para>The <code>timeout</code> operation of a Push Stream can be used to end a 
      stream if no events are received for the given amount of time. If an event 
      is received then this resets the timeout counter. The timeout operation is 
      therefore a useful mechanism for identifying pipelines which have stalled 
      in their processing. If the timeout expires then it propagates an error event
      to the next stage of the pipeline. The Exception in the error event is an
      <code>org.osgi.util.promise.TimeoutException</code>.
      </para>
    </section>
  </section>
    <section>
      <title>The Push Stream Provider</title>
    
      <para>The <code>PushStreamProvider</code> can be used to assist with a variety 
      of asynchronous event handling use cases. A Push Stream Provider can create 
      Push Stream instances from a Push Event Source, it can buffer an Push Event Consumer,
      or it can turn a Push Stream into a reusable Push Event Source.</para>
      
      <section>
        <title>Building Buffers</title>
  
        <para>The Push Stream Provider allows several types of buffered objects to be
        created. By default all Push Streams are created with a buffer, but other
        objects can also be wrapped in a buffer. For example a Push Event Consumer can
        be wrapped in a buffer to isolate it from a Push Event Source. The 
        <code>SimplePushEventSource</code> also has a buffer, which is used
        to isolate the event producing thread from event consumers.</para>
        
        <para>In all cases buffers are configured using a <code>BufferBuilder</code>
        with the following defaults:</para>
        
        <itemizedlist>
          <listitem><para>A parallelism of one</para></listitem>
          <listitem><para>A <code>FAIL</code> QueuePolicy</para></listitem>
          <listitem><para>A <code>LINEAR</code> PushbackPolicy with a maximum pushback of one second</para></listitem>
          <listitem><para>A Buffer with a capacity of 32 elements</para></listitem>
        </itemizedlist>
        
        <para>If no Executor is provided when creating a buffer then the buffer will 
        have its own internal Executor with the same number of threads as the defined 
        parallelism. An internally created Executor will be shut down after the buffer has
        processed a terminal event.</para>
        
      </section>

      <section>
        <title>Mapping between Java 8 Streams and Push Streams</title>
        <para>There are a number of scenarios where an application developer may wish to 
        convert between a Java 8 Stream and a PushStream. In particular, the 
        <code>flatMap</code> operation of a Push Stream takes a single event and converts 
        it into many events in a Push Stream. Common operations, such as splitting the 
        event into child events will result in a Java Collection, or a Java 8 Stream. 
        These need to be converted into a Push Stream before they can be returned from 
        the flatMap operation.</para>
        
        <para>To assist this model the PushStreamProvider provides two <code>streamOf</code> 
        methods. These convert a Java 8 Stream into a Push Stream, changing the pull-based 
        model of Java 8 Streams into the asynchronous model of the Push Stream.</para>
        
        <para>The first <code>streamOf</code> method takes a Java 8 Stream. The 
        PushStream created by this method is not fully asynchronous, it uses the 
        connecting thread to consume the Java 8 Stream. As a result the streams created 
        using this method will block terminal operations. This method should therefore 
        not normally be used for infinite event streams, but instead for short, finite 
        streams of data that can be processed rapidly, for example as the result of a 
        flatmapping operation. In this scenario reusing the incoming thread improves 
        performance.</para>
        
        <para>For larger Streams of data, or when truly asynchronous operation is 
        required, there is a second <code>streamOf</code> method which also takes an 
        <code>Executor</code>. This Executor is used to asynchronously consume elements 
        from the Java 8 Stream using a single task. This mode of operation is suitable 
        for use with infinite data streams, or for streams which require a truly 
        asynchronous mode of operation, and does not require the stream to be parallel.</para>
      </section>
      
    </section>
      <section>
        <title>Simple Push Event Sources</title>
  
        <para>The PushEventSource and PushEventConsumer are both functional interfaces, 
        however it is noticeably harder to implement a PushEventSource than a 
        PushEventConsumer. A PushEventSource must be able to support multiple 
        independently closeable consumer registrations, all of which are providing 
        potentially different amounts of back pressure.</para>
        
        <para>To simplify the case where a user wishes to write a basic event source the 
        PushStreamProvider is able to create a SimplePushEventSource. The 
        SimplePushEventSource handles the details of implementing PushEventSource, providing 
        a simplified API for the event producing code to use.</para>
        
        <para>Events can be sent via the Simple Push Event Source <code>publish(T t)</code> 
        method at any time until it is closed. These events may be silently ignored if no 
        consumer is connected, but if one or more consumers are connected then the event 
        will be asynchronously delivered to them, When the event has been delivered to all 
        of the connected consumers then the returned promise will resolve.</para>
        
        <para>Close or error events can be sent equally easily using the 
        <code>endOfStream()</code> and <code>error(Exception e)</code> methods. These will 
        send disconnection events to all of the currently connected consumers and remove 
        them from the Simple Push Event Source. Note that sending these events does not 
        close the Simple Push Event Source. Subsequent connection attempts will succeed, 
        and events can still be published.</para>
        
        <section>
          <title>Optimising Event Creation</title>

          <para>In addition to the publication methods the Simple Push Event Source 
          provides <code>isConnected()</code> and <code>connectPromise()</code> methods. 
          The isConnected method gives a point-in-time snapshot of whether there are any 
          connections to the Simple Push Event Source. If this method returns false then 
          the event producer may wish to avoid creating the event, particularly if it is 
          computationally expensive to do so. The connectPromise method returns a Promise 
          representing the current connection state. This Promise resolves when there is a 
          client connected (which means it may be resolved immediately as it is created). 
          If the Simple Push Event Source is closed before the Promise resolves then the 
          Promise is failed with an IllegalStateException. The connect Promise can be used 
          to trigger the initialisation of an event thread, allowing lazier startup.</para>
        </section>
      </section>


  <section>
    <title>Security</title>

    <para>The Push Stream API does not define any OSGi services nor does the 
    API perform any privileged actions. Therefore, it has no security
    considerations.</para>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.util.pushstream.xml"/>

  <section>
    <title>References</title>
      <para>TODO</para>

  </section>

</chapter>
