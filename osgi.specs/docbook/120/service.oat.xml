<?xml version="1.0" encoding="utf-8"?>
<chapter label="120"
         revision="$Id$"
         version="5" xml:id="service.oat"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Foreign Application Access Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.application-version"
    linkend="org.osgi.application"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The OSGi Framework contains an advanced collaboration model which
    provides a publish/find/bind model using <emphasis>services</emphasis>.
    This OSGi service architecture is not natively supported by foreign
    application models like MIDP, Xlets, Applets, other Java application
    models. The purpose of this specification is to enable these foreign
    applications to participate in the OSGi service oriented
    architecture.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Interoperatbility</emphasis> - Full
          inter-operability between foreign application models and OSGi
          services is required. This requires both getting services,
          registering services, and listening to Framework events.</para>
        </listitem>

        <listitem>
          <para><emphasis>No Change</emphasis> - The inter-working
          specification cannot modify the life cycle model of the foreign
          application models. The foreign application model specifications
          cannot be changed.</para>
        </listitem>

        <listitem>
          <para><emphasis>Familiarity</emphasis> - Programmers familiar with a
          foreign application model should be able to leverage the services
          architecture without much effort.</para>
        </listitem>

        <listitem>
          <para><emphasis>Simplicity</emphasis> - The programming model for
          using services must be very simple and not require the programmer to
          learn many new concepts.</para>
        </listitem>

        <listitem>
          <para><emphasis>Management</emphasis> - Support managing the foreign
          applications; both through proper OSGi APIs and from a remote
          management server.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Foreign Application</emphasis> - Java Applications,
          which must be delivered in JAR files, which are not OSGi
          bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Container</emphasis> - An Application
          Container is responsible for controlling a foreign application and
          providing the appropriate environment. It must interact with the
          OSGi Framework to give the foreign application instances access to
          the OSGi services and package sharing.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Activator</emphasis> - A class in the
          foreign application JAR file that is used to notify the application
          of life cycle changes. One JAR file can contain multiple application
          activators.</para>
        </listitem>

        <listitem>
          <para><emphasis>Framework</emphasis> - A class that provides access
          to the application container's <emphasis>application
          context</emphasis> for a given application activator.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Context</emphasis> - The interface to
          the application container's functions to inter-work with the OSGi
          Framework.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Declaration</emphasis> - An XML resource
          that must be placed in the application's JAR file at
          <code>OSGI-INF/app/apps.xml</code>. This is an optional
          declaration.</para>
        </listitem>

        <listitem>
          <para><emphasis>Application Instance</emphasis> - A launched
          application. Most foreign application models permit an application
          to be launched multiple times.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Foreign Applications, org.osgi.application package</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.865in"
                       contentwidth="7.000in" fileref="oat-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Synopsis</title>

      <para>Foreign application JAR files can be installed in an OSGi
      Framework as if they were normal bundles. Application containers running
      on the OSGi Framework must detect the installation of recognized foreign
      applications and provide a bridge to the OSGi Environment. This bridge
      can include interaction with the <xref linkend="service.application"/>,
      as well as provide access to the OSGi services and Framework
      events.</para>

      <para>The Application container reads the application XML resource from
      the JAR file and treats the foreign application according to this
      information. When the foreign application is launched, the application
      container creates an application instance.</para>

      <para>Foreign application instances can get an application context
      through a static method on the <code>Framework</code> class. The
      Application Context provides access to getting services, registering
      services and registering listeners.</para>

      <para>The foreign application instance's life cycle can be influenced by
      the application declaration. If desired, an application can be prevented
      from launching or stopping when required services are, or become,
      unavailable.</para>
    </section>
  </section>

  <section>
    <title>Foreign Applications</title>

    <para>Foreign applications are Java applications that can be installed and
    managed through the normal OSGi mechanisms. However, they use another
    application programming model than the bundle programming model. For
    example: MIDP, MHP, DOJA.</para>

    <para>Foreign applications must fulfill the following requirements to be
    able to inter-work with the OSGi environment:</para>

    <itemizedlist>
      <listitem>
        <para>The applications must be written in Java</para>
      </listitem>

      <listitem>
        <para>The applications must be delivered in JAR files. This is the
        common model for Java applications.</para>
      </listitem>

      <listitem>
        <para>They must have a clearly defined life cycle with a start and
        stop state.</para>
      </listitem>

      <listitem>
        <para>One or more classes in the application must be available to
        start and stop the application. For example the Midlet in MIDP or the
        Xlet in MHP. This object is called the <emphasis>application's
        activator</emphasis>. As the application container uses this object
        for life cycle control of the application, the lifetime of this object
        equals the lifetime of the application.</para>
      </listitem>
    </itemizedlist>

    <para>Foreign applications are managed by <emphasis>application
    containers</emphasis>. Application containers provide the environment and
    life cycle management as defined by foreign application model.</para>

    <para>This specification does not require any changes in the foreign
    application model; existing applications must run unmodified. However, to
    allow the foreign applications to participate as a first class OSGi
    citizen, a number of additional artifacts in the JAR file are required.
    These artifacts use Manifest headers and an XML resource in the
    applications JAR file; these artifacts are permitted and ignored by the
    foreign application models that are currently known.</para>

    <section>
      <title>Foreign Metadata</title>

      <para>There are different types of metadata associated with application
      models. Descriptive information, for example the name, icon,
      documentation etc. of the application, is usually provided in an
      application model specific way. Application models can also define
      behavioral metadata, that is, prescribe that the application needs to be
      started automatically at device startup (auto start) or whether multiple
      instances of an application can be executed concurrently (singleton).
      These kinds of metadata are supported by different application models to
      different extent and are not in the scope of this specification. The
      application container is responsible for interpreting this metadata and
      treating the foreign application in the appropriate way.</para>
    </section>

    <section>
      <title>OSGi Manifest Headers</title>

      <para>Foreign applications can import packages by specifying the
      appropriate OSGi module headers in the manifest. These headers are fully
      described in <xref linkend="intro.core.release"
      xrefstyle="template:%t"/>. Their semantics remain unchanged. The
      following headers must not be used in foreign applications:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Export-Package</emphasis> - Exporting packages is
          forbidden in foreign applications.</para>
        </listitem>

        <listitem>
          <para><emphasis>Bundle-Activator</emphasis> - Foreign applications
          have their own activator.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service-Component</emphasis> - Service components
          should be bundles.</para>
        </listitem>
      </itemizedlist>

      <para>Foreign applications that intend to use the OSGi Framework
      features should have Bundle-SymbolicName and Bundle-Version headers. If
      they do not have such a header, they can be deployed with Deployment
      Package, which can assign these headers in the Deployment Package
      manifest.</para>

      <para>Any JAR that uses these headers must not be recognized as a
      foreign application, even if their manifest is conforming and valid with
      respect to the foreign application model. This entails that a JAR cannot
      both be a bundle with activator or exports and a foreign
      application.</para>

      <para>For example, a MIDlet can be extended to import the
      <code>org.osgi.application</code> package from the OSGi environment. The
      Import-Package header is used to describe such an import:</para>

      <programlisting>Manifest-Version: 1.0
MIDlet-Name: Example
MIDlet-1: Example, , osgi.ExampleMidlet
MIDlet-Version: 1.1.0
MIDlet-Vendor: OSGi
MicroEdition-Configuration: CDC-1.0
MicroEdition-Profile: MIDP-1.0
Bundle-ManifestVersion: 2
Bundle-SymbolicName: osgi.example 
Import-Package: org.osgi.application;version=1.0,
  org.osgi.framework;version=1.3</programlisting>
    </section>

    <section>
      <title>Interacting with the OSGi Framework</title>

      <para>The application container must maintain an application context for
      each started application, that is, the application instance. This
      context is related to the application's activator. The Application
      Context can be acquired using a static <xref
      linkend="org.osgi.application.Framework.getApplicationContext-Object-"
      xrefstyle="hyperlink"/> method on the <xref
      linkend="org.osgi.application.Framework" xrefstyle="hyperlink"/> class.
      The parameter of this method is the application's activator itself. The
      <code>getApplicationContext</code> method cannot check if the caller is
      really the given application; the application activator is therefore a
      <emphasis>capability</emphasis>, any application that has this object
      can get the Application Context. The application activator should never
      be shared with other applications. The Application Context must
      therefore deny the application activator to be used as a service
      object.</para>

      <para>The <code>getApplicationContext</code> method must not be called
      from the application activator's constructor; at that time it must not
      be available yet.</para>

      <para>For example, a MIDlet could acquire the application context with
      the following code:</para>

      <programlisting>import org.osgi.framework.*;
import org.osgi.application.*;
import javax.microedition.midlet.*;

public class Example extends MIDlet {
    ApplicationContext     context;
    public void startApp() {
            context = Framework.getApplicationContext(this);
    }

    public void pauseApp() { ... }

    public void destroyApp(boolean unconditional) { ... }
}  </programlisting>

      <para>The <code>getApplicationContext</code> method must throw an
      Illegal Argument Exception if it is called with an object that is not an
      application's activator.</para>

      <para>The <code>ApplicationContext</code> object is singleton for the
      corresponding application's activator. Subsequent calls to the
      <code>getApplicationContext</code> method with the same application's
      activator must return the same <code>ApplicationContext</code> object;
      therefore, applications are free to forget and get the object any number
      of times during their lifetime. However, it is an error to get the
      <code>ApplicationContext</code> object for an application that is
      already stopped. Existing <code>ApplicationContext</code> objects must
      be invalidated once the application's activator is stopped.</para>
    </section>

    <section>
      <title>Introspection</title>

      <para>The Application Context provides the following methods about the
      application:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.application.ApplicationContext.getApplicationId--"
          xrefstyle="hyperlink"/> - Return the Application Descriptor id for
          this application.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.application.ApplicationContext.getInstanceId--"
          xrefstyle="hyperlink"/> - Return the instance id for this
          application.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="i1608489">
      <title>Access to Services</title>

      <para>Foreign applications do not have direct access to the OSGi service
      registry. However, the application context provides the mechanism to
      interact with this service registry.</para>

      <para>Access to services is more protected and controlled than
      traditional OSGi access that uses the <code>BundleContext</code> object.
      The service model is conceptually based on the <xref
      linkend="service.component"/>. It uses the same concepts as that
      specification. Albeit there are a number of differences due the nature
      of foreign applications.</para>

      <para>Applications can use the <code>locateService</code> or
      <code>locateServices</code> methods of their associated application
      context to obtain service objects from the OSGi service registry. Just
      like OSGi Declarative services, these service objects must be declared a
      priori in the <code>reference</code> element of the metadata, see <xref
      linkend="i1620405"/>. This metadata declares a number of <emphasis>named
      references</emphasis>; References contain the criteria which services
      are eligible for use by the application and how these dependencies
      should be handled. The foreign application can only use services defined
      in references; the application context only takes the name of a
      reference as parameter in the <code>locateService</code> and
      <code>locateServices</code> methods. That is, a foreign application
      cannot indiscriminately use the service registry, it is restricted by
      the application declaration.</para>

      <para>A reference <emphasis>selects</emphasis> a subset of services in
      the service registry. The primary selector is its
      <emphasis>interface</emphasis>. However, this subset can be further
      narrowed down with a <emphasis>target </emphasis>filter. The target
      specifies an OSGi filter expression that is used to additionally qualify
      the subset of appropriate services.</para>

      <para>There are two different methods to access the services selected by
      the reference:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.application.ApplicationContext.locateService-String-"
          xrefstyle="hyperlink"/> - Return one of the services that is
          selected by the reference with the given name. If multiple services
          are selected by the reference, then the service with the highest
          ranking must be returned. This is compatible with the
          <code>getServiceReference</code> method in the OSGi Framework's
          <code>BundleContext</code> class.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.application.ApplicationContext.locateServices-String-"
          xrefstyle="hyperlink"/> - Return all the services that are selected
          by the reference with the given name.</para>
        </listitem>
      </itemizedlist>

      <para>Once the application instance has obtained a service object, that
      service is said to be <emphasis>bound</emphasis> to the application
      instance. There is no method to unbind a service.</para>

      <para>For example, a foreign application that wants to log via the Log
      Service, should declare the following metadata in
      <code>OSGI-INF/app/apps.xml:</code></para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;descriptor xmlns="http://www.osgi.org/xmlns/app/v1.1.0"&gt;
        &lt;application class="com.acme.app.SampleMidlet"&gt;
        &lt;reference name="log" 
            interface="org.osgi.service.log.LogService"/&gt; 
    &lt;/application&gt;
&lt;/descriptor&gt;</programlisting>

      <para>The code to log could look like:</para>

      <programlisting>void log(String msg) {
    ApplicationContext ctxt=    
        Framework.getApplicationContext(this);
    LogService log = (LogService) ctxt.locateService("log");
    log.log( LogService.LOG_INFO, msg );
}</programlisting>
    </section>

    <section>
      <title>Service Properties</title>

      <para>The foreign applications receive the services objects they have
      access to directly. This means that they cannot access the service
      properties that are normally associated with the service
      registrations.</para>

      <para>The <xref
      linkend="org.osgi.application.ApplicationContext.getServiceProperties-Object-"
      xrefstyle="hyperlink"/> returns a <code>Map</code> object with a copy of
      these service properties.</para>
    </section>

    <section>
      <title>Dependencies on Services</title>

      <para>The availability of services can influence the life cycle of the
      foreign application. The life cycle is influenced by the
      <emphasis>policy</emphasis> and the
      <emphasis>cardinality</emphasis>.</para>

      <para>The policy defines how the unregistration of a bound service must
      be handled. The following policies are supported:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>static</emphasis> - The application assumes that
          bound services will never go away. So if a bound service becomes
          unregistered, the Application Container must stop the application to
          prevent it from using a stale service.</para>
        </listitem>

        <listitem>
          <para><emphasis>dynamic</emphasis> - The application must never
          store service objects and will always get them on demand. Once a
          service is bound, it can become unregistered without any effect on
          the application.</para>
        </listitem>
      </itemizedlist>

      <para>Additionally, the <emphasis>cardinality</emphasis> defines if a
      reference is optional. An optional reference does not influence the life
      cycle of an application, a mandatory reference does. The cardinality is
      expressed as one of the following values:</para>

      <itemizedlist>
        <listitem>
          <para><code>0..1</code> or <code>0..n</code> - Optional
          reference</para>
        </listitem>

        <listitem>
          <para><code>1..1</code> or <code>1..n</code> - Mandatory
          reference</para>
        </listitem>
      </itemizedlist>

      <para>The multiplicity is only for compatibility with the Declarative
      Services. Both <code>locateService</code> and
      <code>locateServices</code> methods can be used regardless of the given
      multiplicity and return the selected subset for the given
      reference.</para>

      <para>Mandatory references can influence the launching of an
      application. An application must only be started when a mandatory
      reference is <emphasis>satisfied</emphasis>. A reference is satisfied
      when there is at least one registered service selected by the
      reference.</para>

      <para>If a mandatory reference of an application is about to become
      unsatisfied, due to unregistering a service, the application container
      must stop the application instance according to corresponding
      application model semantics.</para>
    </section>

    <section>
      <title>Registering Services</title>

      <para>A common pattern in the OSGi is registering a service to listen to
      certain events. For example, the Configuration Admin service requires
      their clients to register a callback Managed Service, so that the
      service can asynchronously update the client with new configurations.
      The <code>ApplicationContext</code> interface contains methods that
      allow the applications to register such services. These services must be
      automatically unregistered by the application container after the
      application has been stopped.</para>

      <para>The available methods are:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.application.ApplicationContext.registerService-String---Object-Dictionary-"
          xrefstyle="hyperlink"/> - Register a service under a single
          interface.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.application.ApplicationContext.registerService-String-Object-Dictionary-"
          xrefstyle="hyperlink"/> - Register a service under a number of
          interfaces.</para>
        </listitem>
      </itemizedlist>

      <para>Either method requires that the given object implements all the
      interfaces that are given. The <code>Dictionary</code> object provides
      the properties. See the OSGi <code>registerService</code> methods in the
      <code>BundleContext</code> class. These identical methods specifies the
      behavior in detail.</para>

      <para>The use of the application activator as a service object is
      explicitly forbidden. Registering the application activator as a service
      allows other applications in the OSGi environment to access the
      Application Context using this object and the
      <code>getApplicationContext</code> method.</para>

      <para>Both methods return a <code>ServiceRegistration</code> object that
      can be used to unregister the service. Services must be automatically
      unregistered when the application instance is stopped.</para>
    </section>

    <section>
      <title>Listening to Service Events</title>

      <para>The Application Context provides the following methods to listen
      to service events:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.application.ApplicationContext.addServiceListener-ApplicationServiceListener-String-"
          xrefstyle="hyperlink"/> - Add an Application Service Listener. The
          listener will receive the service events for the given reference
          name.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.application.ApplicationContext.addServiceListener-ApplicationServiceListener-String---"
          xrefstyle="hyperlink"/> - Add an Application Service Listener that
          will receive the events for all the services identified with the
          given reference name.</para>
        </listitem>
      </itemizedlist>

      <para>If a Application Service Listener is registered more than once,
      then the previous registration is removed. Listeners can be removed with
      <xref
      linkend="org.osgi.application.ApplicationContext.removeServiceListener-ApplicationServiceListener-"
      xrefstyle="hyperlink"/>. When the application instance is stopped, the
      listeners are automatically unregistered.</para>
    </section>

    <section>
      <title>Access to Startup Parameters</title>

      <para>Applications can use the <code>getStartupArguments</code> method
      on the application context to obtain their startup arguments. The
      startup arguments are represented as map with name and value pairs. The
      name is a non-<code>null</code> and non-empty ("") <code>String</code>
      object. The value can be any type of object.</para>

      <para>The reason for providing the startup parameters through a special
      mechanism is that it allows foreign applications access to the
      parameters of a schedule application, see <xref
      linkend="service.application.scheduling"/>.</para>

      <para>This uniform access to the startup parameters provides a uniform
      way for applications of any foreign application model. This facility
      does not remove the need for any mechanisms required by the foreign
      application model for startup parameters access.</para>
    </section>

    <section>
      <title>Sibling Instances</title>

      <para>Most foreign application models allow an application to be
      launched multiple times, creating multiple instances. In OSGi, a bundle
      can only be started once, which creates certain assumptions. For
      example, the Service Factory concept creates a unique service object per
      bundle.</para>

      <para>Each application instance must be seen as a unique bundle while it
      runs. That is, it should not share anything with other instances. The
      foreign application container is responsible for this isolation;
      implementing this isolation requires implementation dependent
      constructs.</para>
    </section>
  </section>

  <section>
    <title>Application Containers</title>

    <para>Application containers:</para>

    <itemizedlist>
      <listitem>
        <para>Provide management for the foreign applications</para>
      </listitem>

      <listitem>
        <para>Launches application instances in a defined environment</para>
      </listitem>

      <listitem>
        <para>Provide a specific a application model context to foreign
        application instances</para>
      </listitem>

      <listitem>
        <para>Interact with the Application Admin service to provide the
        foreign applications to application managers.</para>
      </listitem>
    </itemizedlist>

    <para>A single OSGi environment can host multiple application
    containers.</para>

    <section>
      <title>Installation</title>

      <para>Applications are installed into the system using OSGi bundle
      installation mechanism (i.e. <code>installBundle</code> method of the
      <code>BundleContext</code> interface). This allows including application
      JARs to Deployment Packages without any changes to the Deployment
      Package format or Deployment Admin behavior. It also allows the OSGi
      framework to process the dependency information (the package
      dependencies) included in the application metadata.</para>

      <para>The application container can listen to the
      <code>BundleEvent.INSTALLED</code> events and examine the installed JARs
      whether they contain applications supported by the particular container.
      After the installation, the application container is responsible for
      registering the corresponding Application Descriptor as defined in the
      <xref linkend="service.application"/>. Similarly, the container can
      recognize the removal of the package by listening to
      <code>BundleEvent.UNINSTALLED</code> events and then it can unregister
      the corresponding descriptors. Additionally, application container must
      check the bundle registry for changes when they are started.</para>

      <para>Receiving <code>BundleEvent.INSTALLED</code> events via a
      Synchronous Bundle Listener makes it possible for the application
      container to examine the package content during installation. A foreign
      application must not become available for execution unless it is started
      as a bundle. This mechanism allows foreign applications to be installed
      but not yet recognized as a foreign application.</para>
    </section>
  </section>

  <section xml:id="i1620405">
    <title>Application Descriptor Resource</title>

    <para>Applications' dependencies on services must be declared in the
    <code>OSGI-INF/app/apps.xml</code> resource. The XML file must use the
    <code>http://www.osgi.org/xmlns/app/v1.1.0</code> namespace. The preferred
    abbreviation is <code>app</code>. The XML schema definition can be found
    at <xref linkend="i1609213"/>. The <code>apps.xml</code> file is optional
    if a foreign application does not require any dependencies.</para>

    <para>The structure of the XML must conform to the description
    below.</para>

    <programlisting>&lt;descriptor&gt;     ::= &lt;application&gt; +
&lt;application&gt;    ::= &lt;reference&gt; *              </programlisting>

    <section>
      <title>Descriptor Element</title>

      <para>The descriptor is the top level element. The
      <code>descriptor</code> element has no attributes.</para>
    </section>

    <section>
      <title>Application Element</title>

      <para>A JAR file can contain multiple application activators. The
      <code>application</code> element can therefore be repeated one or more
      times in the descriptor element.</para>

      <para>The <code>application</code> element has the following
      attribute:</para>

      <itemizedlist>
        <listitem>
          <para><code>class</code> - The <code>class</code> attribute of the
          <code>application</code> element must contain the fully qualified
          name of the application's activator.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Reference Element</title>

      <para>A <code>reference</code> element represents the applications use
      of a particular service. All services that an application uses must be
      declared in a <code>reference</code> element.</para>

      <para>A reference element has the following attributes:</para>

      <itemizedlist>
        <listitem>
          <para><code>name</code> - A <code>reference</code> element is
          identified by a name. This name can be used in the
          <code>locateService</code> or <code>locateService</code>, see <xref
          linkend="i1608489"/>. This name must be unique within an application
          element.</para>
        </listitem>

        <listitem>
          <para><code>interface</code> - The fully qualified name of the
          interface or class that defines the selected service.</para>
        </listitem>

        <listitem>
          <para><code>policy</code> - The choice of action when a bound
          services becomes unregistered while an application instance is
          running. It can have the following values:</para>

          <itemizedlist>
            <listitem>
              <para><code>static</code> - If a bound service becomes
              unregistered, the application instance must be stopped but the
              corresponding Application Descriptor is still launchable.</para>
            </listitem>

            <listitem>
              <para><code>dynamic</code> - If a bound service becomes
              unregistered, the application can continue to run if the
              mandatory reference can still be satisfied by another
              service.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><code>cardinality</code> - Defines the optionality of the
          reference. If it starts with a 0, an application can handle that the
          reference selects no service. That is, <code>locateService</code>
          method can return a <code>null</code>. If it starts with 1, the
          reference is mandatory and at least one service must be available
          before an application instance can be launched. The cardinality can
          have one of the following values:</para>

          <itemizedlist>
            <listitem>
              <para><code>0..1</code> or <code>0..n</code> - Optional
              reference</para>
            </listitem>

            <listitem>
              <para><code>1..1</code> or <code>1..n</code> - Mandatory
              reference</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><code>target</code> - The optional target attribute of the
          element can be used to further narrow which services are acceptable
          for the application by providing an OSGi filter on the properties of
          the services.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Example XML</title>

      <para>The following example is an application declaration for a MIDlet
      application that depends on the OSGi Log Service and another
      service:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;descriptor xmlns="http://www.osgi.org/xmlns/app/v1.1.0"&gt;
  &lt;application class="com.acme.apps.SampleMidlet"&gt;
    &lt;reference name="log" interface="org.osgi.service.log"/&gt; 
    &lt;reference name="foo"   
      interface="com.acme.service.FooService" 
      policy="dynamic" 
      cardinality="0..n" /&gt; 
  &lt;/application&gt;
&lt;/descriptor&gt;</programlisting>

      <para>A similar example for an imaginary Xlet, with different
      dependencies:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;descriptor xmlns="http://www.osgi.org/xmlns/app/v1.1.0"&gt;
  &lt;application class="com.acme.apps.SampleXlet"&gt;
    &lt;reference name="log" interface="org.osgi.service.log"/&gt; 
    &lt;reference name="bar" 
          interface="com.acme.service.BarService"
          policy="static" cardinality="1..n" /&gt; 
  &lt;/application&gt;
&lt;/descriptor&gt;</programlisting>
    </section>
  </section>

  <section xml:id="i1609213">
    <title>Component Description Schema</title>

    <para>This XML Schema defines the component description grammar.</para>

    <programlisting role="pgwide"><xi:include encoding="utf-8"
        href="../../generated/xmlns/app/v1.1.0/app.xsd" parse="text"/></programlisting>
  </section>

  <section>
    <title>Security</title>

    <section>
      <title>Application Context Access</title>

      <para>The <code>getApplicationContext</code> method provides access to
      the Application Context of a given application activator. The
      application activator is therefore a capability; any party that has
      access to this object can potentially get its related Application
      Context and use it in intended ways.</para>

      <para>A common pattern in small applications is to (ab)use the
      application activator class for all tasks, among them as service object.
      However, registering the application activator as a service will allow
      any party that can use that service to use it as the parameter to the
      <code>getApplicationContext</code> method.</para>

      <para>The Application Context must therefore be protected to not allow
      the registration of the application activator.</para>
    </section>

    <section>
      <title>Signing</title>

      <para>Application models can include the definition of a security model.
      For example, MIDP 2 defines a security model different from the standard
      Java 2 security model. If the foreign application model defines a
      security model different from Java 2 security, then it is the
      responsibility of the application container to implement this model and
      enforce it.</para>

      <para>OSGi services are protected by Java 2 permissions. Applications
      wishing to use such services must have the appropriate permissions for
      those services.</para>

      <para>Java 2 permissions are assigned during class loading based on the
      location of the code, the JAR signatures, and possibly based on other
      conditions, when using the Conditional Permission framework.</para>

      <para>Signing is a very common technique to handle the granting of
      permissions. It requires that the JAR be signed according to the JAR
      Signing model. Therefore, OSGi-aware application packages should be
      signed by JAR signing. However, some foreign application models have
      alternative signing models in place. However, it is unlikely that this
      conflicts because JAR signing uses well defined separate files and
      manifest headers. If the foreign application model changes the JAR file
      outside the META-INF directory, then the signing according to the
      foreign application model must be performed before the standard JAR
      signing.</para>

      <para>For example, in the case of MIDP signing and both models are used,
      the JAR signature should be put to the file first as it modifies the
      content of the file, and MIDP signing should be applied
      afterwards.</para>
    </section>

    <section>
      <title>Permission Management</title>

      <para>Applications that use OSGi services must have the corresponding
      Java 2 permissions granted. In order to simplify the policy management,
      and ensure that the overall device policy is consistent, application
      containers should not define separate policy management for each
      application model; rather they should use the existing OSGi policy
      management and express the complete security policy by the means of Java
      2 permissions with the Conditional Permission Admin service. This way,
      policy administrator can define the boundaries of the sandbox available
      for a particular application based on its location, signer or other
      condition. The application container is responsible for enforcing both
      the foreign application specific security mechanisms as well as the OSGi
      granted permissions.</para>

      <para>Applications can package permissions as described in the
      Conditional Permission Admin. These permissions will restrict the
      foreign application's permissions to maximally the permissions in this
      file scoped by the signer's permissions.</para>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.application.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
