<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->

<chapter label="152"
         revision="$Id$"
         version="5.0" xml:id="service.cdi"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>CDI Integration Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.cdi-version"
    linkend="org.osgi.service.cdi"/></releaseinfo>
  </info>

  <section xml:id="service.cdi-intro">
    <title>Introduction</title>

    <para><emphasis>Contexts and Dependency Injection</emphasis> (<xref
    linkend="service.cdi-bib.cdi"/>) is the standard <emphasis>dependency
    injection</emphasis> technology for Java. <xref
    linkend="service.cdi-bib.cdi20"/> is the current version.</para>

    <para>The CDI specification is a composition of the following high level
    features:</para>

    <blockquote>
      <attribution>CDI</attribution>

      <itemizedlist>
        <listitem>
          <para>A well-defined life cycle for stateful objects bound to life
          cycle contexts, where the set of contexts is extensible</para>
        </listitem>

        <listitem>
          <para>A sophisticated, typesafe dependency injection mechanism,
          including the ability to select dependencies at either development
          or deployment time, without verbose configuration</para>
        </listitem>

        <listitem>
          <para>Support for Java EE modularity and the Java EE component
          architecture - the modular structure of a Java EE application is
          taken into account when resolving dependencies between Java EE
          components</para>
        </listitem>

        <listitem>
          <para>Integration with the Unified Expression Language (EL),
          allowing any contextual object to be used directly within a JSF or
          JSP page</para>
        </listitem>

        <listitem>
          <para>The ability to decorate injected objects</para>
        </listitem>

        <listitem>
          <para>The ability to associate interceptors to objects via typesafe
          interceptor bindings</para>
        </listitem>

        <listitem>
          <para>An event notification model</para>
        </listitem>

        <listitem>
          <para>A web conversation context in addition to the three standard
          web contexts defined by the Java Servlets specification</para>
        </listitem>

        <listitem>
          <para>A Service Provider Interface (SPI) allowing portable
          extensions to integrate cleanly with the container</para>
        </listitem>
      </itemizedlist>
    </blockquote>

    <para>This specification describes how OSGi is integrated into the CDI
    programming model and the interaction with these features.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Dependency Injection</emphasis> - Provide an
          advanced dependency injection framework for bundles that can create
          and wire objects and services together into an application.</para>
        </listitem>

        <listitem>
          <para><emphasis>Extender Model</emphasis> - Enable the configuration
          of components inside a bundle based on configuration data provided
          by the bundle developer. The life cycle of these components is
          controlled by the extender based on the extended bundle's
          state.</para>
        </listitem>

        <listitem>
          <para><emphasis>Unencumbered</emphasis> - Does not require any
          special bundle activator or other code to be written inside the
          bundle in order to have components instantiated and
          configured.</para>
        </listitem>

        <listitem>
          <para><emphasis>Services</emphasis> - Enable the usage of OSGi
          services as injected dependencies.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration</emphasis> - Enable the usage of
          Configuration Admin configuration objects as injected
          dependencies.</para>
        </listitem>

        <listitem>
          <para><emphasis>Dependencies</emphasis> - Allow components to depend
          on configuration objects and services and to register services, with
          the full breadth of the OSGi capabilities.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reactive</emphasis> - It must be possible to react
          to changes in the external dependencies with different
          policies.</para>
        </listitem>

        <listitem>
          <para><emphasis>Introspection</emphasis> - It must be possible to
          introspect the service components.</para>
        </listitem>

        <listitem>
          <para><emphasis>Business Logic</emphasis> - A focus on writing
          business logic by using the features of CDI and reusable
          functionality provided by extensions.</para>
        </listitem>

        <listitem>
          <para><emphasis>Familiarity</emphasis> - Familiar to Java developers
          knowledgeable in CDI.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="strong">CDI Entities</emphasis></para>

          <itemizedlist>
            <listitem>
              <para><emphasis>CDI</emphasis> - Contexts and Dependency
              Injection 2.0.</para>
            </listitem>

            <listitem>
              <para><emphasis>Bean</emphasis> - A Java class that satisfies
              the criteria of a bean as defined in CDI and which provides
              contextual objects that define application state and/or
              logic.</para>
            </listitem>

            <listitem>
              <para><emphasis>Producer</emphasis> - A producer method or field
              acts as a source of objects to be injected. It is an alternative
              to beans.</para>
            </listitem>

            <listitem>
              <para><emphasis>Contextual Instance</emphasis> - The object
              instances produced by beans or producers within a given
              <emphasis>context</emphasis>.</para>
            </listitem>

            <listitem>
              <para><emphasis>Context</emphasis> - A Service Provider
              Interface (SPI) defining the life cycle for a set of contextual
              instances. The context also determines which contextual
              instances of beans are visible to the contextual instances of
              other beans.</para>
            </listitem>

            <listitem>
              <para><emphasis>Scope</emphasis> - A (CDI) scope identifies a
              particular <emphasis>Context</emphasis> implementation. All
              beans have a scope and are therefore bound to a particular
              context implementation. A scope is represented by an annotation
              type. Any contextual instances produced from the bean exist
              within a context identified by the scope.</para>
            </listitem>

            <listitem>
              <para><emphasis>Injection Point</emphasis> - A location in a
              contextual instance or producer which is the target for
              injection for a contextual instance.</para>
            </listitem>

            <listitem>
              <para><emphasis>Qualifier</emphasis> - An annotation used to
              define a quality used for matching. Qualifiers are applied to
              injection points, beans, producers (among other things). CDI
              finds beans matching an injection point's type then makes sure
              the qualifiers of the bean match all those on the injection
              point.</para>
            </listitem>

            <listitem>
              <para><emphasis>Stereotype</emphasis> - An annotation
              meta-annotated with
              <code>javax.enterprise.inject.Stereotype</code> used to define a
              recurring role by aggregating a CDI scope and various other
              aspects into a reusable unit.</para>
            </listitem>

            <listitem>
              <para><emphasis>Decorators and Interceptors</emphasis> - Actors
              that intercept certain method invocations of contextual
              instances.</para>
            </listitem>

            <listitem>
              <para><emphasis>Portable Extension</emphasis> - A portable
              extension uses the CDI SPI to provide additional and reusable
              functionality to a set of CDI beans.</para>
            </listitem>

            <listitem>
              <para><emphasis>CDI Container</emphasis> - For each CDI bundle,
              required portable extensions are loaded , metadata and bean
              classes are analyzed to create a bean injection graph. This
              process is encapsulated by a CDI container.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="strong">Entities defined by this
          specification</emphasis></para>

          <itemizedlist>
            <listitem>
              <para><emphasis>CDI Bundle</emphasis> - An OSGi bundle
              containing CDI beans.</para>
            </listitem>

            <listitem>
              <para><emphasis>CDI Extension Bundle</emphasis> - A bundle
              providing one or more portable extensions.</para>
            </listitem>

            <listitem>
              <para><emphasis>CDI Component Runtime (CCR)</emphasis> - The
              actor that manages the CDI containers and their life cycle and
              allows introspection of CDI containers.</para>
            </listitem>

            <listitem>
              <para><emphasis>Configuration Object</emphasis> - Configuration
              Admin object which implements the <code>Configuration</code>
              interface and contains configuration data.</para>
            </listitem>

            <listitem>
              <para><emphasis>Factory Configuration Object</emphasis> - A
              Configuration Object having a factory PID whose instances for
              which there can be 0 or N are under the control of Configuration
              Admin, all sharing the same factory PID.</para>
            </listitem>

            <listitem>
              <para><emphasis>Single Configuration Object</emphasis> - A
              configuration object that has no factory PID and remains
              singularly independent from all other configuration
              objects.</para>
            </listitem>

            <listitem>
              <para><emphasis>Component</emphasis> - A set of beans whose life
              cycle is derived from it's dependencies.</para>
            </listitem>

            <listitem>
              <para><emphasis>Dependency</emphasis> - A configuration object
              or service upon which beans depend. These dependencies are
              dynamic in that their life cycle is independently controlled by
              other actors within the OSGi Framework and CCR must properly
              accommodate for this.</para>
            </listitem>

            <listitem>
              <para><emphasis>Configuration Template</emphasis> - The static
              metadata describing a configuration object dependency.</para>
            </listitem>

            <listitem>
              <para><emphasis>Reference Template</emphasis> - The static
              metadata describing a reference dependency.</para>
            </listitem>

            <listitem>
              <para><emphasis>Component Template</emphasis> - The static
              definition of a <emphasis>component</emphasis> combining all the
              metadata defined by its beans, and its dependencies. The
              component template does not change between restarts of the CDI
              bundle.</para>
            </listitem>

            <listitem>
              <para><emphasis>Component Scope</emphasis> - A (CDI) scope
              defined by this specification that represents the granular life
              cycle associated with a set of dependencies.</para>
            </listitem>

            <listitem>
              <para><emphasis>Component Instance</emphasis> - A runtime
              instance of the component template which observes and reacts to
              the state of the OSGi Framework based on the metadata of the
              component template.</para>
            </listitem>

            <listitem>
              <para><emphasis>Container Component</emphasis> - A component
              encompassing all beans in the CDI container <emphasis
              role="strong">not</emphasis> in the component scope. The
              container component results in a single component
              instance.</para>
            </listitem>

            <listitem>
              <para><emphasis>Single Component</emphasis> - A component that
              encompasses beans that have the <emphasis>Component
              Scope</emphasis>, whose dependencies may include single
              configuration objects and services. A single component results
              in a single component instance.</para>
            </listitem>

            <listitem>
              <para><emphasis>Factory Component</emphasis> - A component that
              encompassed beans having the <emphasis>Component
              Scope</emphasis>, that are driven by factory configuration
              objects and whose dependencies may include single configuration
              objects and services. A factory component results in any number
              of component instances, one for every factory configuration
              object.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Synopsis</title>

      <para>The CDI Extender reads CDI metadata from started CDI bundles.
      These metadata are in the form of XML documents, annotation types and
      requirements which define the set of <emphasis>beans</emphasis>
      available to the CDI container. Beans express dependencies on OSGi
      configuration objects and services and are assembled into components.
      The life cycle of a component is driven from the dependencies of its
      beans.</para>

      <para>There are three types of components:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Container Component</emphasis> - Consists of beans
          not in the <emphasis>component scope</emphasis>. There is exactly
          one container component per CDI bundle. It's life cycle is
          synonymous with the CDI container. The container component must be
          completely satisfied before other component types can be satisfied.
          The container component may provide multiple services. Altering the
          state of the container component's static dependencies results in
          the entire CDI container, and all other component types being
          destroyed and recreated.</para>
        </listitem>

        <listitem>
          <para><emphasis>Single Component</emphasis> - A <emphasis>Single
          Component</emphasis> begins with a bean annotated by the <link
          linkend="org.osgi.service.cdi.annotations.SingleComponent">@SingleComponent</link>
          annotation and is further enhanced by other beans in it's injection
          graph that are component scoped. A single component may provide
          immediate functionality or a service resulting in an immediate
          instance or a single service registration. Unlike the container
          component, single components may be created, destroyed and react to
          changes in the state of it's dependencies in isolation, without
          affecting the entire CDI container. A single component's life cycle
          is driven first by the container component which must be satisfied
          and second by it's dependencies.</para>
        </listitem>

        <listitem>
          <para><emphasis>Factory Component</emphasis> - A <emphasis>Factory
          Component</emphasis> begins with a bean annotated by the <link
          linkend="org.osgi.service.cdi.annotations.FactoryComponent">@FactoryComponent</link>
          annotation and is further enhanced by other beans in it's injection
          graph that are component scoped. A factory component may provide
          immediate functionality or a service, resulting in one immediate
          instance or service registration. Unlike the container component,
          factory components may be created, destroyed and react to changes in
          the state of it's dependencies in isolation, without affecting the
          entire CDI container. A factory component's life cycle is driven
          first by the container component which must be satisfied, secondly
          by factory configuration which result in one component instance per
          factory configuration object, and finally by it's
          dependencies.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>CCR Model</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentwidth="370px"
                       fileref="component-model.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <!-- <section>
		<title>Readers</title>

		<itemizedlist>
			<listitem>
				<para><emphasis>Architects</emphasis>
				</para>
			</listitem>

			<listitem>
				<para><emphasis>Service Programmers</emphasis>
				</para>
			</listitem>

			<listitem>
				<para><emphasis>Deployers</emphasis>
				</para>
			</listitem>
		</itemizedlist>
	</section> -->
  </section>

  <section xml:id="service.cdi-components">
    <title>Components</title>

    <para>A traditional CDI application is composed of beans that have a
    well-defined life cycle based on the CDI scope they declare. This
    specification defines a component model in terms of beans and scopes as
    they are defined in the CDI specification in order to act as a good CDI
    citizen.</para>

    <para><emphasis>Components</emphasis> are defined by this specification to
    have the following characteristics:</para>

    <itemizedlist>
      <listitem>
        <para>Components exist within a CDI bundle.</para>
      </listitem>

      <listitem>
        <para>Components are defined by collections of beans (referred to as
        component beans).</para>
      </listitem>

      <listitem>
        <para>Components may have dependencies on configuration objects and
        services. These dependencies are described using annotations defined
        by this specification.</para>
      </listitem>

      <listitem>
        <para>Components have properties, referred to as <emphasis>component
        properties</emphasis>. Some of these are defined by this specification
        and must be present. Others are aggregated from various configuration
        sources as defined in <xref
        linkend="service.cdi-component.properties"/>.</para>
      </listitem>

      <listitem>
        <para>Components have unique names within the CDI bundle.</para>
      </listitem>

      <listitem>
        <para>Components produce one or more <emphasis>component
        instances</emphasis>. Component instances are the runtime
        representation of the component. They independently react to the state
        of the dependencies declared by their component beans.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="service.cdi-component.scope">
    <title>Component Scope</title>

    <para>This specification uses the facilities of CDI <xref
    linkend="service.cdi-bib.cdi.scopes.and.contexts"/> to define a life cycle
    for beans specifically for supporting a relationship with OSGi
    dependencies.</para>

    <para>Associated with every CDI scope is an object implementing
    <code>javax.enterprise.context.spi.Context</code> or
    <code>javax.enterprise.context.spi.AlterableContext</code>. The life cycle
    and visibility rules for said scope are defined by this implementation
    which collaborates with the CDI container to create or destroy contextual
    instances. Contextual instances associated with the scope exist within a
    <emphasis>context</emphasis> which acts as a cache, creating new or
    returning existing contextual instances as needed. These contexts are
    managed by CCR in conjunction with the CDI container.</para>

    <figure>
      <title>CDI Scope Model</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentwidth="250px"
                     fileref="cdi-scope-model.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The <emphasis>component scope</emphasis> is a <xref
    linkend="service.cdi-bib.cdi.pseudoscope"/> identified by the <code><link
    linkend="org.osgi.service.cdi.annotations.ComponentScoped">@ComponentScoped</link></code>
    annotation. The <emphasis>component scope</emphasis> allows component
    instances to use component beans to create or destroy contextual instances
    when dependencies are satisfied or unsatisfied without interfering with
    the life cycle of other component instances (including the <link
    linkend="service.cdi-container.component">container
    component</link>).</para>

    <para>The context implementation must be registered with the CDI container
    using the CDI SPI. For example:</para>

    <programlisting>void afterBeanDiscovery(
	@Observes javax.enterprise.inject.spi.AfterBeanDiscovery abd) {

	Context ctx = ...
	abd.addContext(ctx);
}</programlisting>

    <para>The <code>ComponentScoped</code> annotation must be registered with
    the CDI container using the CDI SPI. For example:</para>

    <programlisting>void beforeBeanDiscovery(
	@Observes javax.enterprise.inject.spi.BeforeBeanDiscovery bbd) {

	bbd.addScope(ComponentScoped.class, false, false);
}</programlisting>

    <section xml:id="service.cdi-lifecycle.context.instances">
      <title>Contexts</title>

      <para>The creation and destruction of the component scope's contexts
      must adhere to the following process:</para>

      <itemizedlist>
        <listitem xml:id="service.cdi-component.context.creation">
          <para>The following steps are taken to create a
          <emphasis>context</emphasis>:</para>

          <orderedlist>
            <listitem>
              <para><emphasis>the context is made active</emphasis> - The
              method
              <code>javax.enterprise.context.spi.Context.isActive()</code>
              must return <code>true</code>.</para>
            </listitem>

            <listitem>
              <para><emphasis>contextual instances are created and
              injected</emphasis> - Contextual instances can be retrieved by
              calling
              <code>javax.enterprise.context.spi.Context.get(...)</code>.</para>
            </listitem>

            <listitem>
              <para><emphasis>the @Initialized event is fired</emphasis> - On
              success of step 2, the CDI event
              <code>@Initialized(ComponentScoped.class)</code> is fired
              synchronously. See <xref
              linkend="service.cdi-component.context.events"/>.</para>

              <para>When the component is a <emphasis>single
              component</emphasis>, the event payload is the contextual
              instance of the bean marked
              <code>@SingleComponent</code>.</para>

              <para>When the component is a <emphasis>factory
              component</emphasis> the event payload is the contextual
              instance of the bean marked
              <code>@FactoryComponent</code>.</para>

              <para>Any qualifiers defined on the bean of the contextual
              instance must be attached to the event.</para>

              <para>On failure of step 2, errors are logged and made available
              in <xref
              linkend="org.osgi.service.cdi.runtime.dto.ActivationDTO.errors"/>.</para>
            </listitem>

            <listitem>
              <para><emphasis>the context is deactivated</emphasis> - The
              method
              <code>javax.enterprise.context.spi.Context.isActive()</code>
              must return <code>false</code>.</para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem xml:id="service.cdi-component.context.destruction">
          <para>The following steps are taken to destroy a
          <emphasis>context</emphasis>:</para>

          <orderedlist>
            <listitem>
              <para><emphasis>the context is made active</emphasis> - The
              method
              <code>javax.enterprise.context.spi.Context.isActive()</code>
              must return <code>true</code>.</para>
            </listitem>

            <listitem>
              <para><emphasis>the @BeforeDestroy is fired</emphasis> - The CDI
              event <code>@BeforeDestroy(ComponentScoped.class)</code> is
              fired synchronously. See <xref
              linkend="service.cdi-component.context.events"/>.</para>

              <para>When the component is a <emphasis>single
              component</emphasis> the event payload is the contextual
              instance of the bean marked
              <code>@SingleComponent</code>.</para>

              <para>When the component is a <emphasis>factory
              component</emphasis> the event payload is the contextual
              instance of the bean marked
              <code>@FactoryComponent</code>.</para>

              <para>Any qualifiers defined on the bean of the contextual
              instance must be attached to the event.</para>
            </listitem>

            <listitem>
              <para><emphasis>contextual instances are destroyed</emphasis> -
              Any exceptions are logged.</para>
            </listitem>

            <listitem>
              <para><emphasis>the context is deactivated</emphasis> - The
              method
              <code>javax.enterprise.context.spi.Context.isActive()</code>
              must return <code>false</code>.</para>
            </listitem>

            <listitem>
              <para><emphasis>the context is destroyed</emphasis></para>
            </listitem>

            <listitem>
              <para><emphasis>the @Destroyed event is fired</emphasis> - The
              CDI event <code>@Destroyed(ComponentScoped.class)</code> is
              fired synchronously. See <xref
              linkend="service.cdi-component.context.events"/>.</para>

              <para>When the component is a <emphasis>single
              component</emphasis> the event payload is the contextual
              instance of the bean marked
              <code>@SingleComponent</code>.</para>

              <para>When the component is a <emphasis>factory
              component</emphasis> the event payload is the contextual
              instance of the bean marked
              <code>@FactoryComponent</code>.</para>

              <para>Any qualifiers defined on the bean of the contextual
              instance must be attached to the event.</para>

              <para><emphasis role="strong">Note</emphasis> that the object
              may not be <emphasis>usable</emphasis> during this event because
              the context under which it was created is already
              destroyed.</para>
            </listitem>
          </orderedlist>
        </listitem>
      </itemizedlist>

      <table xml:id="service.cdi-component.context.events">
        <title>Component Context Events</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="3*"/>

          <colspec colnum="2" colwidth="2*"/>

          <thead>
            <row>
              <entry>Event Qualifier</entry>

              <entry>Condition</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>@Initialized(ComponentScoped.class)</code></entry>

              <entry>when a context is initialized and ready for use</entry>
            </row>

            <row>
              <entry><code>@BeforeDestroy(ComponentScoped.class)</code></entry>

              <entry>when a context is about to be destroyed, but before
              actual destruction</entry>
            </row>

            <row>
              <entry><code>@Destroyed(ComponentScoped.class)</code></entry>

              <entry>after a context is destroyed</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section>
        <title>When Contexts are Created</title>

        <para>A <emphasis>context</emphasis> is created under each of the
        following conditions:</para>

        <orderedlist>
          <listitem xml:id="service.cdi-context.instance.immediate">
            <para><emphasis>Immediate instance</emphasis> - A component
            instance that does not provide a service requires the immediate
            <link linkend="service.cdi-component.context.creation">creation of
            a context</link>.</para>
          </listitem>

          <listitem xml:id="service.cdi-context.instance.singleton.service.single.component">
            <para><emphasis>Singleton scoped service from a
            <code>@SingleComponent</code></emphasis> - A single component
            instance that provides a singleton scoped service requires the
            immediate <link
            linkend="service.cdi-component.context.creation">creation of a
            context</link>.</para>

            <para>The service object is the contextual instance of the bean
            marked <code>@SingleComponent</code> obtained from the
            context.</para>
          </listitem>

          <listitem xml:id="service.cdi-context.instance.singleton.service.factory.component">
            <para><emphasis>Singleton scoped service from a
            <code>@FactoryComponent</code></emphasis> - A factory component
            instance that provides a singleton scoped service requires the
            immediate <link
            linkend="service.cdi-component.context.creation">creation of a
            context</link> for each factory configuration object.</para>

            <para>The service object is the contextual instance of the bean
            marked <code>@FactoryComponent</code> obtained from the
            context.</para>
          </listitem>

          <listitem xml:id="service.cdi-context.instance.bundle.service">
            <para><emphasis>Bundle scoped service</emphasis> - A component
            instance that provides a bundle scope service requires the <link
            linkend="service.cdi-component.context.creation">creation of a
            context</link> when the <code>ServiceFactory.getService()</code>
            method is called.</para>

            <para>If the component is a <emphasis>single component</emphasis>,
            the service object is the contextual instance of the bean marked
            <code>@SingleComponent</code> obtained from the context.</para>

            <para>If the component is a <emphasis>factory
            component</emphasis>, the service object is the contextual
            instance of the bean marked <code>@FactoryComponent</code>
            obtained from the context.</para>

            <para>The context is released and destroyed when the
            <code>ServiceFactory.ungetService()</code> method is
            called.</para>
          </listitem>

          <listitem xml:id="service.cdi-context.instance.prototype.service">
            <para><emphasis>Prototyped scoped service</emphasis> - A component
            instance that provides a prototype scope service requires the
            <link linkend="service.cdi-component.context.creation">creation of
            a context</link> when the
            <code>PrototypeServiceFactory.getService()</code> method is
            called.</para>

            <para>If the component is a <emphasis>single component</emphasis>,
            the service object is the contextual instance of the bean marked
            <code>@SingleComponent</code> obtained from the context.</para>

            <para>If the component is a <emphasis>factory
            component</emphasis>, the service object is the contextual
            instance of the bean marked <code>@FactoryComponent</code>
            obtained from the context.</para>

            <para>The context is released and destroyed when the
            <code>PrototypeServiceFactory.ungetService()</code> method is
            called.</para>
          </listitem>
        </orderedlist>

        <para>In addition to the cases specified above, all contexts produced
        by an immediate component or by the service registration are released
        and destroyed when the component instance is no longer satisfied or
        when the CDI container is destroyed.</para>
      </section>
    </section>
  </section>

  <section xml:id="service.cdi-container.component">
    <title>Container Component</title>

    <para>The <emphasis>container component</emphasis> is composed of all the
    beans available to the CDI container which are <emphasis
    role="strong">not</emphasis> <xref
    linkend="org.osgi.service.cdi.annotations.ComponentScoped"/>.</para>

    <para>The container component draws it's name from the CDI container id.
    By default, the CDI container id is equal to the
    <code>Bundle-SymbolicName</code> of the CDI bundle prefixed by
    '<code>osgi.cdi.</code>'.</para>

    <programlisting>containerId ::= 'osgi.cdi.' bsn
bsn         ::= &lt; Bundle-SymbolicName &gt;</programlisting>

    <para>The container id can be specified using the <link
    linkend="org.osgi.service.cdi.CDIConstants.CDI_CONTAINER_ID">container.id</link>
    attribute of the <link linkend="service.cdi-capabilities">CDI extender
    requirement</link> in the bundle manifest. The value must follow the
    <code>Bundle-SymbolicName</code> syntax. For example:</para>

    <programlisting>Require-Capability:
	osgi.extender;
		filter:=”(&amp;(osgi.extender=osgi.cdi)(version&gt;=<xref
        endterm="org.osgi.service.cdi-version.number"
        linkend="org.osgi.service.cdi"/>)(!(version&gt;=2.0.0)))”;
		container.id="my.id"</programlisting>

    <section xml:id="service.cdi-container.component.configuration">
      <title>Container Component Configuration</title>

      <para>The container component must be configurable using it's container
      id as a PID; referred to as the <emphasis>container
      PID</emphasis>.</para>

      <programlisting>containerPID ::= &lt; container id &gt;</programlisting>

      <para>Given a bundle with <code>Bundle-SymbolicName</code> equal to
      <code>com.acme.bar</code> which does not set the
      <code>container.id</code> attribute in the requirement, the container id
      would be:</para>

      <programlisting>osgi.cdi.com.acme.bar</programlisting>

      <para>From the requirement example above where the container id is set
      to <code>my.id</code>, the container PID would be:</para>

      <programlisting>my.id</programlisting>

      <para>The configuration object used to satisfy the container PID must be
      a single configuration object. However the configuration policy for this
      configuration object is <emphasis>optional</emphasis> and is not
      required to satisfy the container component.</para>
    </section>

    <section>
      <title>Container Component Life Cycle</title>

      <para>The container component is largely synonymous with the CDI
      container. When the dependencies of the container component are
      satisfied the CDI container completes it's initialization process and
      subsequently is fully functional. When the dependencies of the container
      component are no longer satisfied the CDI container is shutdown and all
      contextual instances are destroyed.</para>

      <para>A container component with no beans would be immediately satisfied
      since it specifies no dependencies.</para>
    </section>
  </section>

  <section xml:id="service.cdi-standard.definitions">
    <title>Standard Definitions</title>

    <section>
      <title>Annotation Inheritance</title>

      <para>Annotations are not inherited unless meta-annotated by
      <code>@java.lang.annotation.Inherited</code>.</para>
    </section>

    <section xml:id="service.cdi-example.classes">
      <title>Code Examples</title>

      <para>This specification provides several source code examples. In order
      to avoid repetition the following Java types are defined and re-used
      throughout:</para>

      <programlisting>interface Dog {}

interface Hound extends Dog {}

abstract class BassetHound implements Hound {}

class Spot extends BassetHound {}

class Buddy implements Hound {}</programlisting>
    </section>
  </section>

  <section xml:id="service.cdi-single.component">
    <title>Single Component</title>

    <para>A <emphasis>Single Component</emphasis> begins with and is rooted by
    a bean annotated by the <link
    linkend="org.osgi.service.cdi.annotations.SingleComponent">@SingleComponent</link>
    annotation. It is further enhanced by beans in it's injection graph that
    are <code>@ComponentScoped</code> which are discovered according to CDI's
    rules for <xref linkend="service.cdi-bib.cdi.typesafe.resolution"/>
    starting from the <code>@SingleComponent</code> bean and recursing through
    all injection points until all injection points are resolved.</para>

    <para>Resolution results which contain non-root beans marked with
    <code>@SingleComponent</code> or <code>@FactoryComponent</code> result in
    a definition error.</para>

    <para>Any failed resolutions result in a definition error.</para>

    <para>Applying any scope besides <code>@ComponentScoped</code> to a bean
    marked with <code>@SingleComponent</code> results in a definition
    error.</para>

    <para>Any <code>@ComponentProperties</code> or <code>@Reference</code>
    injection point that is resolved by beans which are not provided by CCR
    results in a definition error.</para>

    <para>A single component has an implicit dependency on the container
    component. Therefore it may never be satisfied until the container
    component is satisfied.</para>

    <section>
      <title>Single Component Naming</title>

      <para>The <code>@SingleComponent</code> annotation is a
      <emphasis>stereotype</emphasis> which carries the
      <code>@javax.inject.Named</code> meta-annotation. This indicates that
      the default component name is: <blockquote>
          <attribution>CDI</attribution>

          <para><quote>the unqualified class name of the bean class, after
          converting the first character to lower case</quote></para>
        </blockquote> For example:</para>

      <programlisting>// component.name = fido
@SingleComponent
class Fido {}</programlisting>

      <para>However, the name may be specified by adding
      <code>@javax.inject.Named</code> directly to the bean and specifying a
      value whose syntax follows <code>cname</code> defined by the <xref
      linkend="service.cdi-bib.general.syntax.definitions"/>.</para>

      <programlisting>// component.name = Champ
@SingleComponent
@Named("Champ")
class Fido {}</programlisting>
    </section>

    <section>
      <title>Single Component Configuration</title>

      <para>By default a single component must be configurable by using it's
      component name, prefixed by the container PID and a period
      (<code>.</code>), as a configuration PID. This <emphasis>component
      PID</emphasis> will be represented throughout the remained of the
      specification by the symbol <emphasis role="strong">Φ</emphasis>
      (capital Phi).</para>

      <programlisting>Φ           ::= containerPID '.' compName
containerPID ::= &lt; container PID &gt;
compName     ::= &lt; component name &gt;</programlisting>

      <para>A single component may change or add additional PIDs on which it
      depends. When multiple PIDs are referenced the order is relevant and
      affects the aggregation of the configuration objects into a flattened
      dictionary of component properties. Later PIDs take precedence over
      earlier PIDs. Also, it must be possible to reposition the component PID
      within the order. The <xref
      linkend="org.osgi.service.cdi.annotations.PID"/> annotation is used to
      control both referenced PIDs and their order.</para>

      <para>The following is an example of a component that is configurable by
      it's component PID:</para>

      <programlisting>// component pids = [Φ]
@SingleComponent
class Fido {}</programlisting>

      <para>An example of a component replacing it's component PID with a
      specific PID:</para>

      <programlisting>// component pids = [com.acme.foo]
@SingleComponent
@PID("com.acme.foo")
class Fido {}</programlisting>

      <para>An example of multiple PIDs:</para>

      <programlisting>// component pids = [com.acme.foo, com.gamma.bar]
@SingleComponent
@PID("com.acme.foo")
@PID("com.gamma.bar")
class Fido {}</programlisting>

      <para>See <xref linkend="service.cdi-component.properties"/> for how
      multiple component PIDs are merged into component properties.</para>

      <para>Using <code>@PID</code> without arguments refers to the component
      PID:</para>

      <programlisting>// component pids = [Φ]
@SingleComponent
@PID
class Fido {}</programlisting>

      <para>This allows the component PID to be included anywhere in the
      order:</para>

      <programlisting>// component pids = [com.acme.foo, Φ, com.gamma.bar]
@SingleComponent
@PID("com.acme.foo")
@PID
@PID("com.gamma.bar")
class Fido {}</programlisting>

      <para>Each <code>@PID</code> annotation may specify a policy for the
      configuration object. The property <xref
      linkend="org.osgi.service.cdi.annotations.PID.policy--"/> is used to
      specify the value. The possible values are:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis><xref
          linkend="org.osgi.service.cdi.ConfigurationPolicy.OPTIONAL"/></emphasis>
          - A configuration object is not required. <emphasis>This is the
          default policy.</emphasis></para>
        </listitem>

        <listitem>
          <para><emphasis><xref
          linkend="org.osgi.service.cdi.ConfigurationPolicy.REQUIRED"/></emphasis>
          - A configuration object is required.</para>
        </listitem>
      </itemizedlist>

      <programlisting>// component pids = [com.acme.foo, Φ, com.gamma.bar]
@SingleComponent
@PID(value = "com.acme.foo", policy = Policy.REQUIRED)
@PID
@PID("com.gamma.bar")
class Fido {}</programlisting>

      <para>It is a definition error to refer to the same PID more than
      once.</para>

      <para>The configuration objects used to satisfy the single component's
      referenced PIDs must be single configuration objects.</para>
    </section>
  </section>

  <section xml:id="service.cdi-factory.component">
    <title>Factory Component</title>

    <para>A <emphasis>Factory Component</emphasis> begins with and is rooted
    by a bean annotated by the <link
    linkend="org.osgi.service.cdi.annotations.FactoryComponent">@FactoryComponent</link>
    annotation. It is further enhanced by beans in it's injection graph that
    are <code>@ComponentScoped</code> which are discovered according to CDI's
    rules for <xref linkend="service.cdi-bib.cdi.typesafe.resolution"/>
    starting from the <code>@FactoryComponent</code> bean and recursing
    through all injection points until all injection points are
    resolved.</para>

    <para>The <code>@FactoryComponent</code> annotation indicates that the
    component is bound to the life cycle of factory configuration objects
    associated with the factory PID specified in it's <xref
    linkend="org.osgi.service.cdi.annotations.FactoryComponent.value--"/>
    property (or it's default component factory PID). Each factory
    configuration object associated with this factory PID results in a new
    <emphasis>component instance</emphasis>. The component properties of the
    component instance are supplemented by the properties of the factory
    configuration object.</para>

    <para>Resolution results which contain a non-root bean marked with
    <code>@SingleComponent</code> or <code>@FactoryComponent</code> result in
    a definition error.</para>

    <para>Any failed resolutions result in a definition error.</para>

    <para>Applying any scope besides <code>@ComponentScoped</code> to a bean
    marked with <code>@FactoryComponent</code> results in a definition
    error.</para>

    <para>Any <code>@ComponentProperties</code> or <code>@Reference</code>
    injection point that is resolved by beans which are not provided by CCR
    results in a definition error.</para>

    <para>A factory component has an implicit dependency on the container
    component. Therefore it may never be satisfied until the container
    component is satisfied.</para>

    <section>
      <title>Factory Component Naming</title>

      <para>The <code>@FactoryComponent</code> annotation is a
      <emphasis>stereotype</emphasis> which carries the
      <code>@javax.inject.Named</code> meta-annotation. This indicates that
      the default component name is: <blockquote>
          <attribution>CDI</attribution>

          <para><quote>the unqualified class name of the bean class, after
          converting the first character to lower case</quote></para>
        </blockquote> For example:</para>

      <programlisting>// component.name = fido
@FactoryComponent
class Fido {}</programlisting>

      <para>However, the name may be specified by adding
      <code>@javax.inject.Named</code> directly to the bean and specifying a
      value whose syntax follows <code>cname</code> defined by the <xref
      linkend="service.cdi-bib.general.syntax.definitions"/>.</para>

      <programlisting>// component.name = Champ
@FactoryComponent
@Named("Champ")
class Fido {}</programlisting>
    </section>

    <section>
      <title>Factory Component Configuration</title>

      <para>By default a factory component must be configurable by using it's
      component name, prefixed by the container PID and a period
      (<code>.</code>), as a factory PID. This <emphasis>component factory
      PID</emphasis> will be represented throughout the remained of the
      specification by the symbol <emphasis role="strong">Σ</emphasis>
      (capital Sigma).</para>

      <programlisting>Σ            ::= containerPID '.' compName
containerPID ::= &lt; container PID &gt;
compName     ::= &lt; component name &gt;</programlisting>

      <para>An example of a factory component that is configurable by it's
      component factory PID:</para>

      <programlisting>// component pids = [Σ]
@FactoryComponent
class Fido {}</programlisting>

      <para>A factory component may specify a factory PID using it's <xref
      linkend="org.osgi.service.cdi.annotations.FactoryComponent.value--"/>
      property. The value must conform to the syntax defined for the
      <code>Bundle-SymbolicName</code> header.</para>

      <para>An example of a factory component specifying a factory PID:</para>

      <programlisting>// component pids = [com.acme.foo-####]
@FactoryComponent("com.acme.foo")
class Fido {}</programlisting>

      <para>A factory component may change or add additional PIDs on which it
      depends. When multiple PIDs are referenced the order is relevant and
      affects the aggregation of the configuration objects into a flattened
      dictionary of component properties. Later PIDs take precedence over
      earlier PIDs. The <xref linkend="org.osgi.service.cdi.annotations.PID"/>
      annotation is used to control both referenced PIDs and their
      order.</para>

      <para>An example of multiple PIDs:</para>

      <programlisting>// component pids = [com.gamma.bar, com.acme.foo-####]
@FactoryComponent("com.acme.foo")
@PID("com.gamma.bar")
class Fido {}</programlisting>

      <para>Each <code>@PID</code> annotation may specify a policy for the
      configuration dependency. The property <xref
      linkend="org.osgi.service.cdi.annotations.PID.policy--"/> is used to
      specify the value. The possible values are:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis><xref
          linkend="org.osgi.service.cdi.ConfigurationPolicy.OPTIONAL"/></emphasis>
          - A configuration object is not required. <emphasis>This is the
          default policy.</emphasis></para>
        </listitem>

        <listitem>
          <para><emphasis><xref
          linkend="org.osgi.service.cdi.ConfigurationPolicy.REQUIRED"/></emphasis>
          - A configuration object is required.</para>
        </listitem>
      </itemizedlist>

      <programlisting>// component pids [com.acme.foo, com.gamma.bar, Σ]
@FactoryComponent
@PID(value = "com.acme.foo", policy = Policy.REQUIRED)
@PID("com.gamma.bar")
class Fido {}</programlisting>

      <para>See <xref linkend="service.cdi-component.properties"/> for how
      multiple component PIDs are merged into component properties.</para>

      <para>The component factory PID always reserves the highest precedence
      among specified PIDs and is positioned last in PID ordering for the
      purpose of aggregation</para>

      <para>A factory component can only reference a single factory
      PID.</para>

      <para>Notwithstanding the factory PID, it is a definition error to refer
      to the same PID more than once.</para>

      <para>The configuration object used to satisfy the factory component's
      component factory PID must be a factory configuration object.</para>

      <para>Configuration objects used to satisfy the PIDs referred to by the
      <code>@PID</code> annotations must be single configuration
      objects.</para>
    </section>
  </section>

  <section xml:id="service.cdi-component.properties">
    <title>Component Properties</title>

    <para>Each component instance is associated with a set of
    <emphasis>component properties</emphasis>. Component properties are
    specified in the following <emphasis>configuration sources</emphasis> (in
    order of precedence, where the properties provided by later lines
    overwrite those of earlier lines):</para>

    <orderedlist>
      <listitem>
        <para>Properties specified as Bean Property Types on the bean
        annotated with <code>@SingleComponent</code> or
        <code>@FactoryComponent</code> must be treated according to <xref
        linkend="service.cdi-bean.property.types"/>.</para>
      </listitem>

      <listitem>
        <para>Properties provided by single configuration objects whose PIDs
        are matched to and are processed in the order they are specified by
        the component.</para>
      </listitem>

      <listitem>
        <para>Properties provided by a factory configuration object whose PID
        matches to the factory PID specified by the factory component.</para>
      </listitem>
    </orderedlist>

    <para>The precedence behavior allows certain default values to be
    specified in component metadata while allowing properties to be replaced
    and extended by a configuration object.</para>

    <para>Normally, a property value from a higher precedence configuration
    source replace a property value from a lower precedence configuration
    source. However, the <code>service.pid</code> property values receive
    different treatment. For the <code>service.pid</code> property, if the
    property appears multiple times in the configuration sources, CCR must
    aggregate all the values found into a
    <code>Collection&lt;String&gt;</code> having an iteration order such that
    the first item in the iteration is the property value from the lowest
    precedence configuration source and the last item in the iteration is the
    property value from the highest precedence configuration source. If the
    component refers to multiple PIDs, then the order of the
    <code>service.pid</code> property values collected from the corresponding
    configuration objects must match the order in which the PIDs are specified
    by the component. The values of the <code>service.pid</code> component
    property are the values as they come from the configuration sources and
    may container more values than those referred to by the component.</para>

    <para>CCR always adds the following component properties, which cannot be
    overridden:</para>

    <itemizedlist>
      <listitem>
        <para><code>component.name</code> - The component name. The syntax for
        the <code>component.name</code> follows <code>cname</code> defined by
        the <xref
        linkend="service.cdi-bib.general.syntax.definitions"/>.</para>
      </listitem>

      <listitem>
        <para><code>component.id</code> - A unique value ( <code>Long</code>)
        that is larger than all previously assigned values. These values are
        not persistent across restarts of CCR.</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Reference Properties</title>

      <para>This specification defines some component properties which are
      associated with a specific reference. These are called
      <emphasis>reference properties</emphasis>. The name of a reference
      property for a reference is the name of the reference appended with a
      full stop (<code>'.' \u002E</code>) and a suffix unique to the reference
      property. Reference properties can be set wherever component properties
      can be set.</para>

      <para>All component property names starting with a reference name
      followed by a full stop (<code>'.' \u002E</code>) are reserved for use
      by this specification.</para>

      <para>Following are the reference properties defined by this
      specification.</para>

      <section xml:id="service.cdi-target.property">
        <title>Target Property</title>

        <para>The <emphasis>target property</emphasis> is a reference property
        which aids in the selection of target services for the reference. See
        <xref linkend="service.cdi-reference.injection"/>. The name of a
        target property is the name of a reference appended with
        <code>.target</code>.</para>

        <programlisting>target  ::= refName '.target'
refName ::= &lt; reference name &gt;</programlisting>

        <para>For example, the target property for a reference with the name
        <code>http</code> <programlisting>@Inject
@Reference
Http http;</programlisting> would have the name <code>http.target</code>. The
        value of a target property is a filter String used to select target
        services for the reference.</para>

        <programlisting>http.target=(context.name=foo)</programlisting>

        <para>A default target property value can also be set by the <link
        linkend="org.osgi.service.cdi.annotations.Reference.target--">@Reference.target</link>
        property.</para>

        <para>The target property value must be a valid filter String
        according to <xref linkend="service.cdi-bib.filter.syntax"/>. Invalid
        filters result in unmatchable reference filters.</para>

        <para>CCR must support the target property for all references.</para>
      </section>

      <section xml:id="service.cdi-minimum.cardinality.property">
        <title>Minimum Cardinality Property</title>

        <para>The initial minimum cardinality of a reference is specified by
        the optionality of the reference. The minimum cardinality of a
        reference cannot exceed the multiplicity: a scalar reference has a
        multiplicity of 1 and a <code>java.util.List</code> or
        <code>java.util.Collection</code> reference has a multiplicity of
        n.</para>

        <para>The <emphasis>minimum cardinality property</emphasis> is a
        reference property which can be used to raise the minimum cardinality
        of a reference from its initial value. That is, a <code>0..1</code>
        cardinality can be raised to a <code>1..1</code> cardinality by
        setting the reference's minimum cardinality property to
        <code>1</code>. A <code>0..n</code> cardinality can be raised to a
        <code>m..n</code> cardinality by setting the reference's minimum
        cardinality property to <code>m</code> such that <code>m</code> is a
        positive integer. The minimum cardinality of a reference cannot be
        lowered. A mandatory reference cannot be reduced to optional through
        this property. That is, a <code>1..1</code> cardinality can not be
        lowered to a <code>0..1</code> cardinality because the component was
        written to expect at least one bound service.</para>

        <para>The name of a minimum cardinality property is the name of a
        reference appended with <code>.cardinality.minimum</code>.</para>

        <programlisting>
minimumCardinality ::= refName '.cardinality.minimum'
refName            ::= &lt; reference name &gt;</programlisting>

        <para>For example, the minimum cardinality property for a reference
        with the name <code>http</code> <programlisting>@Inject
@Reference
Http http;</programlisting> would have the name
        <code>http.cardinality.minimum</code>.</para>

        <programlisting>http.cardinality.minimum=3</programlisting>

        <para>The value of a minimum cardinality property must be a positive
        integer or a value that can be coerced into a positive integer using
        the <link linkend="util.converter-conversions">conversions</link>
        defined by the <xref linkend="util.converter"/>. If the numerical
        value of the minimum cardinality property is not valid for the
        reference's cardinality or the minimum cardinality property value
        cannot be coerced into a numerical value, then the minimum cardinality
        property must be ignored and a warning message logged.</para>

        <para>Attempts to reduce the initial minimum cardinality will result
        in a warning message to be logged and the value to be otherwise
        ignored.</para>

        <para>CCR must support the minimum cardinality property for all
        references.</para>
      </section>
    </section>
  </section>

  <section xml:id="service.cdi-bean.property.types">
    <title>Bean Property Types</title>

    <para>Component properties can be defined and accessed through a user
    defined annotation type, called a <emphasis>bean property type</emphasis>,
    containing the property names, property types and default values. A bean
    property type allows properties to be defined and accessed in a type safe
    manner. Bean Property Types must be annotated with the <xref
    linkend="org.osgi.service.cdi.annotations.BeanPropertyType"/>
    meta-annotation.</para>

    <para>The following example shows the definition of a bean property type
    called <code>Props</code> which defines three properties where the name of
    the property is the name of the method, the type of the property is the
    return type of the method and the default value for the property is the
    default value of the method.</para>

    <programlisting>@BeanPropertyType
public @interface Props {
	boolean enabled() default true;
	String[] names() default {"a", "b"};
	String topic() default "default/topic";
}</programlisting>

    <para>Bean Property Types can be used in several ways: <itemizedlist>
        <listitem>
          <para>Bean Property Types can be used along side the <xref
          linkend="org.osgi.service.cdi.annotations.SingleComponent"/> or
          <xref linkend="org.osgi.service.cdi.annotations.FactoryComponent"/>
          annotations to provide component properties.</para>
        </listitem>

        <listitem>
          <para>Bean Property Types can be used on
          <code>ApplicationScoped</code> or <code>Dependent</code> scoped
          beans, where the <xref
          linkend="org.osgi.service.cdi.annotations.Service"/> annotation is
          applied to provide service properties.</para>
        </listitem>

        <listitem>
          <para>Bean Property Types can be used on fields and methods
          annotated with <code>@Produces</code>, where the <xref
          linkend="org.osgi.service.cdi.annotations.Service"/> annotation is
          applied, to provide service properties.</para>
        </listitem>

        <listitem>
          <para>Bean Property Types can be used on injection points where the
          <xref linkend="org.osgi.service.cdi.annotations.Reference"/>
          annotation is applied, to provide target filter properties. Target
          filter properties can only provide <code>AND</code> filters.</para>
        </listitem>

        <listitem>
          <para>Bean Property Types can be used on injection points as the
          injection point type where the <xref
          linkend="org.osgi.service.cdi.annotations.ComponentProperties"/>
          annotation is applied to provide type safe coercion of component
          properties.</para>
        </listitem>
      </itemizedlist></para>

    <para>Each use defines property names, types and values.</para>

    <para>The following example shows a component bean annotated with the
    example <code>Props</code> bean property type which specifies a property
    value for the component which is different than the default value. The
    example also shows an injection point method taking the example
    <code>Props</code> bean property type as the injection point type and the
    method implementation accesses component property values by invoking
    methods on the bean property type object.</para>

    <programlisting>@SingleComponent
@Props(names="myapp")
public class MyBean {
	@Inject
	void activate(Props props) {
		if (props.enabled()) {
			// do something
		}
		for (String name : props.names()) {
			// do something with each name
		}
	}
}</programlisting>

    <para>Bean Property Types must be defined as annotation types. This is
    done for several reasons. First, the limitations on annotation type
    definitions make them well suited for Bean Property Types. The methods
    must have no parameters and the return types supported are limited to a
    set which is well suited for component properties. Second, annotation
    types support default values which is useful for defining the default
    value of a component property. Finally, as annotations, they can be used
    to annotate bean classes.</para>

    <para>At runtime, when CCR needs to provide injection points an object
    whose type is a bean property type, CCR must construct an instance of the
    bean property type whose methods are backed by the values of the component
    properties. This object can then be used to obtain the property values in
    a type safe manner.</para>

    <section xml:id="service.cdi-bean.property.type.mapping">
      <title>Bean Property Type Mapping</title>

      <para>Each method of a bean property type is mapped to a component
      property. The property name is derived from the method name. Certain
      common property name characters, such as full stop (<code>'.'
      \u002E</code>) and hyphen-minus (<code>'-' \u002D</code>) are not valid
      in Java identifiers. So the name of a method must be converted to its
      corresponding property name as follows:<itemizedlist>
          <listitem>
            <para>A single dollar sign (<code>'$' \u0024</code>) is removed
            unless it is followed by:<itemizedlist>
                <listitem>
                  <para>A low line (<code>'_' \u005F</code>) and a dollar sign
                  in which case the three consecutive characters
                  (<code>"$_$"</code>) are converted to a single hyphen-minus
                  (<code>'-' \u002D</code>).</para>
                </listitem>

                <listitem>
                  <para>Another dollar sign in which case the two consecutive
                  dollar signs (<code>"$$"</code>) are converted to a single
                  dollar sign.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para>A single low line (<code>'_' \u005F</code>) is converted
            into a full stop (<code>'.' \u002E</code>) unless is it followed
            by another low line in which case the two consecutive low lines
            (<code>"__"</code>) are converted to a single low line.</para>
          </listitem>

          <listitem>
            <para>All other characters are unchanged.</para>
          </listitem>

          <listitem>
            <para>If the bean property type declares a <code>PREFIX_</code>
            field whose value is a compile-time constant String, then the
            property name is prefixed with the value of the
            <code>PREFIX_</code> field.</para>
          </listitem>
        </itemizedlist></para>

      <para><xref linkend="service.cdi-bean.property.type.name.mapping"/>
      contains some name mapping examples.</para>

      <table xml:id="service.cdi-bean.property.type.name.mapping">
        <title>Bean Property Type Name Mapping Examples</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <thead>
            <row>
              <entry>Bean Property Type Method Name</entry>

              <entry>Component Property Name</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>myProperty143</code></entry>

              <entry><code>myProperty143</code></entry>
            </row>

            <row>
              <entry><code>$new</code></entry>

              <entry><code>new</code></entry>
            </row>

            <row>
              <entry><code>my$$prop</code></entry>

              <entry><code>my$prop</code></entry>
            </row>

            <row>
              <entry><code>dot_prop</code></entry>

              <entry><code>dot.prop</code></entry>
            </row>

            <row>
              <entry><code>_secret</code></entry>

              <entry><code>.secret</code></entry>
            </row>

            <row>
              <entry><code>another__prop</code></entry>

              <entry><code>another_prop</code></entry>
            </row>

            <row>
              <entry><code>three___prop</code></entry>

              <entry><code>three_.prop</code></entry>
            </row>

            <row>
              <entry><code>four_$__prop</code></entry>

              <entry><code>four._prop</code></entry>
            </row>

            <row>
              <entry><code>five_$_prop</code></entry>

              <entry><code>five..prop</code></entry>
            </row>

            <row>
              <entry><code>six$_$prop</code></entry>

              <entry><code>six-prop</code></entry>
            </row>

            <row>
              <entry><code>seven$$_$prop</code></entry>

              <entry><code>seven$.prop</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>However, if the bean property type is a <emphasis>single-element
      annotation</emphasis>, see 9.7.3 in <xref
      linkend="service.cdi-bib.jls.ref"/>, then the property name for the
      <code>value</code> method is derived from the name of the bean property
      type rather than the name of the method.</para>

      <para>In this case, the simple name of the bean property type, that is,
      the name of the class without any package name or outer class name, if
      the bean property type is an inner class, must be converted to the
      property name as follows:<itemizedlist>
          <listitem>
            <para>When a lower case character is followed by an upper case
            character, a full stop (<code>'.' \u002E</code>) is inserted
            between them.</para>
          </listitem>

          <listitem>
            <para>Each upper case character is converted to lower case.</para>
          </listitem>

          <listitem>
            <para>All other characters are unchanged.</para>
          </listitem>

          <listitem>
            <para>If the bean property type declares a <code>PREFIX_</code>
            field whose value is a compile-time constant String, then the
            property name is prefixed with the value of the
            <code>PREFIX_</code> field.</para>
          </listitem>
        </itemizedlist></para>

      <para><xref linkend="service.cdi-single.element.name.mapping"/> contains
      some mapping examples for the <code>value</code> method.</para>

      <table xml:id="service.cdi-single.element.name.mapping">
        <title>Single-Element Annotation Mapping Examples for
        <code>value</code> Method</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <thead>
            <row>
              <entry>Bean Property Type Name</entry>

              <entry><code>value</code> Method Component Property Name</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>ServiceRanking</code></entry>

              <entry><code>service.ranking</code></entry>
            </row>

            <row>
              <entry><code>Some_Name</code></entry>

              <entry><code>some_name</code></entry>
            </row>

            <row>
              <entry><code>OSGiProperty</code></entry>

              <entry><code>osgi.property</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If the bean property type is a <emphasis>marker
      annotation</emphasis>, see 9.7.2 in <xref
      linkend="service.cdi-bib.jls.ref"/>, then the property name is derived
      from the name of the bean property type, as is described above for
      single-element annotations, and the value of the property is
      <code>Boolean.TRUE</code>. Marker annotations can be used to annotate
      component beans to set a component property to the value
      <code>Boolean.TRUE</code>. However, since marker annotations have no
      methods, they are of no use as injection point types.</para>

      <para>The property type can be directly derived from the type of the
      method. All types supported for annotation elements can be used except
      for annotation types. Method types of an annotation type or array
      thereof are not supported.</para>

      <para>If the method type is <code>Class</code> or <code>Class[]</code>,
      then the property type must be <code>String</code> or
      <code>String[]</code>, respectively, whose values are fully qualified
      class names in the form returned by the <code>Class.getName()</code>
      method.</para>

      <para>If the method type is an enumeration type or an array thereof,
      then the property type must be <code>String</code> or
      <code>String[]</code>, respectively, whose values are the names of the
      enum constants in the form returned by the <code>Enum.name()</code>
      method.</para>
    </section>

    <section xml:id="service.cdi-bean.property.type.value.coercion">
      <title>Coercing Bean Property Type Values</title>

      <para>When a bean property type is used as an injection point type alone
      with <code>@ComponentProperties</code>, CCR must create a contextual
      instance that implements the bean property type and maps the methods of
      the bean property type to component properties. The name of the method
      is converted to the property name as described in <xref
      linkend="service.cdi-bean.property.type.mapping"/>. The property value
      may need to be coerced to the type of the method. In <xref
      linkend="service.cdi-coercion.table"/>, the columns are source types,
      that is, the type of the component property value, and the rows are
      target types, that is, the method types. The property value is
      <emphasis>v</emphasis>; <emphasis>number</emphasis> is a primitive
      numerical type and <emphasis>Number</emphasis> is a wrapper numerical
      type. An invalid coercion is represented by <code>throw</code>. Such a
      coercion attempt must result in throwing a Bean Property Exception when
      the bean property type method is called. Any other coercion error, such
      as parsing a non-numerical String to a number or the inability to coerce
      a String into a Class or enum object, must be wrapped in a Bean Property
      Exception and thrown when the bean property type method is
      called.</para>

      <table pgwide="1" rowheader="firstcol"
             xml:id="service.cdi-coercion.table">
        <title>Coercion From Property Value to Method Type</title>

        <tgroup cols="6">
          <colspec colname="col1" colnum="1" colwidth="1*"/>

          <colspec colname="col2" colnum="2" colwidth="1*"/>

          <colspec colname="col3" colnum="3" colwidth="1*"/>

          <colspec colname="col4" colnum="4" colwidth="1*"/>

          <colspec colname="col5" colnum="5" colwidth="1*"/>

          <colspec colname="col6" colnum="6" colwidth="2*"/>

          <thead>
            <row>
              <entry><subscript>target</subscript> \
              <superscript>source</superscript></entry>

              <entry>String</entry>

              <entry>Boolean</entry>

              <entry>Character</entry>

              <entry><emphasis>Number</emphasis></entry>

              <entry>Collection/array</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>String</entry>

              <entry><emphasis>v</emphasis></entry>

              <entry><emphasis>v</emphasis>. toString()</entry>

              <entry><emphasis>v</emphasis>. toString()</entry>

              <entry><emphasis>v</emphasis>. toString()</entry>

              <entry>If <emphasis>v</emphasis> has no elements,
              <code>null</code>; otherwise the first element of
              <emphasis>v</emphasis> is coerced.</entry>
            </row>

            <row>
              <entry>boolean</entry>

              <entry>Boolean. parseBoolean( <emphasis>v</emphasis> )</entry>

              <entry><emphasis>v</emphasis>. booleanValue()</entry>

              <entry><emphasis>v</emphasis>. charValue() != 0</entry>

              <entry><emphasis>v</emphasis>. doubleValue() != 0</entry>

              <entry>If <emphasis>v</emphasis> has no elements,
              <code>false</code>; otherwise the first element of
              <emphasis>v</emphasis> is coerced.</entry>
            </row>

            <row>
              <entry>char</entry>

              <entry><emphasis>v</emphasis>. length() &gt; 0 ?
              <emphasis>v</emphasis>. charAt(0) : 0</entry>

              <entry><emphasis>v</emphasis>. booleanValue() ? 1 : 0</entry>

              <entry><emphasis>v</emphasis>. charValue()</entry>

              <entry>(char) <emphasis>v</emphasis>. intValue()</entry>

              <entry>If <emphasis>v</emphasis> has no elements, 0; otherwise
              the first element of <emphasis>v</emphasis> is coerced.</entry>
            </row>

            <row>
              <entry><emphasis>number</emphasis></entry>

              <entry><emphasis>Number</emphasis>.
              parse<emphasis>Number</emphasis>( <emphasis>v</emphasis>
              )</entry>

              <entry><emphasis>v</emphasis>. booleanValue() ? 1 : 0</entry>

              <entry>(<emphasis>number</emphasis>) <emphasis>v</emphasis>.
              charValue()</entry>

              <entry><emphasis>v</emphasis>.
              <emphasis>number</emphasis>Value()</entry>

              <entry>If <emphasis>v</emphasis> has no elements, 0; otherwise
              the first element of <emphasis>v</emphasis> is coerced.</entry>
            </row>

            <row>
              <entry>Class</entry>

              <entry>Bundle. loadClass( <emphasis>v</emphasis> )</entry>

              <entry><code>throw</code></entry>

              <entry><code>throw</code></entry>

              <entry><code>throw</code></entry>

              <entry>If <emphasis>v</emphasis> has no elements,
              <code>null</code>; otherwise the first element of
              <emphasis>v</emphasis> is coerced.</entry>
            </row>

            <row>
              <entry><emphasis>EnumType</emphasis></entry>

              <entry><emphasis>EnumType</emphasis>. valueOf(
              <emphasis>v</emphasis> )</entry>

              <entry><code>throw</code></entry>

              <entry><code>throw</code></entry>

              <entry><code>throw</code></entry>

              <entry>If <emphasis>v</emphasis> has no elements,
              <code>null</code>; otherwise the first element of
              <emphasis>v</emphasis> is coerced.</entry>
            </row>

            <row>
              <entry>annotation type</entry>

              <entry><code>throw</code></entry>

              <entry><code>throw</code></entry>

              <entry><code>throw</code></entry>

              <entry><code>throw</code></entry>

              <entry><code>throw</code></entry>
            </row>

            <row>
              <entry>array</entry>

              <entry nameend="col5" namest="col2">A single element array is
              created and <emphasis>v</emphasis> is coerced into the single
              element of the new array.</entry>

              <entry colname="col6">An array the size of
              <emphasis>v</emphasis> is created and each element of
              <emphasis>v</emphasis> is coerced into the corresponding element
              of the new array.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Component properties whose names do not map to bean property type
      methods are ignored. If there is no corresponding component property for
      a bean property type method, the bean property type method must:</para>

      <itemizedlist>
        <listitem>
          <para>Return 0 for numerical and char method types.</para>
        </listitem>

        <listitem>
          <para>Return <code>false</code> for boolean method type.</para>
        </listitem>

        <listitem>
          <para>Return <code>null</code> for String, Class, and enum.</para>
        </listitem>

        <listitem>
          <para>Return an empty array for array method types.</para>
        </listitem>

        <listitem>
          <para>Throw a BeanPropertyException for annotation method
          types.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="service.cdi-standard.bean.property.types">
      <title>Standard Bean Property Types</title>

      <para>Bean Property Types for standard service properties are specified
      in the <xref linkend="org.osgi.service.cdi.propertytypes"/>
      package.</para>

      <para>The <xref
      linkend="org.osgi.service.cdi.propertytypes.ServiceDescription"/> bean
      property type can be used to add the <code>service.description</code>
      component property, service property or target filter. The <xref
      linkend="org.osgi.service.cdi.propertytypes.ServiceRanking"/> bean
      property type can be used to add the <code>service.ranking</code>
      component property, service property or target filter. The <xref
      linkend="org.osgi.service.cdi.propertytypes.ServiceVendor"/> bean
      property type can be used to add the <code>service.vendor</code>
      component property, service property or target filter. For example,
      using these Bean Property Types as annotations:</para>

      <programlisting>@FactoryComponent
@ServiceDescription(”My Acme Service implementation”)
@ServiceRanking(100)
@ServiceVendor("My Corp")
public class MyBean implements AcmeService {}</programlisting>

      <para>will result in the following component properties:</para>

      <programlisting>service.description=My Acme Service implementation # String
service.ranking=100 # Integer
service.vendor=My Corp # String</programlisting>

      <para>The <xref
      linkend="org.osgi.service.cdi.propertytypes.ExportedService"/> bean
      property type can be used to specify service properties for remote
      services.</para>
    </section>
  </section>

  <section xml:id="service.cdi-providing.services">
    <title>Providing Services</title>

    <para>A key aspect of working with OSGi is the ability to provide
    services. Services are published to the service registry specifying
    service types. The <link
    linkend="org.osgi.service.cdi.annotations.Service">@Service</link>
    annotation provides this capability to CCR and serves a dual role; the
    first of which is indicating that a bean publishes a service, the second
    indicating the service types. <code>@Service</code> can be applied in any
    one of the following ways:</para>

    <section>
      <title>@Service applied to bean class</title>

      <para>Applying the <code>@Service</code> annotation to the bean class
      indicates the set of service types will be one of (in order of
      precedence):</para>

      <orderedlist>
        <listitem>
          <para><emphasis>the specified type(s)</emphasis> - When providing a
          specified <xref
          linkend="org.osgi.service.cdi.annotations.Service.value--"/>, these
          are the types under which the service is published.</para>

          <programlisting>// service types = [BassetHound, Dog]
@Service({BassetHound.class, Dog.class})
class Spot {}</programlisting>
        </listitem>

        <listitem>
          <para><emphasis>directly implemented interfaces</emphasis> - These
          are the interfaces for which the bean class directly specifies an
          <code>implements</code> clause.</para>

          <programlisting>// service types = [Hound]
@Service
class Fido implements Hound {}</programlisting>
        </listitem>

        <listitem>
          <para><emphasis>bean class</emphasis> - The class of the bean itself
          is the type under which the service is published.</para>

          <programlisting>// service types = [Fido]
@Service
class Fido</programlisting>
        </listitem>
      </orderedlist>

      <para>The <code>@Service</code> annotation is <emphasis>never
      inherited</emphasis>. CCR ignores instances of the annotation on super
      classes, interfaces or super interfaces for this purpose.</para>
    </section>

    <section>
      <title>@Service applied to type use</title>

      <para>A convenient readability optimization is to apply the
      <code>@Service</code> annotation on <emphasis>type_use</emphasis>. This
      is to say that it may be applied to <code>extends</code> and/or
      <code>implements</code> clauses. For example:</para>

      <programlisting>// service types = [BassetHound]
class Fido extends @Service BassetHound {}</programlisting>

      <para>Or:</para>

      <programlisting>// service types = [Hound]
class Fido implements @Service Hound {}</programlisting>

      <para>The two approaches can be combined. <code>@Service</code>
      annotations are collected so that the service is published with all
      collected types:</para>

      <programlisting>// service types = [BassetHound, Hound]
class Fido extends @Service BassetHound implements @Service Hound {}</programlisting>

      <para>In this scenario, any use of the <code>@Service.value</code>
      property will result in a definition error.</para>

      <para>Applying <code>@Service</code> to both bean class, and type use
      will result in a definition error.</para>
    </section>

    <section>
      <title>@Service applied to Producers</title>

      <para>Applying the <code>@Service</code> annotation to producer methods
      or fields indicates the set of service types as described in the
      following table (earlier rows take precedence over later rows).</para>

      <table>
        <title>@Service applied to Producers</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="2*"/>

          <thead>
            <row>
              <entry>Case</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para>the type(s) specified by
              <code>@Service.value</code></para></entry>

              <entry><para>When providing a specified
              <code>@Service.value</code>, these are the types under which the
              service is published.</para> <programlisting>// service types = [BassetHound, Dog]
@Produces
@Service({BassetHound.class, Dog.class})
Spot getSpot() {
	return new Spot();
}</programlisting></entry>
            </row>

            <row>
              <entry><para>the returned interface</para></entry>

              <entry><para>In the case of a producer method, if the return
              type is an interface, this type is used as the service
              type.</para> <programlisting>// service types = [Dog]
@Produces
@Service
Dog getDog() {
	return new Spot();
}</programlisting></entry>
            </row>

            <row>
              <entry><para>all directly implemented interfaces of returned
              type</para></entry>

              <entry><para>In the case of a producer method, if the return
              type is a concrete type, use any interfaces directly implemented
              by the concrete type.</para> <programlisting>// service types = [Hound]
@Produces
@Service
Buddy getBuddy() {
	return new Buddy();
}</programlisting></entry>
            </row>

            <row>
              <entry><para>the return type</para></entry>

              <entry><para>In the case of a producer method, if the return
              type is a concrete type which does not directly implement any
              interfaces, use the concrete type.</para> <programlisting>class Fido {}

// service types = [Fido]
@Produces
@Service
Fido getFido() {
	return new Fido();
}</programlisting></entry>
            </row>

            <row>
              <entry><para>the field interface</para></entry>

              <entry><para>In the case of a producer field, if the field type
              is an interface this type is used as the service type.</para>
              <programlisting>// service types = [Dog]
@Produces
@Service
Dog dog = new Spot();</programlisting></entry>
            </row>

            <row>
              <entry><para>all directly implemented interfaces of the field
              type</para></entry>

              <entry><para>In the case of a producer field, if the field type
              is a concrete type use any interfaces directly implemented by
              the concrete type.</para> <programlisting>// service types = [Hound]
@Produces
@Service
Buddy buddy = new Buddy();</programlisting></entry>
            </row>

            <row>
              <entry><para>the field type</para></entry>

              <entry><para>In the case of a producer field if the field type
              is a concrete type which does not directly implement any
              interfaces use the concrete type.</para> <programlisting>class Fido {}

// service types = [Fido]
@Produces
@Service
Fido fido = new Fido();</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="service.cdi-service.restrictions">
      <title>@Service Type Restrictions</title>

      <para>Regardless of the source, no service type may be a generic type. A
      generic type found in the set of service types will result in a
      definition error.</para>

      <para>Service types must be a subset of bean types, including types
      restricted by the use of the <code>@javax.enterprise.inject.Typed</code>
      annotation. This restriction is required to support CDI features like
      <emphasis>Decorators</emphasis> and
      <emphasis>Interceptors</emphasis>.</para>

      <para>Using the <code>@Service</code> annotation on injection points
      will result in a definition error.</para>
    </section>

    <section xml:id="service.cdi-service.properties">
      <title>Service Properties</title>

      <para>The main source of service properties is <xref
      linkend="service.cdi-component.properties"/>.</para>

      <para>When CCR registers a service on behalf of a component instance,
      CCR must follow the recommendations in <xref
      linkend="service.cm.propertypropagation"/> and must not propagate
      private configuration properties. That is, the service properties of the
      registered service must be all the component properties of the component
      configuration whose property names do not start with full stop
      (<code>'.' \u002E</code>).</para>

      <para>Component properties whose names start with full stop are
      available to the component instance but are not available as service
      properties of the registered service.</para>

      <section>
        <title>Container component service properties</title>

        <para>In addition to component properties, services provided by the
        container component obtain additional service properties from Bean
        Property Types on the bean or producer providing the service. See
        <xref linkend="service.cdi-bean.property.types"/>.</para>
      </section>
    </section>

    <section xml:id="service.cdi-service.scope">
      <title>Service Scope</title>

      <para>Service scope represents the scope of the registered service
      object. There are three scopes supported by the OSGi Framework. Each can
      be represented in CCR.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Bundle scope</emphasis> - In order to specify a
          bundle scoped service, the <link
          linkend="org.osgi.service.cdi.annotations.ServiceInstance">@ServiceInstance</link>
          annotation is specified on the bean class, producer method or
          producer field with the value <xref
          linkend="org.osgi.service.cdi.ServiceScope.BUNDLE"/>.</para>

          <programlisting>@Service
@ServiceInstance(ServiceScope.BUNDLE)
class Fido implements Hound {}</programlisting>
        </listitem>

        <listitem>
          <para><emphasis>Prototype scope</emphasis> - In order to specify a
          prototype scoped service, the <link
          linkend="org.osgi.service.cdi.annotations.ServiceInstance">@ServiceInstance</link>
          annotation is specified on the bean class, producer method or
          producer field with the value <xref
          linkend="org.osgi.service.cdi.ServiceScope.PROTOTYPE"/>. The service
          object is the contextual instance created by the producer or
          bean.</para>

          <programlisting>@Service
@ServiceInstance(ServiceScope.PROTOTYPE)
class Fido implements Hound {}</programlisting>
        </listitem>

        <listitem>
          <para><emphasis>Singleton scope</emphasis> - Unless otherwise
          specified, services are singleton scoped but the scope can be
          explicitly expressed if the <link
          linkend="org.osgi.service.cdi.annotations.ServiceInstance">@ServiceInstance</link>
          annotation is specified on the bean class, producer method or
          producer field with the value <xref
          linkend="org.osgi.service.cdi.ServiceScope.SINGLETON"/>. The service
          object is the contextual instance created by the producer or
          bean.</para>

          <programlisting>@Service
@ServiceInstance(ServiceScope.SINGLETON) // equal to omitting the annotation
class Fido implements Hound {}</programlisting>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Container Component Services</title>

      <para>Beans, producer methods and producer fields that are
      <code>@ApplicationScoped</code> result in contextual instances that are
      shared throughout the CDI container. Therefore they can only provide
      singleton scoped services. Each such case results in a single service
      registration. The service object is the contextual instance created by
      the producer or bean. However, <code>@ApplicationScoped</code> beans can
      implement <code>org.osgi.framework.ServiceFactory</code> or
      <code>org.osgi.framework.PrototypeServiceFactory</code> in order to
      provide bundle or prototype scoped service objects.</para>

      <para>Beans, producer methods and producer fields that are
      <code>@Dependent</code> result in contextual instances which are never
      shared in that a new contextual instance is created for each caller.
      Therefore they can provide services of all scopes as outlined in <xref
      linkend="service.cdi-service.scope"/>. The service object is a
      contextual instance created by the producer or bean on each request for
      a service object.</para>

      <para>The use of <code>@ServiceInstance</code> on
      <code>@ApplicationScoped</code> beans will result in a definition
      error.</para>
    </section>

    <section xml:id="service.cdi-single.component.services">
      <title>Single Component Services</title>

      <para>Single components can only apply the <code>@Service</code>
      annotation to beans marked with <code>@SingleComponent</code>.</para>

      <para>A single component providing a service results in a single service
      registration.</para>

      <para>Service objects provided by the service registration are defined
      by the creation of <link
      linkend="service.cdi-lifecycle.context.instances">contexts</link>. In
      all cases, the service object provided is the contextual instance of the
      bean marked <code>@SingleComponent</code> obtained from the
      context.</para>
    </section>

    <section xml:id="service.cdi-factory.component.services">
      <title>Factory Component Services</title>

      <para>Factory components can only apply the <code>@Service</code>
      annotation to beans marked with <code>@FactoryComponent</code>.</para>

      <para>A factory component providing a service results in one service
      registration for every factory configuration object associated with the
      factory PID of the component.</para>

      <para>Service objects provided by the service registration are defined
      by the creation of <link
      linkend="service.cdi-lifecycle.context.instances">contexts</link>. In
      all cases, the service object provided is the contextual instance of the
      bean marked <code>@FactoryComponent</code> obtained from the
      context.</para>
    </section>
  </section>

  <section xml:id="service.cdi-component.properties.injection">
    <title>Component Property Injection Points</title>

    <para>A bean specifies injection of component properties using the <link
    linkend="org.osgi.service.cdi.annotations.ComponentProperties">@ComponentProperties</link>
    annotation at an injection point.</para>

    <para>The type typically associated with component properties is
    <code>java.util.Map&lt;String, Object&gt;</code>:</para>

    <programlisting>@Inject
@ComponentProperties
Map&lt;String, Object&gt; componentProperties;</programlisting>

    <para>However, component properties can be automatically converted to any
    type compatible with the <link
    linkend="util.converter-conversions">conversions</link> defined by the
    <xref linkend="util.converter"/>.</para>

    <para>Given the following configuration properties:</para>

    <programlisting>pool.name (String)
min.threads (int)
max.threads (int)
keep.alive.timeout (long)</programlisting>

    <para>The following example demonstrates conversion of component
    properties into a type safe object with defaults.</para>

    <programlisting>public static @interface PoolConfig {
	String pool_name();
	int min_threads() default 2;
	int max_threads() default 10;
	long keep_alive_timeout() default 500;
}

@Inject
@ComponentProperties
PoolConfig poolConfig;</programlisting>

    <para>Using <link
    linkend="org.osgi.service.cdi.annotations.Reference">@Reference</link> in
    conjunction with <code>@ComponentProperties</code> will result in a
    definition error.</para>

    <section xml:id="service.cdi-coordinatorsupport">
      <title>Coordinator Support</title>

      <para>The <xref linkend="service.coordinator"/> defines a mechanism for
      multiple parties to collaborate on a common task without <emphasis>a
      priori</emphasis> knowledge of who will collaborate in that task. Like
      <xref linkend="service.cm"/>, CCR must participate in such scenarios to
      coordinate with provisioning or configuration tasks.</para>

      <para>If configuration changes occur and an implicit coordination
      exists, CCR must delay taking action on the configuration changes until
      the coordination terminates, regardless of whether the coordination
      fails or terminates regularly.</para>
    </section>
  </section>

  <section xml:id="service.cdi-reference.injection">
    <title>Reference Injection Points</title>

    <para>Any injection point annotated with <link
    linkend="org.osgi.service.cdi.annotations.Reference">@Reference</link>
    declares a service dependency.</para>

    <section xml:id="service.cdi-reference.injection.point.types">
      <title>Reference injection point types</title>

      <para>Injection points specifying <code>@Reference</code> are limited to
      one of the following <emphasis>injection point types</emphasis> as
      representations of the dependent service(s). Given that type
      <code>S</code> is a type under which a service is published, the
      following <emphasis>injection point types</emphasis> are
      supported:</para>

      <table>
        <title>Reference injection point types</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="1*"/>

          <thead>
            <row>
              <entry>Injection Point Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>S</code></entry>

              <entry><programlisting>// S = Dog
@Inject
@Reference
Dog dog;</programlisting></entry>
            </row>

            <row>
              <entry><code>org.osgi.framework.ServiceReference&lt;S&gt;</code></entry>

              <entry><programlisting>// S = Dog
@Inject
@Reference
ServiceReference&lt;Dog&gt; dog;</programlisting></entry>
            </row>

            <row>
              <entry><code>java.util.Map&lt;String, ? |
              Object&gt;</code></entry>

              <entry><para>In this case the <code>@Reference</code> annotation
              must specify service type <code>S</code> using it's <xref
              linkend="org.osgi.service.cdi.annotations.Reference.value--"/>
              property.</para> <programlisting>// S = Dog
@Inject
@Reference(Dog.class)
Map&lt;String, Object&gt; dogProperties;</programlisting> <para>Failure to
              specify the type in this scenario results in a definition
              error.</para></entry>
            </row>

            <row>
              <entry><code>java.util.Map.Entry&lt;Map&lt;String, ? |
              Object&gt;, S&gt;</code></entry>

              <entry><para>Represents a <emphasis>tuple</emphasis> containing
              the map of service properties as the key and the service
              instance as the value.</para> <programlisting>// S = Dog
@Inject
@Reference
Map.Entry&lt;Map&lt;String, ?&gt;, Dog&gt; dog;</programlisting></entry>
            </row>

            <row>
              <entry><code><link
              linkend="org.osgi.service.cdi.reference.BeanServiceObjects">BeanServiceObjects&lt;S&gt;</link></code></entry>

              <entry><programlisting>// S = Dog
@Inject
@Reference
BeanServiceObjects&lt;Dog&gt; dogs;</programlisting></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><code>S</code> must be a concrete service type. The OSGi service
      registry does not support generics, therefore <code>S</code> cannot
      specify a generic type.</para>

      <para>A definition error will result if any other types are used with
      injection points marked <code>@Reference</code> unless otherwise
      specified by this specification.</para>
    </section>

    <section xml:id="service.cdi-reference.service.scope">
      <title>Reference Service scope</title>

      <para>For a bound service, CCR must get the service object from the OSGi
      Framework's service registry using the <code>getService</code> method on
      the component's Bundle Context. If the service object for a bound
      service has been obtained and the service becomes unbound, CCR must
      unget the service object using the <code>ungetService</code> method on
      the component's Bundle Context and discard all references to the service
      object. This ensures that the bundle will only be exposed to a single
      instance of the service object at any given time.</para>

      <para>For a bound service of a reference where the <xref
      linkend="org.osgi.service.cdi.annotations.PrototypeRequired"/>
      annotation was specified, only services registered with prototype
      service scope can be considered as target services. This ensures that
      each component instance can be exposed to a single, distinct instance of
      the service object. Using <code>@PrototypeRequired</code> effectively
      adds <code>service.scope=prototype</code> to the <link
      linkend="service.cdi-target.property">target property</link> of the
      reference. A service that does not use prototype service scope cannot be
      used as a bound service for a reference with
      <code>@PrototypeRequired</code> since the service cannot provide a
      distinct service object for each component instance.</para>

      <programlisting>@Inject
@PrototypeRequired
@Reference
Hound hound;</programlisting>
    </section>

    <section>
      <title>Bean Service Objects</title>

      <para>A Bean Service Objects for the bound service, can be used to
      obtain the actual service object or objects. This approach is useful
      when the referenced service has prototype service scope and the
      component instance needs multiple service objects for the
      service.</para>

      <programlisting>@Inject
@PrototypeRequired
@Reference
BeanServiceObjects&lt;Hound&gt; hounds;</programlisting>

      <para>The <code>@PrototypeRequired</code> annotation is optional. See
      <xref linkend="service.cdi-service.scope"/>.</para>
    </section>

    <section>
      <title>Reference Greediness</title>

      <para>References are greedy by default which means that higher ranking
      matches are immediately bound. Use the <code>@Reluctant</code>
      annotation to indicate that higher ranking matches should not bind once
      the reference has been resolved. Note that in the case of static
      references the component will be destroyed and recreated in order to
      immediately apply the better match. In the case of the container
      component, this will result in the entire CDI container being destroyed
      and recreated.</para>

      <para>A static, greedy reference:</para>

      <programlisting>@Inject
@Reference
Hound hound;</programlisting>

      <para>A static, reluctant reference:</para>

      <programlisting>@Inject
@Reluctant
@Reference
Hound hound;</programlisting>
    </section>

    <section xml:id="service.cdi-reference.service.type">
      <title>Service Type</title>

      <para>As demonstrated earlier, it's possible to specify the service type
      of the reference by using <code>@Reference.value()</code> property. This
      supports use cases like <code>java.util.Map&lt;String, ?&gt;</code>
      where the service type cannot be determined.</para>

      <programlisting>@Inject
@Reference(Hound.class)
Map&lt;String, Object&gt; properties;</programlisting>

      <para>This makes it possible to target a more specific service type. A
      reference injection point whose type is <code>Dog</code> may target a
      service of type <code>BassetHound</code>:</para>

      <programlisting>@Inject
@Reference(BassetHound.class)
Dog dog;</programlisting>

      <para>The injection point type must be compatible with the service type.
      Otherwise a definition error will result.</para>
    </section>

    <section xml:id="service.cdi-reference.service.type.any">
      <title>Any Service Type</title>

      <para>A special exception to the service type rules is defined when the
      special marker type <xref
      linkend="org.osgi.service.cdi.annotations.Reference.Any"/> is set as
      <code>@Reference.value</code>. This allows for any service to match the
      reference. However, the following criteria must be satisfied:</para>

      <orderedlist>
        <listitem>
          <para><code>@Reference.value</code> must specify the single value
          <code>Reference.Any.class</code></para>
        </listitem>

        <listitem>
          <para><code>@Reference.target</code> must specify a valid, non-empty
          filter value</para>
        </listitem>

        <listitem>
          <para>The injection point <emphasis>service type</emphasis> must be
          <code>java.lang.Object</code>. For example: <programlisting>@Inject
@Reference(value = Reference.Any.class, target = "(foo=bar)")
Optional&lt;Object&gt; match;</programlisting> or <programlisting>@Inject
@Reference(value = Reference.Any.class, target = "(foo=bar)")
List&lt;Object&gt; matches;</programlisting> Note that there may be
          performance impacts resulting from matching too broad a set of
          services. By definition the above list example with a target filter
          equal to <code>(service.id=*)</code> is perfectly valid but will
          match all services in the registry which will likely neither be very
          useful nor performant.</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>Target Filter</title>

      <para>Target services for a reference are constrained by the reference's
      service type and the <link linkend="service.cdi-target.property">target
      property</link>. A default target filter can be applied by specifying
      <code>@Reference.target()</code> property.</para>

      <para>For example, a component wants to track all <code>Dog</code>
      services that have a service property <code>service.vendor</code> whose
      value is equal to <code>Acme, Ltd.</code>:</para>

      <programlisting>@Inject
@Reference(target = "(service.vendor=Acme, Ltd.)")
Collection&lt;Dog&gt; dogs;</programlisting>

      <section xml:id="service.cdi-bean.property.types.as.target.filters">
        <title>Bean Property Types as target filters</title>

        <para>Annotations meta-annotated with <xref
        linkend="org.osgi.service.cdi.annotations.BeanPropertyType"/>
        appearing on an injection point in conjunction with the
        <code>@Reference</code> annotation will further enhance the target
        filter as described by the rules for converting <xref
        linkend="service.cdi-bean.property.types"/> to a map of properties
        assembled into a filter String according to the following
        steps:</para>

        <orderedlist>
          <listitem>
            <para>any <code>key=array</code> pairs are flattened into many
            <code>key=scalar</code> pairs, one pair for each array
            value</para>
          </listitem>

          <listitem>
            <para>format every <code>key=scalar</code> pair using the
            production <programlisting>pair       ::= '(' pairKey '=' pairScalar ')'
pairKey    ::= &lt; key &gt;
pairScalar ::= &lt; scalar &gt;</programlisting> If <code>scalar</code> must
            contain one of the characters reverse solidus (<code>'\'
            \u005C</code>), asterisk (<code>'*' \u002A</code>), parentheses
            open (<code>'(' \u0028</code>) or parentheses close (<code>')'
            \u0029</code>), then these characters must be preceded with the
            reverse solidus (<code>'\' \u005C</code>) character. Spaces are
            significant in <code>scalar</code>. Space characters are defined
            by <code>Character.isWhiteSpace()</code></para>
          </listitem>

          <listitem>
            <para>concatenate all results of step <code>2.</code> into a
            single String</para>
          </listitem>

          <listitem>
            <para>append the value of <code>@Reference.target()</code> to the
            result of step <code>3.</code></para>
          </listitem>

          <listitem>
            <para>format the result of step <code>4.</code> using the
            production <programlisting>target ::= '(' '&amp;' step4 ')'
step4  ::= &lt; result of step 4. &gt;</programlisting></para>
          </listitem>
        </orderedlist>

        <para>Given the following example:</para>

        <programlisting>
enum Tricks {
	SIT, STAND, SHAKE_PAW, TREAT_ON_NOSE
}
@Repeatable(...)
@BeanPropertyType
@interface Trick {
	Tricks value();
}

@Inject
@Reference(target = "(service.vendor=Acme Kennels, Ltd.)")
@Trick(SIT)
@Trick(TREAT_ON_NOSE)
Dog dog;</programlisting>

        <para>The target filter will be:</para>

        <programlisting>(&amp;(trick=sit)(trick=treat_on_nose)(service.vendor=Acme Kennels, Ltd.))</programlisting>
      </section>
    </section>

    <section>
      <title>Reference Names</title>

      <para>The <code>@javax.inject.Named</code> annotation may be used to
      specify a name to serve as the base of the component properties used to
      configure the reference. If not specified the name of the reference will
      be derived from the fully qualified class name of the class defining the
      reference injection point and the reference injection point.</para>

      <para>The production for generated names is:</para>

      <programlisting>name   ::= prefix '.' suffix
prefix ::= named | qname
named  ::= &lt; @Named.value &gt;
suffix ::= field | ctor | method
field  ::= &lt; name of field &gt;
ctor   ::= 'new' pIndex
method ::= mName pIndex
mName  ::= &lt; method name &gt;
pIndex ::= &lt; index of @Reference parameter &gt;</programlisting>

      <para>It is a definition error to have two references with the same
      name.</para>

      <para>It is a definition error to specify the
      <code>@javax.inject.Named</code> annotation with no value.</para>

      <para>In the following example the reference name is
      <code>example.Fido.mate</code> and the target and minimum cardinality
      properties of the reference will be
      <code>example.Fido.mate.target</code> and
      <code>example.Fido.mate.cardinality.minimum</code> respectively:</para>

      <programlisting>package example;

@SingleComponent
class Fido {
	@Inject
	@Reference
	Dog mate;
}</programlisting>

      <para>In the following example the reference name is <code>foo</code>
      and the target and minimum cardinality properties of the reference will
      be <code>foo.target</code> and <code>foo.cardinality.minimum</code>
      respectively:</para>

      <programlisting>package example;

@SingleComponent
class Fido {
	@Inject
	@Named("foo")
	@Reference
	Dog mate;
}</programlisting>
    </section>

    <section>
      <title>Static References</title>

      <para>Static references are the most common form of reference injection
      point. Static means that their values do not change during the lifetime
      of the component instance which means that in order to change the
      service bound to the reference injection point, the entire component
      instance must be destroyed and recreated.</para>

      <para>The following are more examples of static reference injection
      points:</para>

      <programlisting>@Inject
@Reference
Dog dog;

@Inject
@Reference(BassetHound.class)
Map&lt;String, Object&gt; props;

@Inject
void setHounds(@Reference BeanServiceObjects&lt;Hound&gt; hounds) {...}

@Inject
@Reference
ServiceReference&lt;Spot&gt; spot;</programlisting>

      <para>Static reference injection points are
      <emphasis>mandatory</emphasis> by default. They require a number of
      services equal to or greater than their minimum cardinality to be
      available in order for the component instance to resolve.</para>
    </section>

    <section xml:id="service.cdi-reference.optional">
      <title>Static Optional References</title>

      <para>Optional reference injection points allow a component instance to
      become resolved when fewer matching services are found than required by
      the reference's minimum cardinality. The injection point type must be
      <code>java.util.Optional&lt;R&gt;</code> where <code>R</code> is one of
      the <link
      linkend="service.cdi-reference.injection.point.types">supported
      reference injection point types</link>.</para>

      <para>The following are examples of static optional references:</para>

      <programlisting>@Inject
@Reference
Optional&lt;Dog&gt; dog;

@Inject
@Reference(BassetHound.class)
Optional&lt;Map&lt;String, Object&gt;&gt; props;

@Inject
void setHounds(@Reference Optional&lt;BeanServiceObjects&lt;Hound&gt;&gt; hounds) {...}

@Inject
@Reference
Optional&lt;ServiceReference&lt;Spot&gt;&gt; spot;</programlisting>

      <para>As with other static references, static means that their values do
      not change during the lifetime of the component instance which means
      that in order to change the service bound to the reference injection
      point, the entire component instance must be destroyed and
      recreated.</para>
    </section>

    <section xml:id="service.cdi-reference.multi.cardinality">
      <title>Static Multi-cardinality References</title>

      <para>Multi-cardinality references are specified using an injection
      point type of <code>java.util.Collection&lt;R&gt;</code>, or
      <code>java.util.List&lt;R&gt;</code> where <code>R</code> is one of the
      <link linkend="service.cdi-reference.injection.point.types">supported
      reference injection point types</link>. Repeating the static examples as
      multi-cardinality references, we get:</para>

      <programlisting>@Inject
@Reference
List&lt;Dog&gt; dogs;

@Inject
@Reference(BassetHound.class)
Collection&lt;Map&lt;String, Object&gt;&gt; props;

@Inject
void setHounds(@Reference List&lt;BeanServiceObjects&lt;Hound&gt;&gt; hounds) {...}

@Inject
@Reference
Collection&lt;ServiceReference&lt;Spot&gt;&gt; spots;</programlisting>

      <para>Multi-cardinality references are naturally
      <emphasis>optional</emphasis> since the default value of the <link
      linkend="service.cdi-minimum.cardinality.property">minimum cardinality
      property</link> is <code>0</code>. See <xref
      linkend="service.cdi-minimum.cardinality.property"/>.</para>

      <para>As with other static references, static means that their values do
      not change during the lifetime of the component instance which means
      that in order to change the services bound to the reference injection
      point, the entire component instance must be destroyed and
      recreated.</para>
    </section>

    <section xml:id="service.cdi-default.minimum.cardinality">
      <title>Default Minimum Cardinality</title>

      <para>As stated in <xref
      linkend="service.cdi-minimum.cardinality.property"/> every reference has
      a configurable reference property <code>name.cardinality.minimum</code>.
      However, there are cases where it is appropriate to specify a non-zero
      default minimum cardinality. The <xref
      linkend="org.osgi.service.cdi.annotations.MinimumCardinality"/>
      annotation provides this functionality.</para>

      <para>The following is an example of setting the minimum
      cardinality:</para>

      <programlisting>@Inject
@MinimumCardinality(3)
@Reference
List&lt;Dog&gt; guards;</programlisting>

      <para>The value must be a positive integer.</para>

      <para>Specifying this annotation on a unary reference results in a
      definition error.</para>
    </section>

    <section xml:id="service.cdi-reference.dynamic">
      <title>Dynamic References</title>

      <para>Dynamic reference injection points are specified using an
      injection point type of <code>javax.inject.Provider&lt;R&gt;</code>
      where <code>R</code> is one of the <link
      linkend="service.cdi-reference.injection.point.types">supported
      reference injection point types</link>,
      <code>java.util.Optional&lt;R&gt;</code>,
      <code>java.util.Collection&lt;R&gt;</code>, or
      <code>java.util.List&lt;R&gt;</code>.</para>

      <para>The following are examples of dynamic references:</para>

      <programlisting>@Inject
@Reference
Provider&lt;Dog&gt; dog;

@Inject
@Reference(BassetHound.class)
Provider&lt;Collection&lt;Map&lt;String, Object&gt;&gt;&gt; props;

@Inject
void setHounds(
		@Reference
		Provider&lt;List&lt;BeanServiceObjects&lt;Hound&gt;&gt;&gt; hounds
	) {...}

@Inject
@Reference
Provider&lt;Optional&lt;ServiceReference&lt;Spot&gt;&gt;&gt; spots;</programlisting>

      <para>The evaluation of <code>javax.inject.Provider.get()</code> is
      performed such that each invocation may produce a different result
      except for returning <code>null</code>.</para>

      <para>Specifying the <code>@MinimumCardinality</code> annotation with a
      non-zero value on a dynamic, multi-cardinality reference results in the
      component not being resolved until the number of matching services
      becomes equal to or greater than the specified minimum
      cardinality.</para>
    </section>
  </section>

  <section xml:id="service.cdi-interacting.with.service.events">
    <title>Interacting with Service Events</title>

    <para>It is often necessary to observe the addition, modification and
    removal of services from the service registry. This specification provides
    3 special bean types, referred to as <emphasis>binder types</emphasis>,
    which make it possible to bind methods to coordinate across the service
    events of set of services. The type argument <code>S</code> indicates the
    service type expected unless further reduced as described by <xref
    linkend="service.cdi-reference.service.type"/>. Bean Property Types may
    also be used to expand the target filter as defined in <xref
    linkend="service.cdi-bean.property.types.as.target.filters"/>.</para>

    <itemizedlist>
      <listitem>
        <para><link
        linkend="org.osgi.service.cdi.reference.BindService">BindService&lt;S&gt;</link>
        - The <code>BindService</code> bean allows for coordination of service
        events when the service instance is required.</para>
      </listitem>

      <listitem>
        <para><link
        linkend="org.osgi.service.cdi.reference.BindBeanServiceObjects">BindBeanServiceObjects&lt;S&gt;</link>
        - The <code>BindBeanServiceObjects</code> bean allows for coordination
        of service events when bean service objects are required.</para>
      </listitem>

      <listitem>
        <para><link
        linkend="org.osgi.service.cdi.reference.BindServiceReference">BindServiceReference&lt;S&gt;</link>
        - The <code>BindServiceReference</code> bean allows for coordination
        of service events when the service reference is required.</para>
      </listitem>
    </itemizedlist>

    <para>These bean types declare a builder style interface for binding the
    necessary methods to coordinate the events. The following example binds
    service event methods over the set of services whose type is
    <code>Dog</code> and having the service property <code>service.vendor=Acme
    Inc.</code>:</para>

    <programlisting>@Inject
@ServiceVendor("Acme Inc.")
void bindDogs(BindService&lt;Dog&gt; binder) {
	binder.
		adding(this::adding).
		modified(this::modified).
		removed(this::removed).
		bind();
}

void adding(Dog dog, Map&lt;String,Object&gt; properties) {...}
void modified(Dog dog, Map&lt;String,Object&gt; properties) {...}
void removed(Dog dog, Map&lt;String,Object&gt; properties) {...}</programlisting>

    <para>The terminal <code>bind()</code> method must be called to inform CCR
    that the bind process is complete. Binding a subset of methods is allowed.
    Only the last bind method specified for any given service event will be
    used. For example, given the following invocation: <programlisting>@Inject
void bindDogs(BindService&lt;Dog&gt; binder) {
	binder.
		adding(this::addingA).
		adding(this::addingB).
		bind();
}</programlisting> only the method <code>addingB</code> will be used.</para>

    <para>An example of a binder type injected into a field:</para>

    <programlisting>@Inject
void bindDogs(BindBeanServiceObjects&lt;Dog&gt; binder) {
	binder.
		adding(this::adding).
		removed(this::removed).
		bind();
}

void adding(BeanServiceObjects&lt;Dog&gt; dogs) {...}
void removed(BeanServiceObjects&lt;Dog&gt; dogs) {...}</programlisting>

    <para>Binder objects are <code>@Dependent</code> objects and are not
    thread safe. They are intended to be used during the creation phase of
    component beans before the end of the <xref
    linkend="service.cdi-bib.postconstruct"/> method. Executing any binder
    object method after this time will result in unspecified behavior.</para>
  </section>

  <section xml:id="service.cdi-cdi.component.runtime">
    <title>CDI Component Runtime</title>

    <para>CDI Component Runtime (CCR) is the actor that manages the CDI
    containers and their life cycle and allows for their introspection.</para>

    <section xml:id="service.cdi-relationship.to.the.osgi.framework">
      <title>Relationship to the OSGi Framework</title>

      <para>CCR must have access to the Bundle Context of any CDI bundle. CCR
      needs access to the Bundle Context for the following reasons:</para>

      <itemizedlist>
        <listitem>
          <para>To be able to register and get services on behalf of a CDI
          bundle.</para>
        </listitem>

        <listitem>
          <para>To interact with the Configuration Admin on behalf of a CDI
          bundle.</para>
        </listitem>

        <listitem>
          <para>To interact with the Log Service on behalf of a CDI
          bundle.</para>
        </listitem>

        <listitem>
          <para>To make the Bundle Context available for injection in the CDI
          bundle's beans.</para>
        </listitem>
      </itemizedlist>

      <para>CCR should use the <code>Bundle.getBundleContext()</code> method
      to obtain the Bundle Context reference.</para>
    </section>

    <section xml:id="service.cdi-injecting.bundle.context">
      <title>Injecting the Bundle Context</title>

      <para>The Bundle Context of the CDI bundle can be injected. The
      injection point must be of type
      <code>org.osgi.framework.BundleContext</code> and must not specify any
      qualifiers.</para>

      <programlisting>@Inject
BundleContext bundleContext;</programlisting>
    </section>

    <section xml:id="service.cdi-starting.and.stopping.ccr">
      <title>Starting and Stopping CCR</title>

      <para>When CCR is implemented as a bundle, any containers activated by
      CCR must be deactivated when the CCR bundle is stopped. When the CCR
      bundle is started, it must process the CDI metadata declared in CDI
      bundles. This includes bundles which are started and are awaiting lazy
      activation.</para>
    </section>

    <section xml:id="service.cdi-logging.messages">
      <title>Logging Messages</title>

      <para>When CCR must log a message to the Log Service, it must use a
      Logger named using the component's name and associated with the CDI
      bundle. To obtain the Logger object, CCR must call the
      <code>LoggerFactory.getLogger(Bundle bundle, String name, Class
      loggerType)</code> method passing the CDI bundle as the first argument
      and the name of the component as the second argument. If CCR cannot know
      the component name, because the error is not associated with a component
      or the error occurred before the component template is processed, then
      CCR must use the bundle's Root Logger, that is, the Logger named
      <code>ROOT</code>.</para>
    </section>

    <section xml:id="service.cdi-bundle.activator.interaction">
      <title>Bundle Activator Interaction</title>

      <para>A CDI bundle may also declare a Bundle Activator. Such a bundle
      may also be marked for lazy activation. Since CDI containers are
      activated by CCR and Bundle Activators are called by the OSGi Framework,
      a bundle using both a CDI container and a Bundle Activator must take
      care. The Bundle Activator's start method must not rely upon CCR having
      activated the bundle's CDI container. However, the CDI container can
      rely upon the Bundle Activator's start method having been called. That
      is, there is a <emphasis>happens-before</emphasis> relationship between
      the Bundle Activator's start method being run and the CDI container
      being activated.</para>
    </section>

    <section xml:id="service.cdi-introspection">
      <title>Introspection</title>

      <para>CCR provides an introspection API for examining the runtime state
      of the CDI bundles processed by CCR. CCR must register a <xref
      linkend="org.osgi.service.cdi.runtime.CDIComponentRuntime"/> service
      upon startup. The CDI Component Runtime service provides methods to
      inspect CDI containers. The service uses <emphasis>Data Transfer Objects
      (DTO)</emphasis> as arguments and return values. The rules for Data
      Transfer Objects are specified in <xref
      linkend="intro.core.release"/>.</para>

      <para>The CDI Component Runtime service provides the following
      methods.</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.cdi.runtime.CDIComponentRuntime.getContainerDTOs-Bundle...-"/>
          - For each specified bundle, if the bundle is active and processed
          by CCR, and the bundle is a valid CDI bundle, the returned
          collection will contain a <xref
          linkend="org.osgi.service.cdi.runtime.dto.ContainerDTO"/> describing
          the CDI container.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.cdi.runtime.CDIComponentRuntime.getContainerTemplateDTO-Bundle-"/>
          - If the specified bundle is active and processed by CCR, and the
          bundle is a valid CDI bundle, the method will return a <xref
          linkend="org.osgi.service.cdi.runtime.dto.template.ContainerTemplateDTO"/>
          describing the template metadata of the CDI container.</para>
        </listitem>
      </itemizedlist>

      <para>The runtime state of the containers can change at any time. So any
      information returned by these methods only provides a snapshot of the
      state at the time of the method call.</para>

      <para>There are a number of DTOs available via the CDI Component Runtime
      service.</para>

      <figure>
        <title>CDI Component Runtime DTOs</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentwidth="300px"
                       fileref="dto-structure.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <xref
      linkend="org.osgi.service.cdi.runtime.dto.ContainerDTO"/> specifies a
      <code>changeCount</code> field of type <code>long</code>. Whenever the
      DTOs bellow the <code>ContainerDTO</code> change, CCR will increment the
      <code>ContainerDTO</code>'s <xref
      linkend="org.osgi.service.cdi.runtime.dto.ContainerDTO.changeCount"/>.
      Whenever any ContainerDTO changes, CCR will update the
      <code>service.changecount</code> service property of the
      <code>CDIComponentRuntime</code> service. CCR may use a single update to
      the <code>service.changecount</code> property to reflect updates in
      multiple <code>ContainerDTOs</code>. See
      <code>org.osgi.framework.Constants.SERVICE_CHANGECOUNT</code> in <xref
      linkend="intro.core.release" xrefstyle="template:%t"/>.</para>
    </section>

    <section xml:id="service.cdi-logger.support">
      <title>Logger Support</title>

      <para>CCR provides special support for logging via the Log Service
      specification. CCR must provide <code>@Dependent</code> objects of type
      <code>org.osgi.service.log.Logger</code> and
      <code>org.osgi.service.log.FormatterLogger</code>.</para>

      <para>To obtain the Logger object for injection, CCR must call the
      <code>LoggerFactory.getLogger(Bundle bundle, String name, Class
      loggerType)</code> method passing the bundle declaring the component as
      the first argument, the fully qualified name of the injection point's
      declaring class as the second argument, and the type of the injection
      point; <code>org.osgi.service.log.Logger</code> or
      <code>org.osgi.service.log.FormatterLogger</code>, as the third
      argument. The typical usage is:</para>

      <programlisting>@Inject
Logger logger;

@PostConstruct
void init() {
	logger.debug("Initialized");
}</programlisting>

      <para>Another example using method injection along with component
      properties (coerced to <code>Config</code>):</para>

      <programlisting>public static @interface Config {
	String component_name();
}

@Inject
void setup(@ComponentProperties Config config, Logger logger) {
	logger.trace(“Activating component {}”, config.component_name());
}</programlisting>
    </section>

    <section xml:id="service.cdi-disabling.components">
      <title>Disabling Components</title>

      <para>All components in a CDI bundle are enabled by default. However,
      any component can be disabled through configuration using the single
      configuration object associated with the <link
      linkend="service.cdi-container.component.configuration">container
      PID</link> by defining a property using the component name suffixed with
      <code>.enabled</code>. The value's type is <code>boolean</code>.</para>

      <programlisting>enabled  ::= compName '.enabled'
compName ::= &lt; component name &gt;</programlisting>

      <para>The following is an example disabling a component whose name is
      <code>foo</code>:</para>

      <programlisting>foo.enabled=false</programlisting>

      <para>The container component can be disabled using it's component name,
      which is the <emphasis>container id</emphasis>. As a result of disabling
      the container component, all components in the CDI bundle are also
      disabled.</para>
    </section>

    <section xml:id="service.cdi-container.component.and.service.cycles">
      <title>Container Component and Service Cycles</title>

      <para>There is no special support to allow service cycles within the
      <emphasis>container component</emphasis>. CDI provides existing
      mechanisms for wiring and collaborating within the CDI container.
      However, if an container component defines a dynamic, optional
      reference, then a service subsequently provided by the container
      component may satisfy the reference at some point when the container
      component is satisfied. However, if the reference is static and
      mandatory and the only potentially matching service is one provided by
      the container component itself, then the container component would wait
      forever for a service that will never arrive. This is simple design
      error. The information about unsatisfied references is available from
      the <xref linkend="org.osgi.service.cdi.runtime.CDIComponentRuntime"/>
      service.</para>
    </section>
  </section>

  <section xml:id="service.cdi-capabilities">
    <title>Capabilities</title>

    <para>CCR must provide the following capabilities.</para>

    <para>A capability in the <link
    linkend="service.namespaces-osgi.extender.namespace"><code>osgi.extender</code></link>
    namespace declaring an extender with the name <link
    linkend="org.osgi.service.cdi.CDIConstants.CDI_CAPABILITY_NAME">osgi.cdi</link>.
    In addition to the specification packages, this capability must declare a
    uses constraint for the <code>javax.inject</code> package. For
    example:</para>

    <programlisting>Provide-Capability:
	osgi.extender;
		osgi.extender="osgi.cdi";
		version:Version="<xref endterm="org.osgi.service.cdi-version.number"
        linkend="org.osgi.service.cdi"/>";
		uses:="javax.inject, org.osgi.service.cdi, org.osgi.service.cdi.annotations,
			org.osgi.service.cdi.reference, org.osgi.service.cdi.runtime,
			org.osgi.service.cdi.runtime.dto,
			org.osgi.service.cdi.runtime.dto.template"</programlisting>

    <para>This capability must follow the rules defined for the <xref
    linkend="service.namespaces-osgi.extender.namespace"/>.</para>

    <para>A CDI bundle must require the <code>osgi.extender</code> capability
    from CCR. This requirement will wire the bundle to the CCR implementation
    and ensure that CCR is using the same <code>org.osgi.service.cdi.*</code>
    packages as the bundle if the bundle uses those packages.</para>

    <programlisting>Require-Capability:
	osgi.extender;
		filter:="(&amp;(osgi.extender=osgi.cdi)(version&gt;=<xref
        endterm="org.osgi.service.cdi-version.number"
        linkend="org.osgi.service.cdi"/>)(!(version&gt;=2.0)))"</programlisting>

    <para>CCR must only process a CDI bundle if the bundle's wiring has a
    required wire for at least one <code>osgi.extender</code> capability with
    the name <code>osgi.cdi</code> and the first of these required wires is
    wired to CCR.</para>

    <para>When using the annotations <xref
    linkend="org.osgi.service.cdi.annotations.Bean"/> or <xref
    linkend="org.osgi.service.cdi.annotations.Beans"/>, the above requirement
    is automatically added to the manifest when the code is processed by a
    supporting build tool capable of interpreting <emphasis>Bundle
    Annotations</emphasis> defined in <xref
    linkend="intro.core.release"/>.</para>

    <para>The requirement may be specified directly on any class or package in
    the CDI bundle by using the <xref
    linkend="org.osgi.service.cdi.annotations.RequireCDIExtender"/> annotation
    when the code is processed by a supporting build tool capable of
    interpreting <emphasis>Bundle Annotations</emphasis> defined in <xref
    linkend="intro.core.release"/>.</para>

    <para><emphasis role="strong">Specifying CDI bean descriptors</emphasis> -
    As specified in <xref linkend="service.cdi-bean.descriptors"/> a CDI
    bundle must declare all CDI bean descriptors CCR is expected to operate
    on. This is done by adding the attribute <code>descriptor</code>, of type
    <code>List&lt;String&gt;</code>, to the requirement.</para>

    <para><emphasis role="strong">Specifying the list of bean
    classes</emphasis> - As specified in <xref
    linkend="service.cdi-bean.discovery"/> a CDI bundle must declare all bean
    classes CCR is expected to operate on. This is done by adding the
    attribute <code>beans</code>, of type <code>List&lt;String&gt;</code>, to
    the requirement.</para>

    <para>A capability in the <link
    linkend="service.namespaces-osgi.implementation.namespace"><code>osgi.implementation</code></link>
    namespace declaring an implementation with the name <link
    linkend="org.osgi.service.cdi.CDIConstants.CDI_CAPABILITY_NAME">osgi.cdi</link>.
    In addition to the specification packages, this capability must also
    declare a uses constraint for the <code>javax.enterprise.*</code>
    packages. For example:</para>

    <programlisting>Provide-Capability:
	osgi.implementation;
		osgi.implementation="osgi.cdi";
		version:Version="<xref endterm="org.osgi.service.cdi-version.number"
        linkend="org.osgi.service.cdi"/>";
		uses:="javax.enterprise.context, javax.enterprise.context.control,
			javax.enterprise.context.spi, javax.enterprise.event,
			javax.enterprise.inject, javax.enterprise.inject.literal,
			javax.enterprise.inject.spi, javax.enterprise.inject.spi.configurator,
			javax.enterprise.util, org.osgi.service.cdi,
			org.osgi.service.cdi.annotations,
			org.osgi.service.cdi.reference, org.osgi.service.cdi.runtime,
			org.osgi.service.cdi.runtime.dto,
			org.osgi.service.cdi.runtime.dto.template"</programlisting>

    <para>This capability must follow the rules defined for the <xref
    linkend="service.namespaces-osgi.implementation.namespace"/>.</para>

    <para>A capability in the <link
    linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
    namespace representing the <xref
    linkend="org.osgi.service.cdi.runtime.CDIComponentRuntime"/> service. This
    capability must also declare a uses constraint for the
    <code>org.osgi.service.cdi.runtime</code> package. For example:</para>

    <programlisting>Provide-Capability:
	osgi.service;
		objectClass:List&lt;String&gt;=
			"org.osgi.service.cdi.runtime.CDIComponentRuntime";
		uses:="org.osgi.service.cdi.runtime"</programlisting>

    <para>This capability must follow the rules defined for the <xref
    linkend="service.namespaces-osgi.service.namespace"/>.</para>

    <para>A capability in the <link
    linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
    namespace for every service declared by the metadata in the CDI
    bundle.</para>
  </section>

  <section xml:id="service.cdi-relationship.to.cdi.features">
    <title>Relationship to CDI features</title>

    <para>CDI has many features which may occasionally interact with the OSGi
    CDI integrations defined by this specification.</para>

    <section xml:id="service.cdi-bean.descriptors">
      <title>Bean Descriptors</title>

      <para>The <xref linkend="service.cdi-bib.cdi.packaging.and.deployment"/>
      chapter of the CDI specification defines XML descriptors which are used
      to control the CDI container. This specification expects that these
      descriptors be declared using the <code>osgi.cdi</code> extender
      requirement attribute <code>descriptor</code> of type
      <code>List&lt;String&gt;</code>. For example:</para>

      <programlisting>Require-Capability:
	osgi.extender;
		filter:=”(&amp;(osgi.extender=osgi.cdi)(version&gt;=<xref
          endterm="org.osgi.service.cdi-version.number"
          linkend="org.osgi.service.cdi"/>)(!(version&gt;=2.0.0)))”;
		descriptor:List&lt;String&gt;="META-INF/beans.xml"</programlisting>

      <para>If the attribute is not specified the default value of
      <code>META-INF/beans.xml</code> is used.</para>

      <para>CCR must find descriptors by calling
      <code>Bundle.getResources(String)</code> for each specified value. Note
      that the accepted syntax for the values is the same as for
      <code>java.lang.ClassLoader.getResources</code>. See <link
      linkend="service.cdi-capabilities"><code>osgi.cdi</code> extender
      capability</link>.</para>
    </section>

    <section xml:id="service.cdi-bean.discovery">
      <title>Bean Discovery</title>

      <para>The CDI specification defines 3 bean discover modes which perform
      runtime class discovery:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>all</emphasis> - All classes in the jar are passed
          to the CDI container and processed.</para>
        </listitem>

        <listitem>
          <para><emphasis>none</emphasis> - No classes in the jar are passed
          to the CDI container. It is assumed however that <emphasis>portable
          extensions</emphasis> may yet provide beans.</para>
        </listitem>

        <listitem>
          <para><emphasis>annotated</emphasis> (default) - Only classes
          matching the definition of <emphasis>annotated beans</emphasis> as
          defined by the <xref
          linkend="service.cdi-bib.cdi.default.bean.discovery.mode"
          xrefstyle="hyperlink"/> are passed to the CDI container and
          processed.</para>
        </listitem>
      </itemizedlist>

      <para>This specification avoids runtime class analysis concern by
      ignoring the bean discovery mode specified or implied by the
      descriptors, requiring bean classes to be pre-calculated at build time
      such that the CDI container receives a concrete list of classes to
      process.</para>

      <para>It is expected that the aforementioned bean discover modes be
      implemented in build tooling and be performed at build time.</para>

      <para>A CDI bundle must specify the list of classes to process using the
      <code>osgi.cdi</code> extender requirement attribute <code>beans</code>
      of type <code>List&lt;String&gt;</code>. For example:</para>

      <programlisting>Require-Capability:
	osgi.extender;
		filter:=”(&amp;(osgi.extender=osgi.cdi)(version&gt;=<xref
          endterm="org.osgi.service.cdi-version.number"
          linkend="org.osgi.service.cdi"/>)(!(version&gt;=2.0.0)))”;
		beans:List&lt;String&gt;="org.foo.Bar, org.foo.baz.Fum"</programlisting>

      <para>See <link linkend="service.cdi-capabilities"><code>osgi.cdi</code>
      extender capability</link>.</para>

      <section>
        <title>Build tool support</title>

        <para>The bean descriptors specified by the CDI specification allow
        for narrowing the range of processed classes by defining <xref
        linkend="service.cdi-bib.cdi.exclude.filters" xrefstyle="hyperlink"/>.
        While these filters are still considered, they are only applied over
        the concrete list of classes passed from the <code>beans</code>
        attribute.</para>

        <para>Build tools may opt to implement bean discover modes.
        Implementing the discovery mode <emphasis>all</emphasis> simply
        requires placing the names of all classes found in the bundle in the
        <code>beans</code> attribute. Implementing the discovery mode
        <emphasis>annotated</emphasis> involves collecting the names of all
        classes matching the definition of <emphasis>annotated
        beans</emphasis> as defined by the <xref
        linkend="service.cdi-bib.cdi.default.bean.discovery.mode"
        xrefstyle="hyperlink"/> and placing those in the <code>beans</code>
        attribute.</para>

        <para>Another option is to use the <code>CLASS</code> retention
        annotation defined by this specification.</para>

        <para>The <code>CLASS</code> retention annotation <xref
        linkend="org.osgi.service.cdi.annotations.Bean"/> may be applied to a
        class to indicate to supporting build tools it must be included in the
        <code>beans</code> list.</para>

        <para>The <code>CLASS</code> retention annotation <xref
        linkend="org.osgi.service.cdi.annotations.Beans"/> may be applied to a
        package to indicate to supporting build tools that all classes in the
        package must be included in the <code>beans</code> list.</para>

        <para>Specifying a <xref
        linkend="org.osgi.service.cdi.annotations.Beans.value--"/> indicates
        to supporting build tools that the specified classes in the package
        must be included in the <code>beans</code> list.</para>
      </section>
    </section>

    <section xml:id="service.cdi-portable.extensions">
      <title>Portable Extensions</title>

      <para>CDI Portable Extensions use CDI's SPI which provides a powerful
      mechanism for extending the base functionality of CDI. Portable
      extensions may add, modify or read bean and bean class metadata, define
      custom contexts, and much more. Through the SPI a portable extension can
      participate in all aspects of the CDI Container's life cycle.</para>

      <para>Portable extensions must be provided as OSGi services using the
      interface <code>javax.enterprise.inject.spi.Extension</code>. Portable
      extension services must specify the service property
      <code>osgi.cdi.extension</code> whose value is a name identifying the
      functionality provided by the portable extension.</para>

      <table>
        <title>Portable Extension Service Properties</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="2*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="2*"/>

          <thead>
            <row>
              <entry>Service Property</entry>

              <entry>Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>osgi.cdi.extension</code></entry>

              <entry><para>String</para></entry>

              <entry><para>The name of the Portable Extension</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example, a portable extension service that provides an
      implementation of the <xref linkend="service.cdi-bib.jta"/> should
      specify the value of it's <code>osgi.cdi.extension</code> service
      property using the <xref
      linkend="service.cdi-bib.portable.java.contract" xrefstyle="hyperlink"/>
      name specified for it, which is <code>JavaJTA</code>.</para>

      <para>Portable Extension bundles must define a capability using the
      namespace <code>osgi.cdi.extension</code> having an attribute
      <code>osgi.cdi.extension</code> whose value is the same as the name
      specified in the <code>osgi.cdi.extension</code> service property of the
      portable extension service. The capability must also specify a
      <code>version</code> attribute of type <code>Version</code>. The
      capability must also specify a <code>uses</code> directive listing all
      of the Java packages provided as part of the Portable Extension's API.
      If the portable extension implements an API specified as a Portable Java
      Contract the uses list should match the Portable Java Contract.</para>

      <programlisting>Provide-Capability:
	osgi.cdi.extension;
		osgi.cdi.extension=JavaJTA;
		version:Version="1.2";
		uses:="javax.transaction,javax.transaction.xa"
		</programlisting>

      <para>CDI bundles express a dependency on a portable extension by
      specifying a requirement in the <code>osgi.cdi.extension</code>
      namespace whose <code>filter</code> matches a portable extension
      capability. For example:</para>

      <programlisting>Require-Capability:
	osgi.cdi.extension;
		filter:=”(&amp;(osgi.cdi.extension=JavaJTA)(version=1.2))”;</programlisting>

      <para>See <link linkend="service.cdi-capabilities"><code>osgi.cdi</code>
      extender capability</link>.</para>

      <para>A Portable extension bundle must require the
      <code>osgi.implementation</code> capability from CCR. This requirement
      will wire the extension bundle to the CCR implementation and ensure that
      CCR is using the same <code>javax.enterprise.*</code> packages as the
      portable extension bundle.</para>

      <programlisting>Require-Capability:
	osgi.implementation;
		filter:="(&amp;(osgi.implementation=osgi.cdi)(version&gt;=<xref
          endterm="org.osgi.service.cdi-version.number"
          linkend="org.osgi.service.cdi"/>)(!(version&gt;=2.0)))"</programlisting>

      <para>The requirement may be specified directly on any class in the
      portable extension bundle by using the <xref
      linkend="org.osgi.service.cdi.annotations.RequireCDIImplementation"/>
      annotation when the code is processed by tooling capable of interpreting
      <emphasis>Bundle Annotations</emphasis> defined in <xref
      linkend="intro.core.release"/>.</para>

      <section xml:id="service.cdi-portable.extension.services.and.beans">
        <title>Portable Extension Services and Beans</title>

        <para>Portable extension bundles intending to provide additional beans
        must do so programmatically using the SPI. Bean descriptors in the
        bundle providing the portable extension service are not visible to the
        CDI container and therefore play no role in bean discovery.</para>
      </section>

      <section xml:id="service.cdi-embedded.portable.extensions">
        <title>Embedded Portable Extension</title>

        <para>Portable extensions which are embedded in the CDI bundle are
        discoverable through the CDI specified <emphasis>service
        loader</emphasis> mechanism using the class loader of the CDI
        bundle.</para>
      </section>
    </section>

    <section xml:id="service.cdi-bean.manager">
      <title>Bean Manager</title>

      <para>When the container component is satisfied CCR must published the
      CDI container's <code>javax.enterprise.inject.spi.BeanManager</code> to
      the service registry using the <code>ServiceContext</code> of the CDI
      bundle accompanied by the following service property:</para>

      <table>
        <title>Bean Manager Service Properties</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="2*"/>

          <colspec colnum="2" colwidth="1*"/>

          <colspec colnum="3" colwidth="2*"/>

          <thead>
            <row>
              <entry>Service Property</entry>

              <entry>Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>osgi.cdi.container.id</code></entry>

              <entry><para>String</para></entry>

              <entry><para>The container id. The constant <code><xref
              linkend="org.osgi.service.cdi.CDIConstants.CDI_CONTAINER_ID_PROPERTY"/></code>
              exists for convenience. See <xref
              linkend="service.cdi-container.component"/>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <code>javax.enterprise.inject.spi.BeanManager</code> must be
      unregistered when the container component becomes unsatisfied.</para>
    </section>

    <section xml:id="service.cdi-decorators.and.interceptors">
      <title>Decorators and Interceptors</title>

      <para>Decorators and Interceptors are used to wrap contextual instances
      with proxies to deliver additional, targeted functionality. However,
      these features do not support <xref
      linkend="service.cdi-bib.unproxyable"/>. Attempting to apply either
      feature to a bean or producer having an unproxyable bean type will
      result in a definition error. This limitation extends to CCR where
      applicable. The <code>@javax.enterprise.inject.Typed</code> annotation
      is available to explicitly reduce the set of bean types, making it
      possible to use either feature on beans having unproxyable types.
      Implementations of this specification must support the use of
      <code>@javax.enterprise.inject.Typed</code> when publishing
      services.</para>

      <para>Service objects are the product of beans and producers. As such
      they may be targeted by Decorators and/or Interceptors and wrapped by
      proxies. Therefore the subset of types under which the service is
      published must be a subset of the bean types, including further
      restrictions declared by <code>@javax.enterprise.inject.Typed</code>.
      Service types not contained in the restricted set of bean types will
      result in a definition error. See <xref
      linkend="service.cdi-service.restrictions"/>.</para>
    </section>
  </section>

  <section xml:id="service.cdi-security">
    <title>Security</title>

    <para>When Java permissions are enabled, CCR must perform the following
    security procedures.</para>

    <section>
      <title>Service Permissions</title>

      <para>CCR dependencies are built upon the existing OSGi service
      infrastructure. This means that Service Permission applies regarding the
      ability to publish, find or bind services.</para>

      <para>If a component specifies a service, that component cannot be
      satisfied unless the CDI bundle has
      <code>ServicePermission[&lt;provides&gt;, REGISTER]</code> for each
      provided interface specified for the service.</para>

      <para>If a component's reference does not specify optional cardinality,
      the reference cannot be satisfied unless the CDI bundle has
      <code>ServicePermission[&lt;interface&gt;, GET]</code> for the specified
      interface in the reference. If the reference specifies optional
      cardinality but the component's bundle does not have
      <code>ServicePermission[&lt;interface&gt;, GET]</code> for the specified
      interface in the reference, no service must be bound for this
      reference.</para>

      <para>CCR must have <code>ServicePermission[CDIComponentRuntime,
      REGISTER]</code> permission to register the <xref
      linkend="org.osgi.service.cdi.runtime.CDIComponentRuntime"/> service.
      Administrative bundles wishing to use the <xref
      linkend="org.osgi.service.cdi.runtime.CDIComponentRuntime"/> service
      must have <code>ServicePermission[CDIComponentRuntime, GET]</code>
      permission. In general, this permission should only be granted to
      administrative bundles to limit access to the potentially intrusive
      methods provided by this service.</para>
    </section>

    <section>
      <title>Required Admin Permission</title>

      <para>CCR requires <code>AdminPermission[*,CONTEXT]</code> because it
      needs access to the CDI bundle's Bundle Context object with the
      <code>Bundle.getBundleContext()</code> method.</para>
    </section>

    <section>
      <title>Using hasPermission</title>

      <para>CCR does all publishing, finding and binding of services on behalf
      of the component using the Bundle Context of the CDI bundle. This means
      that normal stack-based permission checks will check CCR and not the
      component's bundle. Since CCR is registering and getting services on
      behalf of a CDI bundle, CCR must call the
      <code>Bundle.hasPermission</code> method to validate that a CDI bundle
      has the necessary permission to register or get a service.</para>
    </section>

    <section xml:id="service.cdi-multi.location.regions">
      <title>Configuration Multi-Locations and Regions</title>

      <para>CCR must ensure a bundle has the proper
      <code>ConfigurationPermission</code> for a Configuration used by its
      components when the Configuration has a multi-location. See <xref
      linkend="service.cm-multi.locations"/> for more information on
      multi-locations and <xref linkend="service.cm-regions"/> for more
      information on regions. If a bundle does not have the necessary
      permission for a multi-location Configuration, then CCR must act as if
      the Configuration does not exist for the bundle.</para>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cdi.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cdi.annotations.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cdi.propertytypes.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cdi.reference.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cdi.runtime.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cdi.runtime.dto.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cdi.runtime.dto.template.xml"/>

  <section xml:id="service.cdi-references">
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="service.cdi-bib.cdi"><title>CDI</title> <biblioid
      class="uri"><link
      xlink:href="https://www.cdi-spec.org/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.cdi-bib.cdi20"><title>CDI 2.0</title>
      <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.cdi-bib.unproxyable"><title>unproxyable
      bean types</title> <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#unproxyable"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.cdi-bib.cdi.default.bean.discovery.mode"><title>Default
      bean discovery mode</title> <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#default_bean_discovery"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.cdi-bib.cdi.exclude.filters"><title>Exclude
      filters</title> <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#exclude_filters"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.cdi-bib.cdi.packaging.and.deployment"><title>Packaging
      and deployment</title> <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#packaging_deployment"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.cdi-bib.cdi.typesafe.resolution"><title>Typesafe
      Resolution</title> <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#typesafe_resolution"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.cdi-bib.cdi.scopes.and.contexts"><title>Scopes and
      contexts</title> <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#contexts"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.cdi-bib.cdi.pseudoscope"><title>Pseudo-scope</title>
      <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#normal_scope"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.cdi-bib.postconstruct"><title>@PostConstruct</title>
      <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/annotations/1.3/apidocs/javax/annotation/postconstruct"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.cdi-bib.general.syntax.definitions"><title>General
      Syntax Definitions</title>OSGi Core, General Syntax
      Definitions</bibliomixed>

      <bibliomixed xml:id="service.cdi-bib.filter.syntax"><title>Filter
      Syntax</title>OSGi Core, Filter Syntax</bibliomixed>

      <bibliomixed xml:id="service.cdi-bib.inject"><title>Dependency Injection
      for Java</title> <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/dependency-injection/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.cdi-bib.jta"><title>Java Transaction
      API</title> <biblioid class="uri"><link
      xlink:href="https://jakarta.ee/specifications/transactions/"/></biblioid></bibliomixed>

      <bibliomixed
      xml:id="service.cdi-bib.portable.java.contract"><title>Portable Java
      Contract</title> <biblioid class="uri"><link
      xlink:href="https://docs.osgi.org/reference/portable-java-contracts.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="service.cdi-bib.jls.ref"><title>The Java Language
      Specification, Java SE 8 Edition</title> <biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
