<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->
<chapter label="104"
         revision="$Id$"
         version="5.0" xml:id="service.cm"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Configuration Admin Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.cm-version"
    linkend="org.osgi.service.cm"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The Configuration Admin service is an important aspect of the
    deployment of an OSGi framework. It allows an Operator to configure
    deployed bundles. Configuring is the process of defining the configuration
    data for bundles and assuring that those bundles receive that data when
    they are active in the OSGi framework.</para>

    <figure>
      <title>Configuration Admin Service Overview</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.049in"
                     contentwidth="4.917in" fileref="cm-classes.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Essentials</title>

      <para>The following requirements and patterns are associated with the
      Configuration Admin service specification:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Local Configuration</emphasis> - The Configuration
          Admin service must support bundles that have their own user
          interface to change their configurations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Reflection</emphasis> - The Configuration Admin
          service must be able to deduce the names and types of the needed
          configuration data.</para>
        </listitem>

        <listitem>
          <para><emphasis>Legacy</emphasis> - The Configuration Admin service
          must support configuration data of existing entities (such as
          devices).</para>
        </listitem>

        <listitem>
          <para><emphasis>Object Oriented</emphasis> - The Configuration Admin
          service must support the creation and deletion of instances of
          configuration information so that a bundle can create the
          appropriate number of services under the control of the
          Configuration Admin service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Embedded Devices</emphasis> - The Configuration
          Admin service must be deployable on a wide range of platforms. This
          requirement means that the interface should not assume file storage
          on the platform. The choice to use file storage should be left to
          the implementation of the Configuration Admin service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Remote versus Local Management</emphasis> - The
          Configuration Admin service must allow for a remotely managed OSGi
          framework, and must not assume that con-figuration information is
          stored locally. Nor should it assume that the Configuration Admin
          service is always done remotely. Both implementation approaches
          should be viable.</para>
        </listitem>

        <listitem>
          <para><emphasis>Availability</emphasis> - The OSGi environment is a
          dynamic environment that must run continuously (24/7/365).
          Configuration updates must happen dynamically and should not require
          restarting of the system or bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Immediate Response</emphasis> - Changes in
          configuration should be reflected immediately.</para>
        </listitem>

        <listitem>
          <para><emphasis>Execution Environment</emphasis> - The Configuration
          Admin service will not require more than an environment that
          fulfills the minimal execution requirements.</para>
        </listitem>

        <listitem>
          <para><emphasis>Communications</emphasis> - The Configuration Admin
          service should not assume "always-on" connectivity, so the API is
          also applicable for mobile applications in cars, phones, or
          boats.</para>
        </listitem>

        <listitem>
          <para><emphasis>Extendability</emphasis> - The Configuration Admin
          service should expose the process of configuration to other bundles.
          This exposure should at a minimum encompass initiating an update,
          removing certain configuration properties, adding properties, and
          modifying the value of properties potentially based on existing
          property or service values.</para>
        </listitem>

        <listitem>
          <para><emphasis>Complexity Trade-offs</emphasis> - Bundles in need
          of configuration data should have a simple way of obtaining it. Most
          bundles have this need and the code to accept this data.
          Additionally, updates should be simple from the perspective of the
          receiver.</para>

          <para>Trade-offs in simplicity should be made at the expense of the
          bundle implementing the Configuration Admin service and in favor of
          bundles that need configuration information. The reason for this
          choice is that normal bundles will outnumber Configuration Admin
          bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Regions</emphasis> - It should be possible to create
          groups of bundles and a manager in a single system that share
          configuration data that is not accessible outside the region.</para>
        </listitem>

        <listitem>
          <para><emphasis>Shared Information</emphasis> - It should be
          possible to share configuration data between bundles.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Configuration information</emphasis> - The
          information needed by a bundle before it can provide its intended
          functionality.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration dictionary</emphasis> - The
          configuration information when it is passed to the target service.
          It consists of a <code>Dictionary</code> object with a number of
          properties and identifiers.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuring Bundle</emphasis> - A bundle that
          modifies the configuration information through the Configuration
          Admin service. This bundle is either a management bundle or the
          bundle for which the configuration information is intended.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration Target</emphasis> - The target service
          that will receive the configuration information. For services, there
          are two types of targets: <code>ManagedServiceFactory</code> or
          <code>ManagedService</code> objects.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration Admin Service</emphasis> - This
          service is responsible for supplying configuration target bundles
          with their configuration information. It maintains a database with
          configuration information, keyed on the <code>service.pid</code> of
          configuration target services. These services receive their
          configuration dictionary/dictionaries when they are registered with
          the Framework. Configurations can be modified or extended using
          Configuration Plugin services before they reach the target
          bundle.</para>
        </listitem>

        <listitem>
          <para><emphasis>Managed Service</emphasis> - A Managed Service
          represents a client of the Configuration Admin service, and is thus
          a configuration target. Bundles should register a Managed Service to
          receive the configuration data from the Configuration Admin service.
          A Managed Service adds one or more unique <code>service.pid</code>
          service properties as a primary key for the configuration
          information.</para>
        </listitem>

        <listitem>
          <para><emphasis>Managed Service Factory</emphasis> - A Managed
          Service Factory can receive a number of configuration dictionaries
          from the Configuration Admin service, and is thus also a
          configuration target service. It should register with one or more
          <code>service.pid</code> strings and receives zero or more
          configuration dictionaries. Each dictionary has its own PID that is
          distinct from the factory PID.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration Object</emphasis> - Implements the
          <code>Configuration</code> interface and contains the configuration
          dictionary for a Managed Service or one of the configuration
          dictionaries for a Managed Service Factory. These objects are
          manipulated by configuring bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration Plugin Services</emphasis> -
          Configuration Plugin services are called before the configuration
          dictionary is given to the configuration targets. The plug-in can
          modify the configuration dictionary, which is passed to the
          Configuration Target.</para>
        </listitem>
      </itemizedlist>

      <figure xml:id="i1817860">
        <title>Overall Service Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.962in"
                       contentwidth="6.230in" fileref="overall.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Synopsis</title>

      <para>This specification is based on the concept of a Configuration
      Admin service that manages the configuration of an OSGi framework. It
      maintains a database of <code>Configuration</code> objects, locally or
      remotely. This service monitors the service registry and provides
      configuration information to services that are registered with a
      <code>service.pid</code> property, the Persistent IDentity (PID), and
      implement one of the following interfaces:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Managed Service</emphasis> - A service registered
          with this interface receives its <emphasis>configuration
          dictionary</emphasis> from the database or receives
          <code>null</code> when no such configuration exists.</para>
        </listitem>

        <listitem>
          <para><emphasis>Managed Service Factory</emphasis> - Services
          registered with this interface can receive several configuration
          dictionaries when registered. The database contains zero or more
          configuration dictionaries for this service. Each configuration
          dictionary is given sequentially to the service.</para>
        </listitem>
      </itemizedlist>

      <para>The database can be manipulated either by the Management Agent or
      bundles that configure themselves. Other parties can provide
      Configuration Plugin services. Such services participate in the
      configuration process. They can inspect the configuration dictionary and
      modify it before it reaches the target service.</para>
    </section>
  </section>

  <section xml:id="i1358725">
    <title>Configuration Targets</title>

    <para>One of the more complicated aspects of this specification is the
    subtle distinction between the <code>ManagedService</code> and
    <code>ManagedServiceFactory</code> classes. Both receive configuration
    information from the Configuration Admin service and are treated similarly
    in most respects. Therefore, this specification refers to
    <emphasis>configuration targets</emphasis> or simply
    <emphasis>targets</emphasis> when the distinction is irrelevant.</para>

    <para>The difference between these types is related to the cardinality of
    the configuration dictionary. A Managed Service is used when an existing
    entity needs a configuration dictionary. Thus, a one-to-one relationship
    always exists between the configuration dictionary and the configurable
    entity in the Managed Service. There can be multiple Managed Service
    targets registered with the same PID but a Managed Service can only
    configure a single entity in each given Managed Service.</para>

    <para>A Managed Service Factory is used when part of the configuration is
    to define <emphasis>how many instances are required</emphasis> for a given
    Managed Service Factory. A management bundle can create, modify, and
    delete any number of instances for a Managed Service Factory through the
    Configuration Admin service. Each instance is configured by a single
    <code>Configuration</code> object. Therefore, a Managed Service Factory
    can have multiple associated <code>Configuration</code> objects.</para>

    <figure>
      <title>Differentiation of ManagedService and ManagedServiceFactory
      Classes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.205in"
                     contentwidth="4.917in" fileref="ms-v-msf.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>A Configuration target updates the target when the underlying
    Configuration object is created, updated, or deleted. However, it is not
    called back when the Configuration Admin service is shutdown or the
    service is ungotten.</para>

    <para>To summarize:</para>

    <itemizedlist>
      <listitem>
        <para>A <emphasis>Managed Service</emphasis> must receive a single
        configuration dictionary when it is registered or when its
        configuration is modified.</para>
      </listitem>

      <listitem>
        <para>A <emphasis>Managed Service Factory</emphasis> must receive from
        zero to <emphasis>n</emphasis> configuration dictionaries when it
        registers, depending on the current configuration. The Managed Service
        Factory is informed of configuration dictionary changes:
        modifications, creations, and deletions.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="i1233800">
    <title>The Persistent Identity</title>

    <para>A crucial concept in the Configuration Admin service specification
    is the Persistent IDentity (PID) as defined in the Framework's service
    layer. Its purpose is to act as a primary key for objects that need a
    configuration dictionary. The name of the service property for PID is
    defined in the Framework in
    <code>org.osgi.framework.Constants.SERVICE_PID</code>.</para>

    <para>The Configuration Admin service requires the use of one or more PIDs
    with Managed Service and Managed Service Factory registrations because it
    associates its configuration data with PIDs.</para>

    <para>A service can register with multiple PIDs and PIDs can be shared
    between multiple targets (both Managed Service and Managed Service Factory
    targets) to receive the same information. If PIDs are to be shared between
    Bundles then the location of the Configuration must be a multi-location,
    see <xref linkend="service.cm-location.binding"/>.</para>

    <para>The Configuration Admin must track the configuration targets on
    their actual PID. That is, if the <code>service.pid</code> service
    property is modified then the Configuration Admin must treat it as if the
    service was unregistered and then re-registered with the new PID.</para>

    <section>
      <title>PID Syntax</title>

      <para>PIDs are intended for use by other bundles, not by people, but
      sometimes the user is confronted with a PID. For example, when
      installing an alarm system, the user needs to identify the different
      components to a wiring application. This type of application exposes the
      PID to end users.</para>

      <para>PIDs should follow the symbolic-name syntax, which uses a very
      restricted character set. The following sections define some schemes for
      common cases. These schemes are not required, but bundle developers are
      urged to use them to achieve consistency.</para>

      <section>
        <title>Local Bundle PIDs</title>

        <para>As a convention, descriptions starting with the bundle identity
        and a full stop (<code>'.' \u002E</code>) are reserved for a bundle.
        As an example, a PID of <code>"65.536"</code> would belong to the
        bundle with a bundle identity of 65.</para>
      </section>

      <section>
        <title>Software PIDs</title>

        <para>Configuration target services that are singletons can use a Java
        package name they own as the PID (the reverse domain name scheme) as
        long as they do not use characters outside the basic ASCII set. As an
        example, the PID named <code>com.acme.watchdog</code> would represent
        a Watchdog service from the ACME company.</para>
      </section>

      <section>
        <title>Devices</title>

        <para>Devices are usually organized on buses or networks. The identity
        of a device, such as a unique serial number or an address, is a good
        component of a PID. The format of the serial number should be the same
        as that printed on the housing or box, to aid in recognition.</para>

        <table pgwide="1">
          <title>Schemes for Device-Oriented PID Names</title>

          <tgroup cols="4">
            <colspec colnum="1" colwidth="1*"/>

            <colspec colnum="2" colwidth="3*"/>

            <colspec colnum="3" colwidth="4*"/>

            <colspec colnum="4" colwidth="4*"/>

            <thead>
              <row>
                <entry>Bus</entry>

                <entry>Example</entry>

                <entry>Format</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>USB</code></entry>

                <entry><code>USB.0123-0002-9909873</code></entry>

                <entry><para>idVendor (hex 4)</para> <para>idProduct (hex
                4)</para> <para>iSerialNumber (decimal)</para></entry>

                <entry><para>Universal Serial Bus. Use the standard device
                descriptor.</para></entry>
              </row>

              <row>
                <entry><code>IP</code></entry>

                <entry><code>IP.172.16.28.21</code></entry>

                <entry><para>IP nr (dotted decimal)</para></entry>

                <entry><para>Internet Protocol</para></entry>
              </row>

              <row>
                <entry><code>802</code></entry>

                <entry><code>802-00:60:97:00:9A:56</code></entry>

                <entry><para>MAC address with : separators</para></entry>

                <entry><para>IEEE 802 MAC address (Token Ring,
                Ethernet,...)</para></entry>
              </row>

              <row>
                <entry><code>ONE</code></entry>

                <entry><code>ONE.06-00000021E461</code></entry>

                <entry><para>Family (hex 2) and serial number including CRC
                (hex 6)</para></entry>

                <entry><para>1-wire bus of Dallas Semiconductor</para></entry>
              </row>

              <row>
                <entry><code>COM</code></entry>

                <entry><code>COM.krups-brewer-12323</code></entry>

                <entry><para>serial number or type name of
                device</para></entry>

                <entry><para>Serial ports</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section xml:id="service.cm-targeted.pids">
      <title>Targeted PIDs</title>

      <para>PIDs are defined as primary keys for the configuration object; any
      target that uses the PID in its service registration (and has the proper
      permissions if security is on) will receive the configuration associated
      with it, regardless of the bundle that registered the target service.
      Though in general the PID is designed to ignore the bundle, there are a
      number of cases where the bundle becomes relevant. The most typical case
      is where a bundle is available in different versions. Each version will
      request the same PID and will get therefore configured
      identically.</para>

      <para><emphasis>Targeted PIDs</emphasis> are specially formatted PIDs
      that are interpreted by the Configuration Admin service. Targeted PIDs
      work both as a normal Managed Service PID and as a Managed Service
      Factory PID. In the case of factories, the targeted PID is the Factory
      PID since the other PID is chosen by CM for each instance.</para>

      <para>The target PID scopes the applicability of the PID to a limited
      set of target bundles. The syntax of a target pid is:</para>

      <programlisting>target-pid  ::=  PID 
    ( '|' symbolic-name ( '|' version ( '|' location )? )? )?</programlisting>

      <para>Targets never register with a target PID, target PIDs should only
      be used when creating, getting, or deleting a Configuration through the
      Configuration Admin service. The target PID is still the primary key of
      the Configuration and is thus in itself a PID. The distinction is only
      made when the Configuration Admin must update a target service. Instead
      of using the non-target PID as the primary key it must first search if
      there exists a target PID in the Configuration store that matches the
      requested target PID.</para>

      <para>When a target registers and needs to be updated the Configuration
      Admin must first find the Configuration with the <emphasis>best
      matching</emphasis> PID. It must logically take the requested PID,
      append it with the bundle symbolic name, the bundle version, and the
      bundle location. The version must be formatted canonically, that is,
      according to the <code>toString()</code> method of the
      <code>Version</code> class. The rules for best matching are then as
      follows:</para>

      <para>Look for a Configuration, in the given order, with a key
      of:</para>

      <programlisting>    &lt;pid&gt;|&lt;bsn&gt;|&lt;version&gt;|&lt;location&gt;
    &lt;pid&gt;|&lt;bsn&gt;|&lt;version&gt;
    &lt;pid&gt;|&lt;bsn&gt;
    &lt;pid&gt;</programlisting>

      <para>For example:</para>

      <programlisting>    com.example.web.WebConf|com.acme.example|3.2.0|http://www.xyz.com/acme.jar
    com.example.web.WebConf|com.acme.example|3.2.0
    com.example.web.WebConf|com.acme.example
    com.example.web.WebConf</programlisting>

      <para>If a registered target service has a PID that contains a vertical
      line (<code>'|' \u007c</code>) | then the value must be taken as is and
      must not be interpreted as a targeted PID.</para>

      <para>The <code>service.pid</code> configuration property for a targeted
      PID configuration must always be set to the targeted PID. That is, if
      the PID is <code>com.example.web.WebConf</code> and the targeted PID
      <code>com.example.web.WebConf|com.acme.example|3.2.0</code> then the
      property in the Configuration dictionary must be the targeted
      PID.</para>

      <para>If a Configuration with a targeted PID is deleted or a
      Configuration with a new targeted PID is added then all targets that
      would be stale must be reevaluated against the new situation and updated
      accordingly if they are no longer bound against the best matching target
      PID.</para>
    </section>

    <section xml:id="service.cm-extenders.targeted.pids">
      <title>Extenders and Targeted PIDs</title>

      <para>Extenders like Declarative Services use Configurations but bypass
      the general Managed Service or Managed Service Factory method. It is the
      responsibility of these extenders to access the Configurations using the
      targeted PIDs.</para>

      <para>Since getting a Configuration tends to create that Configuration
      it is necessary for these extenders to use the <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.listConfigurations-String-"
      xrefstyle="hyperlink"/> method to find out if a more targeted
      Configuration exists. There are many ways the extender can find the most
      targeted PID. For example, the following code gets the most targeted PID
      for a given bundle.</para>

      <programlisting>String mostTargeted(String key, String pid, Bundle bundle) throws Exception {
    String bsn = bundle.getSymbolicName();
    Version version = bundle.getVersion();
    String location = bundle.getLocation();
    String f = String.format("(|(%1$s=%2$s)(%1$s=%2$s|%3$s)" +
        "(%1$s=%2$s|%3$s|%4$s)(%1$s=%2$s|%3$s|%4$s|%5$s))",
        key, pid, bsn, version, location );

    Configuration[] configurations = cm.listConfigurations(f);
    if (configurations == null)
        return null;

    String largest = null;
    for (Configuration c : configurations) {
        String s = (String) c.getProperties().get(key);
        if ((largest == null) || (largest.length() &lt; s.length()))
            largest = s;
    }
    return largest;
}</programlisting>
    </section>
  </section>

  <section>
    <title>The Configuration Object</title>

    <para>A <code>Configuration</code> object contains the configuration
    dictionary, which is a set of properties that configure an aspect of a
    bundle. A bundle can receive <code>Configuration</code> objects by
    registering a configuration target service with a PID service property.
    See <xref linkend="i1233800"/> for more information about PIDs.</para>

    <para>During registration, the Configuration Admin service must detect
    these configuration target services and hand over their configuration
    dictionary via a callback. If this configuration dictionary is
    subsequently modified, the modified dictionary is handed over to the
    configuration target with the same callback.</para>

    <para>The <code>Configuration</code> object is primarily a set of
    properties that can be updated by a Management Agent, user interfaces on
    the OSGi framework, or other applications. Configuration changes are first
    made persistent, and then passed to the target service via a call to the
    <code>updated</code> method in the <code>ManagedServiceFactory</code> or
    <code>ManagedService</code> class.</para>

    <para>A Configuration object must be uniquely bound to a Managed Service
    or Managed Service Factory. This implies that a bundle must not register a
    Managed Service Factory with a PID that is the same as the PID given to a
    Managed Service.</para>

    <section xml:id="service.cm-location.binding">
      <title>Location Binding</title>

      <para>When a <xref linkend="org.osgi.service.cm.Configuration"
      xrefstyle="hyperlink"/> object is created with either <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.getConfiguration-String-"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.getFactoryConfiguration-String-String-"
      xrefstyle="hyperlink"/>, or <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.createFactoryConfiguration-String-"
      xrefstyle="hyperlink"/>, it becomes <emphasis>bound</emphasis> to the
      location of the calling bundle. This location is obtained with the <xref
      linkend="org.osgi.service.cm.Configuration.getBundleLocation--"
      xrefstyle="hyperlink"/> method.</para>

      <para>Location binding is a security feature that assures that only
      management bundles can modify configuration data, and other bundles can
      only modify their own configuration data. A Security Exception is thrown
      if a bundle does not have <code>ConfigurationPermission[location,
      CONFIGURE]</code>.</para>

      <para>The two argument versions of <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.getConfiguration-String-String-"
      xrefstyle="hyperlink"/> and <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.createFactoryConfiguration-String-String-"
      xrefstyle="hyperlink"/> as well as the three argument version of <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.getFactoryConfiguration-String-String-String-"
      xrefstyle="hyperlink"/> take a location <code>String</code> as their
      last argument. These methods require the correct permission, and they
      create <xref linkend="org.osgi.service.cm.Configuration"
      xrefstyle="hyperlink"/> objects bound to the specified location.</para>

      <para>Locations can be specified for a specific Bundle or use
      <emphasis>multi-locations</emphasis>. For a specific location the
      Configuration location must exactly match the location of the target's
      Bundle. A multi-location is any location that has the following
      syntax:</para>

      <programlisting>multi-location ::= '?' symbolic-name?</programlisting>

      <para>For example</para>

      <programlisting>?com.acme</programlisting>

      <para>The path after the question mark is the <emphasis>multi-location
      name</emphasis>, the multi-location name can be empty if only a question
      mark is specified. Configurations with a multi-location are dispatched
      to any target that has <emphasis>visibility</emphasis> to the
      Configuration. The visibility for a given Configuration <code>c</code>
      depends on the following rules:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Single-Location</emphasis> - If
          <code>c.location</code> is not a multi-location then a Bundle only
          has visibility if the Bundle's location exactly matches
          <code>c.location</code>. In this case there is never a security
          check.</para>
        </listitem>

        <listitem>
          <para><emphasis>Multi-Location</emphasis> - If
          <code>c.location</code> is a multi-location (that is, starts with a
          question mark):</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>Security Off</emphasis> - The Bundle always has
              visibility</para>
            </listitem>

            <listitem>
              <para><emphasis>Security On</emphasis> - The target's Bundle
              must have <code>ConfigurationPermission[ c.location,</code>
              <xref
              linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
              xrefstyle="hyperlink"/> <code> ]</code> as defined by the
              Bundle's <code>hasPermission</code> method. The resource name of
              the permission must include the question mark.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The permission matches on the whole name, including any leading
      <code>?</code>. The <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
      xrefstyle="hyperlink"/> action is only applicable in the multi-location
      scenario since the security is not checked for a single-location. There
      is therefore no point in granting a Bundle a permission with <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
      xrefstyle="hyperlink"/> action for anything but a multi-location
      (starting with a <code>?</code>).</para>

      <para>It is therefore possible to register services with the same PID
      from different bundles. If a multi-location is used then each bundle
      will be evaluated for a corresponding configuration update. If the
      bundle has visibility then it is updated, otherwise it is not.</para>

      <para>If multiple targets must be updated then the order of updating is
      the ranking order of their services.</para>

      <para>If a target loses visibility because the Configuration's location
      changes then it must immediately be deleted from the perspective of that
      target. That is, the target must see a deletion (Managed Service
      Factory) or an update with <code>null</code> (Managed Service). If a
      configuration target gains visibility then the target must see a new
      update with the proper configuration dictionary. However, the associated
      events must not be sent as the underlying Configuration is not actually
      deleted nor modified.</para>

      <para>Changes in the permissions must not initiate a recalculation of
      the visibility. If the permissions are changed this will not become
      visible until one of the other events happen that cause a recalculation
      of the visibility.</para>

      <para>If the location is changed then the Configuration Admin must send
      a <xref
      linkend="org.osgi.service.cm.ConfigurationEvent.CM_LOCATION_CHANGED"
      xrefstyle="hyperlink"/> event to signal that the location has changed.
      It is up to the Configuration Listeners to update their state
      appropriately.</para>
    </section>

    <section>
      <title>Dynamic Binding</title>

      <para>Dynamic binding is available for backward compatibility with
      earlier versions. It is recommended that management agents explicitly
      set the location to a <code>?</code> (a multi-location) to allow
      multiple bundles to share PIDs and not use the dynamic binding facility.
      If a management agent uses ?, it must at least have
      <code>ConfigurationPermission[ ?,</code> <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
      xrefstyle="hyperlink"/> <code> ]</code> when security is on, it is also
      possible to use <code>ConfigurationPermission[ ?*,</code> <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
      xrefstyle="hyperlink"/> <code> ]</code> to not limit the management
      agent. See <xref linkend="service.cm-regions"/> for some examples of
      using the locations in isolation scenarios.</para>

      <para>A <code>null</code> location parameter can be used to create
      <code>Configuration</code> objects that are not yet bound. In this case,
      the Configuration becomes bound to a specific location the first time
      that it is compared to a Bundle's location. If a bundle becomes
      dynamically bound to a Configuration then a <xref
      linkend="org.osgi.service.cm.ConfigurationEvent.CM_LOCATION_CHANGED"
      xrefstyle="hyperlink"/> event must be dispatched.</para>

      <para>When this <emphasis>dynamically bound</emphasis> Bundle is
      subsequently uninstalled, configurations that are bound to this bundle
      must be released. That means that for such <code>Configuration</code>
      object's the bundle location must be set to <code>null</code> again so
      it can be bound again to another bundle.</para>
    </section>

    <section xml:id="service.cm.configuration.properties">
      <title>Configuration Properties</title>

      <para>A configuration dictionary contains a set of properties in a
      <code>Dictionary</code> object. The value of the property must be the
      same type as the set of Primary Property Types specified in <xref
      linkend="intro.core.release" xrefstyle="template:%t"/> Filter
      Syntax.</para>

      <para>The name or key of a property must always be a <code>String</code>
      object, and is not case-sensitive during look up, but must preserve the
      original case. The format of a property name should be:</para>

      <programlisting>property-name ::= public | private
public        ::= symbolic-name // See General Syntax in Core Framework
private       ::= '.' symbolic-name</programlisting>

      <para>Properties can be used in other subsystems that have restrictions
      on the character set that can be used. The <code>symbolic-name</code>
      production uses a very minimal character set.</para>

      <para>Bundles must not use nested lists or arrays, nor must they use
      mixed types. Using mixed types or nesting makes it impossible to use the
      meta typing specification. See <xref
      linkend="service.metatype"/>.</para>

      <para>Property values that are collections may have an ordering that
      must be preserved when persisting the configuration so that later access
      to the property value will see the preserved ordering of the
      collection.</para>
    </section>

    <section xml:id="service.cm.propertypropagation">
      <title>Property Propagation</title>

      <para>A configuration target should copy the public configuration
      properties (properties whose name does not start with a <code>'.'</code>
      or <code>\u002E</code>) of the <code>Dictionary</code> object argument
      in <code>updated(Dictionary)</code> into the service properties on any
      resulting service registration.</para>

      <para>This propagation allows the development of applications that
      leverage the Framework service registry more extensively, so compliance
      with this mechanism is advised.</para>

      <para>A configuration target may ignore any configuration properties it
      does not recognize, or it may change the values of the configuration
      properties before these properties are registered as service properties.
      Configuration properties in the Framework service registry are not
      strictly related to the configuration information.</para>

      <para>Bundles that follow this recommendation to propagate public
      configuration properties can participate in horizontal applications. For
      example, an application that maintains physical location information in
      the Framework service registry could find out where a particular device
      is located in the house or car. This service could use a property
      dedicated to the physical location and provide functions that leverage
      this property, such as a graphic user interface that displays these
      locations.</para>

      <para>Bundles performing service registrations on behalf of other
      bundles (e.g. OSGi Declarative Services) should propagate all public
      configuration properties and not propagate private configuration
      properties.</para>
    </section>

    <section xml:id="i1374751">
      <title>Automatic Properties</title>

      <para>The Configuration Admin service must automatically add a number of
      properties to the configuration dictionary. If these properties are also
      set by a configuring bundle or a plug-in, they must always be overridden
      before they are given to the target service, see <xref
      linkend="i1459884"/>. Therefore, the receiving bundle or plug-in can
      assume that the following properties are defined by the Configuration
      Admin service and not by the configuring bundle:</para>

      <itemizedlist>
        <listitem>
          <para><code>service.pid</code> - Set to the PID of the associated
          <code>Configuration</code> object. This is the full the targeted PID
          if a targeted PID is used, see <xref
          linkend="service.cm-targeted.pids"/>.</para>
        </listitem>

        <listitem>
          <para><code>service.factoryPid</code> - Only set for a Managed
          Service Factory. It is then set to the PID of the associated Managed
          Service Factory. This is the full the targeted PID if a targeted PID
          is used.</para>
        </listitem>

        <listitem>
          <para><code>service.bundleLocation</code> - Set to the location of
          the <code>Configuration</code> object. This property can only be
          used for searching, it may not appear in the configuration
          dictionary returned from the <code>getProperties</code> method due
          to security reasons, nor may it be used when the target is
          updated.</para>
        </listitem>
      </itemizedlist>

      <para>Constants for some of these properties can be found in
      <code>org.osgi.framework.Constants</code> and the <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin" xrefstyle="hyperlink"/>
      interface. These service properties are all of type
      <code>String</code>.</para>
    </section>

    <section xml:id="i1488808">
      <title>Equality</title>

      <para>Two different <code>Configuration</code> objects can actually
      represent the same underlying configuration. This means that a
      <code>Configuration</code> object must implement the <code>equals</code>
      and <code>hashCode</code> methods in such a way that two
      <code>Configuration</code> objects are equal when their PID is
      equal.</para>
    </section>
  </section>

  <section>
    <title>Managed Service</title>

    <para>A Managed Service is used by a bundle that needs one or more
    configuration dictionaries. It therefore registers the Managed Service
    with one or more PIDs and is thus associated with one
    <code>Configuration</code> object in the Configuration Admin service for
    each registered PID. A bundle can register any number of
    <code>ManagedService</code> objects, but each must be identified with its
    own PID or PIDs.</para>

    <para>A bundle should use a Managed Service when it needs configuration
    information for the following:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>A Singleton</emphasis> - A single entity in the bundle
        that needs to be configured.</para>
      </listitem>

      <listitem>
        <para><emphasis>Externally Detected Devices</emphasis> - Each device
        that is detected causes a registration of an associated
        <code>ManagedService</code> object. The PID of this object is related
        to the identity of the device, such as the address or serial
        number.</para>
      </listitem>
    </itemizedlist>

    <para>A Managed Service may be registered with more than one PID and
    therefore be associated with multiple Configuration objects, one for each
    PID. Using multiple PIDs for a Managed Service is not recommended. For
    example, when a configuration is deleted for a Managed Service there is no
    way to identify which PID is associated with the deleted
    configuration.</para>

    <section>
      <title>Singletons</title>

      <para>When an object must be instantiated only once, it is called a
      <emphasis>singleton</emphasis>. A singleton requires a single
      configuration dictionary. Bundles may implement several different types
      of singletons if necessary.</para>

      <para>For example, a Watchdog service could watch the registry for the
      status and presence of services in the Framework service registry. Only
      one instance of a Watchdog service is needed, so only a single
      configuration dictionary is required that contains the polling time and
      the list of services to watch.</para>
    </section>

    <section>
      <title>Networks</title>

      <para>When a device in the external world needs to be represented in the
      OSGi Environment, it must be detected in some manner. The Configuration
      Admin service cannot know the identity and the number of instances of
      the device without assistance. When a device is detected, it still needs
      configuration information in order to play a useful role.</para>

      <para>For example, a 1-Wire network can automatically detect devices
      that are attached and removed. When it detects a temperature sensor, it
      could register a Sensor service with the Framework service registry.
      This Sensor service needs configuration information specifically for
      that sensor, such as which lamps should be turned on, at what
      temperature the sensor is triggered, what timer should be started, in
      what zone it resides, and so on. One bundle could potentially have
      hundreds of these sensors and actuators, and each needs its own
      configuration information.</para>

      <para>Each of these Sensor services should be registered as a Managed
      Service with a PID related to the physical sensor (such as the address)
      to receive configuration information.</para>

      <para>Other examples are services discovered on networks with protocols
      like Jini, UPnP, and Salutation. They can usually be represented in the
      Framework service registry. A network printer, for example, could be
      detected via UPnP. Once in the service registry, these services usually
      require local configuration information. A Printer service needs to be
      configured for its local role: location, access list, and so on.</para>

      <para>This information needs to be available in the Framework service
      registry whenever that particular Printer service is registered.
      Therefore, the Configuration Admin service must remember the
      configuration information for this Printer service.</para>

      <para>This type of service should register with the Framework as a
      Managed Service in order to receive appropriate configuration
      information.</para>
    </section>

    <section xml:id="i1233865">
      <title>Configuring Managed Services</title>

      <para>A bundle that needs configuration information should register one
      or more <code>ManagedService</code> objects with a PID service property.
      If it has a default set of properties for its configuration, it may
      include them as service properties of the Managed Service. These
      properties may be used as a configuration template when a
      <code>Configuration</code> object is created for the first time. A
      Managed Service optionally implements the <code>MetaTypeProvider</code>
      interface to provide information about the property types. See <xref
      linkend="i1288153"/>.</para>

      <para>When this registration is detected by the Configuration Admin
      service, the following steps must occur:</para>

      <itemizedlist>
        <listitem>
          <para>The configuration stored for the registered PID must be
          retrieved. If there is a <code>Configuration</code> object for this
          PID and the configuration is visible for the associated bundle then
          it is sent to the Managed Service with <xref
          linkend="org.osgi.service.cm.ManagedService.updated-Dictionary-"
          xrefstyle="hyperlink"/>.</para>
        </listitem>

        <listitem>
          <para>If a Managed Service is registered and no configuration
          information is available or the configuration is not visible then
          the Configuration Admin service must call
          <code>updated(Dictionary)</code> with a <code>null</code>
          parameter.</para>
        </listitem>

        <listitem>
          <para>If the Configuration Admin service starts
          <emphasis>after</emphasis> a Managed Service is registered, it must
          call <xref
          linkend="org.osgi.service.cm.ManagedService.updated-Dictionary-"
          xrefstyle="hyperlink"/> on this service as soon as possible
          according to the prior rules. For this reason, a Managed Service
          must always get a callback when it registers
          <emphasis>and</emphasis> the Configuration Admin service is
          started.</para>
        </listitem>
      </itemizedlist>

      <para>Multiple Managed Services can register with the same PID, they are
      all updated as long as they have visibility to the configuration as
      defined by the location, see <xref
      linkend="service.cm-location.binding"/>.</para>

      <para>If the Managed Service is registered with more than one PID and
      more than one PID has no configuration information available, then
      <code>updated(Dictionary)</code> will be called multiple times with a
      <code>null</code> parameter.</para>

      <para>The <xref
      linkend="org.osgi.service.cm.ManagedService.updated-Dictionary-"
      xrefstyle="hyperlink"/> callback from the Configuration Admin service to
      the Managed Service must take place asynchronously. This requirement
      allows the Managed Service to finish its initialization in a
      synchronized method without interference from the Configuration Admin
      service callback. Care should be taken not to cause deadlocks by calling
      the Framework within a synchronized method.</para>

      <figure pgwide="1">
        <title>Managed Service Configuration Action Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.028in"
                       contentwidth="4.917in" fileref="ms-config-action.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <code>updated</code> method may throw a <xref
      linkend="org.osgi.service.cm.ConfigurationException"
      xrefstyle="hyperlink"/>. This object must describe the problem and what
      property caused the exception.</para>
    </section>

    <section>
      <title>Race Conditions</title>

      <para>When a Managed Service is registered, the default properties may
      be visible in the service registry for a short period before they are
      replaced by the properties of the actual configuration dictionary. Care
      should be taken that this visibility does not cause race conditions for
      other bundles.</para>

      <para>In cases where race conditions could be harmful, the Managed
      Service must be split into two pieces: an object performing the actual
      service and a Managed Service. First, the Managed Service is registered,
      the configuration is received, and the actual service object is
      registered. In such cases, the use of a Managed Service Factory that
      performs this function should be considered.</para>
    </section>

    <section>
      <title>Examples of Managed Service</title>

      <para><xref linkend="i1379376"/> shows a Managed Service configuration
      example. Two services are registered under the
      <code>ManagedService</code> interface, each with a different PID.</para>

      <figure xml:id="i1379376">
        <title>PIDs and External Associations</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.111in"
                       contentwidth="4.917in"
                       fileref="pids-external-associations.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Configuration Admin service has a database containing a
      configuration record for each PID. When the Managed Service with
      <code>service.pid = com.acme</code> is registered, the Configuration
      Admin service will retrieve the properties <code>name=Elmer</code> and
      <code>size=42</code> from its database. The properties are stored in a
      <code>Dictionary</code> object and then given to the Managed Service
      with the <code>updated(Dictionary)</code> method.</para>

      <section>
        <title>Configuring A Console Bundle</title>

        <para>In this example, a bundle can run a single debugging console
        over a Telnet connection. It is a singleton, so it uses a
        <code>ManagedService</code> object to get its configuration
        information: the port and the network name on which it should
        register.</para>

        <programlisting>class SampleManagedService implements ManagedService{
    Dictionary          properties;
    ServiceRegistration registration;
    Console             console;

    public void start( 
        BundleContext context ) throws Exception {
        properties = new Hashtable();
        properties.put( Constants.SERVICE_PID,
            "com.acme.console" );

        registration = context.registerService(
            ManagedService.class.getName(), 
            this,
            properties
        );
    }

    public synchronized void updated( Dictionary np ) {
        if ( np != null ) {
            properties = np;
            properties.put(
                Constants.SERVICE_PID, "com.acme.console" );
        }

        if (console == null)
            console = new Console();

        int port = ((Integer)properties.get("port"))
            .intValue();

        String network = (String) properties.get("network");
        console.setPort(port, network);
        registration.setProperties(properties);
    }
    ... further methods
}</programlisting>
      </section>
    </section>

    <section>
      <title>Deletion</title>

      <para>When a <code>Configuration</code> object for a Managed Service is
      deleted, the Configuration Admin service must call
      <code>updated(Dictionary)</code> with a <code>null</code> argument on a
      thread that is different from that on which the
      <code>Configuration.delete</code> was executed. This deletion must send
      out a Configuration Event <xref
      linkend="org.osgi.service.cm.ConfigurationEvent.CM_DELETED"
      xrefstyle="hyperlink"/> asynchronously to any registered Configuration
      Listener services after the <code>updated</code> method is called with a
      <code>null</code>.</para>
    </section>
  </section>

  <section xml:id="i1299227">
    <title>Managed Service Factory</title>

    <para>A Managed Service Factory is used when configuration information is
    needed for a service that can be instantiated multiple times. When a
    Managed Service Factory is registered with the Framework, the
    Configuration Admin service consults its database and calls <xref
    linkend="org.osgi.service.cm.ManagedServiceFactory.updated-String-Dictionary-"
    xrefstyle="hyperlink"/> for each associated and visible
    <code>Configuration</code> object that matches the PIDs on the
    registration. It passes the identifier of the Configuration instance,
    which can be used as a PID, as well as a <code>Dictionary</code> object
    with the configuration properties.</para>

    <para>A Managed Service Factory is useful when the bundle can provide
    functionality a number of times, each time with different configuration
    dictionaries. In this situation, the Managed Service Factory acts like a
    <emphasis>class</emphasis> and the Configuration Admin service can use
    this Managed Service Factory to <emphasis>instantiate instances</emphasis>
    for that <emphasis>class</emphasis>.</para>

    <para>In the next section, the word <emphasis>factory</emphasis> refers to
    this concept of creating <emphasis>instances</emphasis> of a function
    defined by a bundle that registers a Managed Service Factory.</para>

    <section>
      <title>When to Use a Managed Service Factory</title>

      <para>A Managed Service Factory should be used when a bundle does not
      have an internal or external entity associated with the configuration
      information but can potentially be instantiated multiple times.</para>

      <section>
        <title>Example Email Fetcher</title>

        <para>An email fetcher program displays the number of emails that a
        user has - a function likely to be required for different users. This
        function could be viewed as a <emphasis>class</emphasis> that needs to
        be <emphasis>instantiated</emphasis> for each user. Each instance
        requires different parameters, including password, host, protocol,
        user id, and so on.</para>

        <para>An implementation of the Email Fetcher service should register a
        <code>ManagedServiceFactory</code> object. In this way, the
        Configuration Admin service can define the configuration information
        for each user separately. The Email Fetcher service will only receive
        a configuration dictionary for each required instance (user).</para>
      </section>

      <section>
        <title>Example Temperature Conversion Service</title>

        <para>Assume a bundle has the code to implement a conversion service
        that receives a temperature and, depending on settings, can turn an
        actuator on and off. This service would need to be instantiated many
        times depending on where it is needed. Each instance would require its
        own configuration information for the following:</para>

        <itemizedlist>
          <listitem>
            <para>Upper value</para>
          </listitem>

          <listitem>
            <para>Lower value</para>
          </listitem>

          <listitem>
            <para>Switch Identification</para>
          </listitem>

          <listitem>
            <para>...</para>
          </listitem>
        </itemizedlist>

        <para>Such a conversion service should register a service object under
        a <code>ManagedServiceFactory</code> interface. A configuration
        program can then use this Managed Service Factory to create instances
        as needed. For example, this program could use a Graphic User
        Interface (GUI) to create such a component and configure it.</para>
      </section>

      <section>
        <title>Serial Ports</title>

        <para>Serial ports cannot always be used by the OSGi Device Access
        specification implementations. Some environments have no means to
        identify available serial ports, and a device on a serial port cannot
        always provide information about its type.</para>

        <para>Therefore, each serial port requires a description of the device
        that is connected. The bundle managing the serial ports would need to
        instantiate a number of serial ports under the control of the
        Configuration Admin service, with the appropriate
        <code>DEVICE_CATEGORY</code> property to allow it to participate in
        the Device Access implementation.</para>

        <para>If the bundle cannot detect the available serial ports
        automatically, it should register a Managed Service Factory. The
        Configuration Admin service can then, with the help of a configuration
        program, define configuration information for each available serial
        port.</para>
      </section>
    </section>

    <section>
      <title>Registration</title>

      <para>Similar to the Managed Service configuration dictionary, the
      configuration dictionary for a Managed Service Factory is identified by
      a PID. The Managed Service Factory, however, also has a
      <emphasis>factory</emphasis> PID, which is the PID of the associated
      Managed Service Factory. It is used to group all Managed Service Factory
      configuration dictionaries together.</para>

      <para>When the Configuration Admin service detects the registration of a
      Managed Service Factory, it must find all visible configuration
      dictionaries for this factory and must then sequentially call
      <code>ManagedServiceFactory.</code><xref
      linkend="org.osgi.service.cm.ManagedServiceFactory.updated-String-Dictionary-"
      xrefstyle="hyperlink"/> for each configuration dictionary. The first
      argument is the PID of the <code>Configuration</code> object (the one
      created by the Configuration Admin service) and the second argument
      contains the configuration properties.</para>

      <para>The Managed Service Factory should then create any artifacts
      associated with that factory. Using the PID given in the
      <code>Configuration</code> object, the bundle may register new services
      (other than a Managed Service) with the Framework, but this is not
      required. This may be necessary when the PID is useful in contexts other
      than the Configuration Admin service.</para>

      <para>The receiver must <emphasis>not</emphasis> register a Managed
      Service with this PID because this would force two Configuration objects
      to have the same PID. If a bundle attempts to do this, the Configuration
      Admin service should log an error and must ignore the registration of
      the Managed Service.</para>

      <para>The Configuration Admin service must guarantee that no race
      conditions exist between initialization, updates, and deletions.</para>

      <figure pgwide="1">
        <title>Managed Service Factory Action Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.910in"
                       contentwidth="4.917in" fileref="msf-config-action.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A Managed Service Factory has only one update method: <xref
      linkend="org.osgi.service.cm.ManagedServiceFactory.updated-String-Dictionary-"
      xrefstyle="hyperlink"/>. This method can be called any number of times
      as Configuration objects are created or updated.</para>

      <para>The Managed Service Factory must detect whether a PID is being
      used for the first time, in which case it should create a new
      <emphasis>instance</emphasis>, or a subsequent time, in which case it
      should update an existing instance.</para>

      <para>The Configuration Admin service must call
      <code>updated(String,Dictionary)</code> on a thread that is different
      from the one that executed the registration. This requirement allows an
      implementation of a Managed Service Factory to use a synchronized method
      to assure that the callbacks do not interfere with the Managed Service
      Factory registration.</para>

      <para>The <xref
      linkend="org.osgi.service.cm.ManagedServiceFactory.updated-String-Dictionary-"
      xrefstyle="hyperlink"/> method may throw a <xref
      linkend="org.osgi.service.cm.ConfigurationException"
      xrefstyle="hyperlink"/> object. This object describes the problem and
      what property caused the problem. These exceptions should be logged by a
      Configuration Admin service.</para>

      <para>Multiple Managed Service Factory services can be registered with
      the same PID. Each of those services that have visibility to the
      corresponding configuration will be updated in service ranking
      order.</para>
    </section>

    <section>
      <title>Deletion</title>

      <para>If a configuring bundle deletes an instance of a Managed Service
      Factory, the <xref
      linkend="org.osgi.service.cm.ManagedServiceFactory.deleted-String-"
      xrefstyle="hyperlink"/> method is called. The argument is the PID for
      this instance. The implementation of the Managed Service Factory must
      remove all information and stop any behavior associated with that PID.
      If a service was registered for this PID, it should be
      unregistered.</para>

      <para>Deletion will asynchronously send out a Configuration Event <xref
      linkend="org.osgi.service.cm.ConfigurationEvent.CM_DELETED"
      xrefstyle="hyperlink"/> to all registered Configuration Listener
      services.</para>
    </section>

    <section>
      <title>Managed Service Factory Example</title>

      <para><xref linkend="i1318247"/> highlights the differences between a
      Managed Service and a Managed Service Factory. It shows how a Managed
      Service Factory implementation receives configuration information that
      was created before it was registered.</para>

      <itemizedlist>
        <listitem>
          <para>A bundle implements an EMail Fetcher service. It registers a
          <code>ManagedServiceFactory</code> object with
          PID=<code>com.acme.email</code>.</para>
        </listitem>

        <listitem>
          <para>The Configuration Admin service notices the registration and
          consults its database. It finds three <code>Configuration</code>
          objects for which the factory PID is equal to
          <code>com.acme.email</code>. It must call
          <code>updated(String,Dictionary)</code> for each of these
          <code>Configuration</code> objects on the newly registered
          <code>ManagedServiceFactory</code> object.</para>
        </listitem>

        <listitem>
          <para>For each configuration dictionary received, the factory should
          create a new instance of a <code>EMailFetcher</code> object, one for
          <code>erica</code> (PID=16.1), one for <code>anna</code> (PID=16.3),
          and one for <code>elmer</code> (PID=16.2).</para>
        </listitem>

        <listitem>
          <para>The <code>EMailFetcher</code> objects are registered under the
          <code>Topic</code> interface so their results can be viewed by an
          online display.</para>

          <para>If the <code>EMailFetcher</code> object is registered, it may
          safely use the PID of the <code>Configuration</code> object because
          the Configuration Admin service must guarantee its suitability for
          this purpose.</para>
        </listitem>
      </itemizedlist>

      <figure pgwide="1" xml:id="i1318247">
        <title>Managed Service Factory Example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.778in"
                       contentwidth="4.940in" fileref="msf-example.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Multiple Consoles Example</title>

      <para>This example illustrates how multiple consoles, each of which has
      its own port and interface can run simultaneously. This approach is very
      similar to the example for the Managed Service, but highlights the
      difference by allowing multiple consoles to be created.</para>

      <programlisting>class ExampleFactory implements ManagedServiceFactory{
    Hashtable        consoles = new Hashtable();
    BundleContext    context;
    public void start( BundleContext context ) 
        throws Exception {
        this.context = context;
        Hashtable local = new Hashtable();
        local.put(Constants.SERVICE_PID,"com.acme.console");
        context.registerService(
            ManagedServiceFactory.class.getName(),
            this, 
            local );
    }

    public void updated( String pid, Dictionary config ){
        Console console = (Console) consoles.get(pid);
        if (console == null) {
            console = new Console(context);
            consoles.put(pid, console);
        }

        int port = getInt(config, "port", 2011);
        String network = getString(
            config, 
            "network",
            null /*all*/ 
        );
        console.setPort(port, network);
    }

    public void deleted(String pid) {
        Console console = (Console) consoles.get(pid);
        if (console != null) {
            consoles.remove(pid);
            console.close();
        }
    }
}</programlisting>
    </section>
  </section>

  <section>
    <title>Configuration Admin Service</title>

    <para>The <xref linkend="org.osgi.service.cm.ConfigurationAdmin"
    xrefstyle="hyperlink"/> interface provides methods to maintain
    configuration data in an OSGi environment. This configuration information
    is defined by a number of <code>Configuration</code> objects associated
    with specific configuration targets. <code>Configuration</code> objects
    can be created, listed, modified, and deleted through this interface.
    Either a remote management system or the bundles configuring their own
    configuration information may perform these operations.</para>

    <para>The <code>ConfigurationAdmin</code> interface has methods for
    creating and accessing <code>Configuration</code> objects for a Managed
    Service, as well as methods for managing new <code>Configuration</code>
    objects for a Managed Service Factory.</para>

    <section xml:id="i1374750">
      <title>Creating a Managed Service Configuration Object</title>

      <para>A bundle can create a new Managed Service
      <code>Configuration</code> object with
      <code>ConfigurationAdmin.getConfiguration</code>. No create method is
      offered because doing so could introduce race conditions between
      different bundles trying to create a <code>Configuration</code> object
      for the same Managed Service. The <code>getConfiguration</code> method
      must atomically create and persistently store an object if it does not
      yet exist.</para>

      <para>Two variants of this method are:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationAdmin.getConfiguration-String-"
          xrefstyle="hyperlink"/> - This method is used by a bundle with a
          given location to configure its <emphasis>own</emphasis>
          <code>ManagedService</code> objects. The argument specifies the PID
          of the targeted service.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationAdmin.getConfiguration-String-String-"
          xrefstyle="hyperlink"/> - This method is used by a management bundle
          to configure <emphasis>another</emphasis> bundle. Therefore, this
          management bundle needs the right permission. The first argument is
          the PID and the second argument is the location identifier of the
          targeted <code>ManagedService</code> object.</para>
        </listitem>
      </itemizedlist>

      <para>All <code>Configuration</code> objects have a method, <xref
      linkend="org.osgi.service.cm.Configuration.getFactoryPid--"
      xrefstyle="hyperlink"/>, which in this case must return
      <code>null</code> because the <code>Configuration</code> object is
      associated with a Managed Service.</para>

      <para>Creating a new Configuration object must <emphasis>not</emphasis>
      initiate a callback to the Managed Service <code>updated</code> method
      until the properties are set in the Configuration with the
      <code>update</code> method.</para>
    </section>

    <section xml:id="i1761778">
      <title>Creating a Managed Service Factory Configuration Object</title>

      <para>The <code>ConfigurationAdmin</code> class provides two sets of
      methods to create a new Configuration for a Managed Service Factory. The
      first set delegates the creation of the unique PID to the Configuration
      Admin service. The second set allows the caller to influence the
      generation of the PID.</para>

      <para>The <code>ConfigurationAdmin</code> class provides the following
      two methods which generate a unique PID when creating a new
      Configuration for a Managed Service Factory. A new, unique PID is
      created for the Configuration object by the Configuration Admin service.
      The scheme used for this PID is defined by the Configuration Admin
      service and is unrelated to the factory PID, which is chosen by the
      registering bundle.</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationAdmin.createFactoryConfiguration-String-"
          xrefstyle="hyperlink"/> - This method is used by a bundle with a
          given location to configure its own
          <code>ManagedServiceFactory</code> objects. The argument specifies
          the PID of the targeted <code>ManagedServiceFactory</code> object.
          This <emphasis>factory PID</emphasis> can be obtained from the
          returned <code>Configuration</code> object with the
          <code>getFactoryPid()</code> method.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationAdmin.createFactoryConfiguration-String-String-"
          xrefstyle="hyperlink"/> - This method is used by a management bundle
          to configure another bundle's <code>ManagedServiceFactory</code>
          object. The first argument is the PID and the second is the location
          identifier of the targeted <code>ManagedServiceFactory</code>
          object. The <emphasis>factory PID</emphasis> can be obtained from
          the returned <code>Configuration</code> object with
          <code>getFactoryPid</code> method.</para>
        </listitem>
      </itemizedlist>

      <para>The <code>ConfigurationAdmin</code> class provides the following
      two methods allowing the caller to influence the generation of the PID
      when creating a new Configuration for a Managed Service Factory. The PID
      for the Configuration object is generated from the provided factory PID
      and the provided name by starting with the factory PID, appending a
      tilde (<code>'~' \u007e</code>), and then appending the name. The
      <code>getFactoryConfiguration</code> methods must atomically create and
      persistently store a Configuration object if it does not yet
      exist.</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationAdmin.getFactoryConfiguration-String-String-"
          xrefstyle="hyperlink"/> - This method is used by a bundle with a
          given location to configure its own
          <code>ManagedServiceFactory</code> objects. The first argument
          specifies the PID of the targeted <code>ManagedServiceFactory</code>
          object. This <emphasis>factory PID</emphasis> can be obtained from
          the returned <code>Configuration</code> object with the
          <code>getFactoryPid()</code> method. The second argument specifies
          the <emphasis>name</emphasis> of the factory configuration. The
          generated PID can be obtained from the returned
          <code>Configuration</code> object with the <code>getPid()</code>
          method.</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationAdmin.getFactoryConfiguration-String-String-String-"
          xrefstyle="hyperlink"/> - This method is used by a management bundle
          to configure another bundle's <code>ManagedServiceFactory</code>
          object. The first argument is the PID, the second argument is the
          name, and the third is the location identifier of the targeted
          <code>ManagedServiceFactory</code> object. The <emphasis>factory
          PID</emphasis> can be obtained from the returned
          <code>Configuration</code> object with <code>getFactoryPid</code>
          method. The generated PID can be obtained from the returned
          <code>Configuration</code> object with the <code>getPid()</code>
          method.</para>
        </listitem>
      </itemizedlist>

      <para>Creating a new Configuration must <emphasis>not</emphasis>
      initiate a callback to the Managed Service Factory <code>updated</code>
      method until the properties are set in the <code>Configuration</code>
      object with the <code>update</code> method.</para>
    </section>

    <section>
      <title>Accessing Existing Configurations</title>

      <para>The existing set of <code>Configuration</code> objects can be
      listed with <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.listConfigurations-String-"
      xrefstyle="hyperlink"/>. The argument is a <code>String</code> object
      with a filter expression. This filter expression has the same syntax as
      the Framework <code>Filter</code> class. For example:</para>

      <programlisting>(&amp;(size=42)(service.factoryPid=*osgi*))</programlisting>

      <para>The Configuration Admin service must only return Configurations
      that are visible to the calling bundle, see <xref
      linkend="service.cm-location.binding"/>.</para>

      <para>A single <code>Configuration</code> object is identified with a
      PID, and can be obtained with <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.listConfigurations-String-"
      xrefstyle="hyperlink"/> if it is visible. <code>null</code> is returned
      in both cases when there are no visible <code>Configuration</code>
      objects.</para>

      <para>The PIDs that are filtered on can be targeted PIDs, see <xref
      linkend="service.cm-targeted.pids"/>.</para>
    </section>

    <section xml:id="service.cm-updating.configuration">
      <title>Updating a Configuration</title>

      <para>The process of updating a <code>Configuration</code> object is the
      same for Managed Services and Managed Service Factories. First, <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.listConfigurations-String-"
      xrefstyle="hyperlink"/>, <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.getConfiguration-String-"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.service.cm.ConfigurationAdmin.getFactoryConfiguration-String-String-"
      xrefstyle="hyperlink"/> should be used to get a
      <code>Configuration</code> object. The properties can be obtained with
      <code>Configuration.getProperties</code>. When no update has occurred
      since this object was created, <code>getProperties</code> returns
      <code>null</code>.</para>

      <para>New properties can be set by calling
      <code>Configuration.update</code>. The Configuration Admin service must
      first store the configuration information and then call all
      configuration targets that have visibility with the <code>updated</code>
      method: either the <code>ManagedService.</code><xref
      linkend="org.osgi.service.cm.ManagedService.updated-Dictionary-"
      xrefstyle="hyperlink"/> or <code>ManagedServiceFactory.</code><xref
      linkend="org.osgi.service.cm.ManagedServiceFactory.updated-String-Dictionary-"
      xrefstyle="hyperlink"/> method. If a target service is not registered,
      the fresh configuration information must be given to the target when the
      configuration target service registers and it has visibility. Each
      update of the Configuration properties must update a counter in the
      Configuration object after the data has been persisted but before the
      target(s) have been updated and any events are sent out. This counter is
      available from the <xref
      linkend="org.osgi.service.cm.Configuration.getChangeCount--"
      xrefstyle="hyperlink"/> method.</para>

      <para>The <code>update</code> methods in <code>Configuration</code>
      objects are not executed synchronously with the related target services
      <code>updated</code> method. The <code>updated</code> method must be
      called asynchronously. The Configuration Admin service, however, must
      have updated the persistent storage before the <code>update</code>
      method returns.</para>

      <para>The <code>update</code> methods must also asynchronously send out
      a Configuration Event <xref
      linkend="org.osgi.service.cm.ConfigurationEvent.CM_UPDATED"
      xrefstyle="hyperlink"/> to all registered Configuration
      Listeners.</para>

      <para>Invoking the <xref
      linkend="org.osgi.service.cm.Configuration.update-Dictionary-"
      xrefstyle="hyperlink"/> method results in Configuration Admin service
      blindly updating the <code>Configuration</code> object and performing
      the above outlined actions. This even happens if the updated set of
      properties is the same as the already existing properties in the
      <code>Configuration</code> object.</para>

      <para>To optimize configuration updates if the caller does not know
      whether properties of a <code>Configuration</code> object have changed,
      the <xref
      linkend="org.osgi.service.cm.Configuration.updateIfDifferent-Dictionary-"
      xrefstyle="hyperlink"/> method can be used. The provided dictionary is
      compared with the existing properties. If there is no change, no action
      is taken. If there is any change detected, <xref
      linkend="org.osgi.service.cm.Configuration.updateIfDifferent-Dictionary-"
      xrefstyle="hyperlink"/> acts exactly as <xref
      linkend="org.osgi.service.cm.Configuration.update-Dictionary-"
      xrefstyle="hyperlink"/>. Properties are compared as follows:</para>

      <itemizedlist>
        <listitem>
          <para>Scalars are compared using <code>equals</code></para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Arrays are compared using <code>Arrays.equals</code></para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Collections are compared using <code>equals</code></para>
        </listitem>
      </itemizedlist>

      <para>The <code>boolean</code> result of <xref
      linkend="org.osgi.service.cm.Configuration.updateIfDifferent-Dictionary-"
      xrefstyle="hyperlink"/> is <code>true</code> if the Configuration object
      has been updated.</para>

      <para>If the <code>Configuration</code> object has the <xref
      linkend="org.osgi.service.cm.Configuration.ConfigurationAttribute.READ_ONLY"
      xrefstyle="hyperlink"/> attribute set, calling one of the
      <code>update</code> methods results in a <xref
      linkend="org.osgi.service.cm.ReadOnlyConfigurationException"
      xrefstyle="hyperlink"/> and the configuration is not changed.</para>
    </section>

    <section xml:id="service.cm-multi.locations">
      <title>Using Multi-Locations</title>

      <para>Sharing configuration between different bundles can be done using
      multi-locations, see <xref linkend="service.cm-location.binding"/>. A
      multi-location for a Configuration enables this Configuration to be
      delivered to any bundle that has visibility to that configuration. It is
      also possible that Bundles are interested in multiple PIDs for one
      target service, for this reason they can register multiple PIDs for one
      service.</para>

      <para>For example, a number of bundles require access to the URL of a
      remote host, associated with the PID <code>com.acme.host</code>. A
      manager, aware that this PID is used by different bundles, would need to
      specify a location for the Configuration that allows delivery to any
      bundle. A multi-location, any location starting with a question mark
      achieves this. The part after the question mark has only use if the
      system runs with security, it allows the implementation of regions, see
      <xref linkend="service.cm-regions"/>. In this example a single question
      mark is used because any Bundle can receive this Configuration. The
      manager's code could look like:</para>

      <programlisting>Configuration c = admin.getConfiguration("com.acme.host", "?" );
Hashtable ht = new Hashtable();
ht.put( "host", hostURL);
c.update(ht);</programlisting>

      <para>A Bundle interested in the host configuration would register a
      Managed Service with the following properties:</para>

      <programlisting>service.pid = [ "com.acme.host", "com.acme.system"]</programlisting>

      <para>The Bundle would be called back for both the com.acme.host and
      com.acme.system PID and must therefore discriminate between these two
      cases. This Managed Service therefore would have a callback like:</para>

      <programlisting>volatile URL url;
public void updated( Dictionary d ) {
  if ( d.get("service.pid").equals("com.acme.host"))
      this.url = new URL( d.get("host"));
  if ( d.get("service.pid").equals("com.acme.system"))
        ....
}</programlisting>
    </section>

    <section xml:id="service.cm-regions">
      <title>Regions</title>

      <para>In certain cases it is necessary to isolate bundles from each
      other. This will require that the configuration can be separated in
      <emphasis>regions</emphasis>. Each region can then be configured by a
      separate manager that is only allowed to manage bundles in its own
      region. Bundles can then only see configurations from their own region.
      Such a region based system can only be achieved with Java security as
      this is the only way to place bundles in a sandbox. This section
      describes how the Configuration's location binding can be used to
      implement regions if Java security is active.</para>

      <para>Regions are groups of bundles that share location information
      among each other but are not willing to share this information with
      others. Using the multi-locations, see <xref
      linkend="service.cm-location.binding"/>, and security it is possible to
      limit access to a Configuration by using a location name. A Bundle can
      only receive a Configuration when it has <xref
      linkend="org.osgi.service.cm.ConfigurationPermission"
      xrefstyle="hyperlink"/> <code>[location name,</code> <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
      xrefstyle="hyperlink"/> <code>]</code>. It is therefore possible to
      create region by choosing a region name for the location. A management
      agent then requires <xref
      linkend="org.osgi.service.cm.ConfigurationPermission"
      xrefstyle="hyperlink"/> <code>[?region-name,</code> <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
      xrefstyle="hyperlink"/> <code>]</code> and a Bundle in the region
      requires <xref linkend="org.osgi.service.cm.ConfigurationPermission"
      xrefstyle="hyperlink"/> <code>[?region-name,</code> <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
      xrefstyle="hyperlink"/> <code>]</code>.</para>

      <para>To implement regions, the management agent is required to use
      multi-locations; without the question mark a Configuration is only
      visible to a Bundle that has the exact location of the Configuration.
      With a multi-location, the Configuration is delivered to any bundle that
      has the appropriate permission. Therefore, if regions are used, no
      manager should have <code>ConfigurationPermission[*, <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
      xrefstyle="hyperlink"/> ]</code> because it would be able to configure
      anybody. This permission would enable the manager to set the location to
      any region or set the location to <code>null</code>. All managers must
      be restricted to a permission like
      <code>ConfigurationPermission[?com.acme.region.*,CONFIGURE]</code>. The
      resource name for a Configuration Permission uses substring matching as
      in the OSGi Filter, this facility can be used to simplify the
      administrative setup and implement more complex sharing schemes.</para>

      <para>For example, a management agent works for the region
      <code>com.acme</code>. It has the following permission:</para>

      <programlisting><xref
          linkend="org.osgi.service.cm.ConfigurationPermission"
          xrefstyle="hyperlink"/>[?com.acme.*,<xref
          linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
          xrefstyle="hyperlink"/>]</programlisting>

      <para>The manager requires multi-location updates for
      <code>com.acme.*</code> (the last full stop is required in this
      wildcarding). For the <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
      xrefstyle="hyperlink"/> action the question mark must be specified in
      the resource name. The bundles in the region have the permission:</para>

      <programlisting><xref
          linkend="org.osgi.service.cm.ConfigurationPermission"
          xrefstyle="hyperlink"/>["?com.acme.alpha",<xref
          linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
          xrefstyle="hyperlink"/>]</programlisting>

      <para>The question mark must be specified for the <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
      xrefstyle="hyperlink"/> permission. A management agent that needs to
      configure Bundles in a region must then do this as follows:</para>

      <programlisting>Configuration c = admin.getConfiguration("com.acme.host", "?com.acme.alpha" );
Hashtable ht = new Hashtable();
ht.put( "host", hostURL);
c.update(ht);</programlisting>

      <para>Another, similar, example with two regions:</para>

      <itemizedlist>
        <listitem>
          <para><code>system</code></para>
        </listitem>

        <listitem>
          <para><code>application</code></para>
        </listitem>
      </itemizedlist>

      <para>There is only one manager that manages all bundles. Its
      permissions look like:</para>

      <programlisting>ConfigurationPermission[?system,<xref
          linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
          xrefstyle="hyperlink"/>]
ConfigurationPermission[?application,<xref
          linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
          xrefstyle="hyperlink"/>]</programlisting>

      <para>A Bundle in the <code>application</code> region can have the
      following permissions:</para>

      <programlisting>ConfigurationPermission[?application,<xref
          linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
          xrefstyle="hyperlink"/>]</programlisting>

      <para>This managed bundle therefore has only visibility to
      configurations in the <code>application</code> region.</para>
    </section>

    <section>
      <title>Deletion</title>

      <para>A <code>Configuration</code> object that is no longer needed can
      be deleted with <code>Configuration.delete</code>, which removes the
      <code>Configuration</code> object from the database. The database must
      be updated before the target service's <code>updated</code> or
      <code>deleted</code> method is called. Only services that have received
      the configuration dictionary before must be called.</para>

      <para>If the target service is a Managed Service Factory, the factory is
      informed of the deleted <code>Configuration</code> object by a call to
      <code>ManagedServiceFactory.</code><xref
      linkend="org.osgi.service.cm.ManagedServiceFactory.deleted-String-"
      xrefstyle="hyperlink"/> method. It should then remove the associated
      <emphasis>instance</emphasis>. The
      <code>ManagedServiceFactory.</code><xref
      linkend="org.osgi.service.cm.ManagedServiceFactory.deleted-String-"
      xrefstyle="hyperlink"/> call must be done asynchronously with respect to
      <code>Configuration.</code><xref
      linkend="org.osgi.service.cm.Configuration.delete--"
      xrefstyle="hyperlink"/>.</para>

      <para>When a <code>Configuration</code> object of a Managed Service is
      deleted, <code>ManagedService.updated</code> is called with
      <code>null</code> for the <code>properties</code> argument. This method
      may be used for clean-up, to revert to default values, or to unregister
      a service. This method is called asynchronously from the
      <code>delete</code> method.</para>

      <para>The delete method must also asynchronously send out a
      Configuration Event <xref
      linkend="org.osgi.service.cm.ConfigurationEvent.CM_DELETED"
      xrefstyle="hyperlink"/> to all registered Configuration
      Listeners.</para>

      <para>If the <code>Configuration</code> object has the <xref
      linkend="org.osgi.service.cm.Configuration.ConfigurationAttribute.READ_ONLY"
      xrefstyle="hyperlink"/> attribute set, calling the delete method results
      in a <xref linkend="org.osgi.service.cm.ReadOnlyConfigurationException"
      xrefstyle="hyperlink"/> and the configuration is not deleted.</para>
    </section>

    <section>
      <title>Updating a Bundle's Own Configuration</title>

      <para>The Configuration Admin service specification does not distinguish
      between updates via a Management Agent and a bundle updating its own
      configuration information (as defined by its location). Even if a bundle
      updates its own configuration information, the Configuration Admin
      service must callback the associated target service's
      <code>updated</code> method.</para>

      <para>As a rule, to update its own configuration, a bundle's user
      interface should <emphasis>only</emphasis> update the configuration
      information and never its internal structures directly. This rule has
      the advantage that the events, from the bundle implementation's
      perspective, appear similar for internal updates, remote management
      updates, and initialization.</para>
    </section>

    <section xml:id="service.cm-configuration.attributes">
      <title>Configuration Attributes</title>

      <para>The <code>Configuration</code> object supports attributes, similar
      to setting attributes on files in a file system. Currently only the
      <xref
      linkend="org.osgi.service.cm.Configuration.ConfigurationAttribute.READ_ONLY"
      xrefstyle="hyperlink"/> attribute is supported.</para>

      <para>Attributes can be set by calling the <xref
      linkend="org.osgi.service.cm.Configuration.addAttributes-ConfigurationAttribute...-"
      xrefstyle="hyperlink"/> method and listing the attributes to be added.
      In the same way attributes can be removed by calling <xref
      linkend="org.osgi.service.cm.Configuration.removeAttributes-ConfigurationAttribute...-"
      xrefstyle="hyperlink"/>. Each successful change in attributes is
      persisted.</para>

      <para>A Bundle can only change the attributes if it has Configuration
      Permission with the <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.ATTRIBUTE"
      xrefstyle="hyperlink"/> action. Otherwise a Security Exception is
      thrown.</para>

      <para>The currently set attributes can be queried using the <xref
      linkend="org.osgi.service.cm.Configuration.getAttributes--"
      xrefstyle="hyperlink"/> method.</para>
    </section>
  </section>

  <section xml:id="i1693263">
    <title>Configuration Events</title>

    <para>Configuration Admin can update interested parties of changes in its
    repository. The model is based on the white board pattern where
    Configuration Listener services are registered with the service
    registry.</para>

    <para>There are two types of Configuration Listener services:</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="org.osgi.service.cm.ConfigurationListener"
        xrefstyle="hyperlink"/> - The default Configuration Listener receives
        events asynchronously from the method that initiated the event and on
        another thread.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.cm.SynchronousConfigurationListener"
        xrefstyle="hyperlink"/> - A Synchronous Configuration Listener is
        guaranteed to be called on the same thread as the method call that
        initiated the event.</para>
      </listitem>
    </itemizedlist>

    <para>The Configuration Listener service will receive <xref
    linkend="org.osgi.service.cm.ConfigurationEvent" xrefstyle="hyperlink"/>
    objects if important changes take place. The Configuration Admin service
    must call the <xref
    linkend="org.osgi.service.cm.ConfigurationListener.configurationEvent-ConfigurationEvent-"
    xrefstyle="hyperlink"/> method with such an event. Configuration Events
    must be delivered in order for each listener as they are generated. The
    way events must be delivered is the same as described in
    <emphasis>Delivering Events</emphasis> of <xref
    linkend="intro.core.release" xrefstyle="template:%t"/>.</para>

    <para>The <code>ConfigurationEvent</code> object carries a factory PID (
    <xref linkend="org.osgi.service.cm.ConfigurationEvent.getFactoryPid--"
    xrefstyle="hyperlink"/> ) and a PID ( <xref
    linkend="org.osgi.service.cm.ConfigurationEvent.getPid--"
    xrefstyle="hyperlink"/> ). If the factory PID is <code>null</code>, the
    event is related to a Managed Service <code>Configuration</code> object,
    else the event is related to a Managed Service <code>Factory
    Configuration</code> object.</para>

    <para>The <code>ConfigurationEvent</code> object can deliver the following
    events from the <xref
    linkend="org.osgi.service.cm.ConfigurationEvent.getType--"
    xrefstyle="hyperlink"/> method:</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.service.cm.ConfigurationEvent.CM_DELETED"
        xrefstyle="hyperlink"/> - The <code>Configuration</code> object is
        deleted.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.cm.ConfigurationEvent.CM_UPDATED"
        xrefstyle="hyperlink"/> - The <code>Configuration</code> object is
        updated.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.cm.ConfigurationEvent.CM_LOCATION_CHANGED"
        xrefstyle="hyperlink"/> - The location of the
        <code>Configuration</code> object changed.</para>
      </listitem>
    </itemizedlist>

    <para>The Configuration Event also carries the
    <code>ServiceReference</code> object of the Configuration Admin service
    that generated the event.</para>

    <section>
      <title>Event Admin Service and Configuration Change Events</title>

      <para>Configuration events must be delivered asynchronously via the
      Event Admin service, if present. The topic of a configuration event must
      be:</para>

      <programlisting>org/osgi/service/cm/ConfigurationEvent/&lt;eventtype&gt;</programlisting>

      <para>The &lt;event type&gt; can be any of the following:</para>

      <programlisting><xref
          linkend="org.osgi.service.cm.ConfigurationEvent.CM_DELETED"
          xrefstyle="hyperlink"/>
<xref linkend="org.osgi.service.cm.ConfigurationEvent.CM_UPDATED"
          xrefstyle="hyperlink"/>
<xref linkend="org.osgi.service.cm.ConfigurationEvent.CM_LOCATION_CHANGED"
          xrefstyle="hyperlink"/></programlisting>

      <para>The properties of a configuration event are:</para>

      <itemizedlist>
        <listitem>
          <para><code>cm.factoryPid</code> - (<code>String</code>) The factory
          PID of the associated <code>Configuration</code> object, if the
          target is a Managed Service Factory. Otherwise not set.</para>
        </listitem>

        <listitem>
          <para><code>cm.pid</code> - (<code>String</code>) The PID of the
          associated <code>Configuration</code> object.</para>
        </listitem>

        <listitem>
          <para><code>service</code> - (<code>ServiceReference</code>) The
          Service Reference of the Configuration Admin service.</para>
        </listitem>

        <listitem>
          <para><code>service.id</code> - (<code>Long</code>) The
          Configuration Admin service's ID.</para>
        </listitem>

        <listitem>
          <para><code>service.objectClass</code> - (<code>String[]</code>) The
          Configuration Admin service's object class (which must include
          <code>org.osgi.service.cm.ConfigurationAdmin</code>)</para>
        </listitem>

        <listitem>
          <para><code>service.pid</code> - (<code>String</code>) The
          Configuration Admin service's persistent identity, if set.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section xml:id="i1459884">
    <title>Configuration Plugin</title>

    <para>The Configuration Admin service allows third-party applications to
    participate in the configuration process. Bundles that register a service
    object under a <code>ConfigurationPlugin</code> interface can process the
    configuration dictionary just before it reaches the configuration target
    service.</para>

    <para xml:id="i1490844">Plug-ins allow sufficiently privileged bundles to
    intercept configuration dictionaries just <emphasis>before</emphasis> they
    must be passed to the intended Managed Service or Managed Service Factory
    but <emphasis>after</emphasis> the properties are stored. The changes the
    plug-in makes are dynamic and must not be stored. The plug-in must only be
    called when an update takes place while it is registered and there is a
    valid dictionary. The plugin is not called when a configuration is
    deleted.</para>

    <para>The <code>ConfigurationPlugin</code> interface has only one method:
    <xref
    linkend="org.osgi.service.cm.ConfigurationPlugin.modifyConfiguration-ServiceReference-Dictionary-"
    xrefstyle="hyperlink"/>. This method inspects or modifies configuration
    data.</para>

    <para xml:id="i1490848">All plug-ins in the service registry must be
    traversed and called before the properties are passed to the configuration
    target service. Each Configuration Plugin object gets a chance to inspect
    the existing data, look at the target object, which can be a
    <code>ManagedService</code> object or a <code>ManagedServiceFactory</code>
    object, and modify the properties of the configuration dictionary. The
    changes made by a plug-in must be visible to plugins that are called
    later.</para>

    <para><code>ConfigurationPlugin</code> objects should not modify
    properties that belong to the configuration properties of the target
    service unless the implications are understood. This functionality is
    mainly intended to provide functions that leverage the Framework service
    registry. The changes made by the plugin should normally not be validated.
    However, the Configuration Admin must ignore changes to the automatic
    properties as described in <xref linkend="i1374751"/>.</para>

    <para>For example, a Configuration Plugin service may add a physical
    location property to a service. This property can be leveraged by
    applications that want to know where a service is physically located. This
    scenario could be carried out without any further support of the service
    itself, except for the general requirement that the service should
    propagate the public properties it receives from the Configuration Admin
    service to the service registry.</para>

    <figure>
      <title>Order of Configuration Plugin Services</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.722in"
                     contentwidth="7.000in" fileref="config-plugin-order.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section xml:id="i1490850">
      <title>Limiting The Targets</title>

      <para xml:id="i1490849">A <code>ConfigurationPlugin</code> object may
      optionally specify a <code>cm.target</code> registration property. This
      value is the PID of the configuration target whose configuration updates
      the <code>ConfigurationPlugin</code> object wants to intercept.</para>

      <para>The <code>ConfigurationPlugin</code> object must then only be
      called with updates for the configuration target service with the
      specified PID. For a factory target service, the factory PID is used and
      the plugin will see all instances of the factory. Omitting the
      <code>cm.target</code> registration property means that it is called for
      <emphasis>all</emphasis> configuration updates.</para>
    </section>

    <section>
      <title>Example of Property Expansion</title>

      <para>Consider a Managed Service that has a configuration property
      <code>service.to</code> with the value
      <code>(objectclass=com.acme.Alarm</code>). When the Configuration Admin
      service sets this property on the target service, a
      <code>ConfigurationPlugin</code> object may replace the
      <code>(objectclass=com.acme.Alarm)</code> filter with an array of
      existing alarm systems' PIDs as follows:</para>

      <programlisting>ID "service.to=[32434,232,12421,1212]"</programlisting>

      <para>A new Alarm Service with <code>service.pid=343</code> is
      registered, requiring that the list of the target service be updated.
      The bundle which registered the Configuration Plugin service, therefore,
      wants to set the <code>service.to</code> registration property on the
      target service. It does <emphasis>not</emphasis> do this by calling
      <code>ManagedService.updated</code> directly for several reasons:</para>

      <itemizedlist>
        <listitem>
          <para>In a securely configured system, it should not have the
          permission to make this call or even obtain the target
          service.</para>
        </listitem>

        <listitem>
          <para>It could get into race conditions with the Configuration Admin
          service if it had the permissions in the previous bullet. Both
          services would compete for access simultaneously.</para>
        </listitem>
      </itemizedlist>

      <para>Instead, it must get the <code>Configuration</code> object from
      the Configuration Admin service and call the <code>update</code> method
      on it.</para>

      <para>The Configuration Admin service must schedule a new update cycle
      on another thread, and sometime in the future must call
      <code>ConfigurationPlugin.modifyProperties</code>. The
      <code>ConfigurationPlugin</code> object could then set the
      <code>service.to</code> property to <code>[32434,232,12421,1212,
      343]</code>. After that, the Configuration Admin service must call
      <code>updated</code> on the target service with the new
      <code>service.to</code> list.</para>
    </section>

    <section xml:id="i1490867">
      <title>Configuration Data Modifications</title>

      <para>Modifications to the configuration dictionary are still under the
      control of the Configuration Admin service, which must determine whether
      to accept the changes, hide critical variables, or deny the changes for
      other reasons.</para>

      <para>The <code>ConfigurationPlugin</code> interface must also allow
      plugins to detect configuration updates to the service via the callback.
      This ability allows them to synchronize the configuration updates with
      transient information.</para>
    </section>

    <section>
      <title>Forcing a Callback</title>

      <para>If a bundle needs to force a Configuration Plugin service to be
      called again, it must fetch the appropriate <code>Configuration</code>
      object from the Configuration Admin service and call the
      <code>update()</code> method (the no parameter version) on this object.
      This call forces an update with the current configuration dictionary so
      that all applicable plug-ins get called again.</para>
    </section>

    <section xml:id="service.cm-plugin.order">
      <title>Calling Order</title>

      <para>The order in which the <code>ConfigurationPlugin</code> objects
      are called must depend on the <code>service.cmRanking</code>
      configuration property of the <code>ConfigurationPlugin</code> object.
      <xref linkend="i1624384"/> shows the usage of the
      <code>service.cmRanking</code> property for the order of calling the
      Configuration Plugin services. In the event of more than one plugin
      having the same value of <code>service.cmRanking</code>, then the order
      in which these are called is undefined.</para>

      <table xml:id="i1624384">
        <title><code>service.cmRanking</code> Usage For Ordering</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="3*"/>

          <thead>
            <row>
              <entry>service.cmRanking value</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>&lt; 0</code></entry>

              <entry><para>The Configuration Plugin service should not modify
              properties and must be called before any modifications are made.
              Any modification from the Configuration Plugin service is
              ignored.</para></entry>
            </row>

            <row>
              <entry><code>&gt;= 0 &amp;&amp; &lt;= 1000</code></entry>

              <entry><para xml:id="i1624378">The Configuration Plugin service
              modifies the configuration data. The calling order should be
              based on the value of the <code>service.cmRanking</code>
              property.</para></entry>
            </row>

            <row>
              <entry><code>&gt; 1000</code></entry>

              <entry><para>The Configuration Plugin service should not modify
              data and is called after all modifications are made. Any
              modification from the Configuration Plugin service is
              ignored.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="service.cm-plugin.manual">
      <title>Manual Invocation</title>

      <para>The Configuration Admin service ensures that Configuration Plugin
      services are automatically called for a Managed Service or a Managed
      Service Factory as outlined above. If a bundle needs to get the
      configuration properties processed by the Configuration Plugin services,
      the <xref
      linkend="org.osgi.service.cm.Configuration.getProcessedProperties-ServiceReference-"
      xrefstyle="hyperlink"/> method provides this view.</para>

      <para>The service reference passed into the method must either point to
      a Managed Service or Managed Service Factory registered on behalf of the
      bundle getting the processed properties. If that service should not be
      called by the Configuration Admin service, that service must be
      registered without a PID service property.</para>
    </section>
  </section>

  <section xml:id="i1288153">
    <title>Meta Typing</title>

    <para>This section discusses how the Metatype specification is used in the
    context of a Configuration Admin service.</para>

    <para>When a Managed Service or Managed Service Factory is registered, the
    service object may also implement the <code>MetaTypeProvider</code>
    interface.</para>

    <para>If the Managed Service or Managed Service Factory object implements
    the <code>MetaTypeProvider</code> interface, a management bundle may
    assume that the associated <code>ObjectClassDefinition</code> object can
    be used to configure the service.</para>

    <para>The <code>ObjectClassDefinition</code> and
    <code>AttributeDefinition</code> objects contain sufficient information to
    automatically build simple user interfaces. They can also be used to
    augment dedicated interfaces with accurate validations.</para>

    <para>When the Metatype specification is used, care should be taken to
    match the capabilities of the metatype package to the capabilities of the
    Configuration Admin service specification. Specifically:</para>

    <itemizedlist>
      <listitem>
        <para>The metatype specification cannot describe nested arrays and
        lists or arrays/lists of mixed type.</para>
      </listitem>
    </itemizedlist>

    <para>This specification does not address how the metatype is made
    available to a management system due to the many open issues regarding
    remote management.</para>
  </section>

  <section xml:id="service.cm-coordinatorsupport">
    <title>Coordinator Support</title>

    <para>The <xref linkend="service.coordinator"/> defines a mechanism for
    multiple parties to collaborate on a common task without <emphasis>a
    priori</emphasis> knowledge of who will collaborate in that task. The
    Configuration Admin service must participate in such scenarios to
    coordinate with provisioning or configuration tasks.</para>

    <para>If configurations are created, updated or deleted and an implicit
    coordination exists, the Configuration Admin service must delay
    notifications until the coordination terminates. However the configuration
    changes must be persisted immediately. Updating a Managed Service or
    Managed Service Factory and informing asynchronous listeners is delayed
    until the coordination terminates, regardless of whether the coordination
    fails or terminates regularly. Registered synchronous listeners will be
    informed immediately when the change happens regardless of a
    coordination.</para>
    <para>The intend of this integration is that multiple events are collapsed
    into one as updating a Managed Service or Managed Service Factory might result
    in services being updated or unregistered what can trigger other service changes
    what might be a costly operation and therefore result in an unwanted intermediate
    state until the system has setled again. Collapsing here means, that multiple
    updates inside a coordination are combined into exactly one update that reflects
    the final outcome, the following list gives some examples for clarification:
    </para>
    <itemizedlist>
      <listitem>
        <para>If a configuration exists and it has currently the values <code>{key: value}</code>
         and a coordination starts where it is first updated to <code>{key: something else}</code>
         and later again to <code>{key: value}</code>, then after the coordination terminates
         one update is delivered with <code>{key: value}</code> even though the configuration has
         not changed, see <xref linkend="service.cm-updating.configuration" />.
         </para>
         <para>If no configuration exists and a coordination starts where it is first updated to
         <code>{key: something else}</code> and later is deleted, then after the coordination
         terminates one update is delivered with <code>null</code> even though the Managed Service
         or Managed Service Factory has not changed this is a special case of the blindly update
         case described in <xref linkend="service.cm-updating.configuration" />.
         </para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="service.cm-capabilities">
    <title>Capabilities</title>

    <section>
      <title>osgi.implementation Capability</title>

      <para>The Configuration Admin implementation bundle must provide the
      <link
      linkend="service.namespaces-osgi.implementation.namespace"><code>osgi.implementation</code></link>
      capability with the name <code>osgi.cm</code>. This capability can be
      used by provisioning tools and during resolution to ensure that a
      Configuration Admin implementation is present to manage configurations.
      The capability must also declare a uses constraint for the
      <code>org.osgi.service.cm</code> package and provide the version of this
      specification:</para>

      <programlisting>Provide-Capability: osgi.implementation;
       osgi.implementation="osgi.cm";
       uses:="org.osgi.service.cm";
       version:Version="<xref endterm="org.osgi.service.cm-version.number"
          linkend="org.osgi.service.cm"/>"</programlisting>

      <para>This capability must follow the rules defined for the <xref
      linkend="service.namespaces-osgi.implementation.namespace"/>.</para>

      <para>Bundles relying on the Configuration Admin service should require
      the <code>osgi.implementation</code> capability from the Configuration
      Admin Service.</para>

      <programlisting>Require-Capability: osgi.implementation;
  filter:="(&amp;(osgi.implementation=osgi.cm)(version&gt;=<xref
          endterm="org.osgi.service.cm-version.number"
          linkend="org.osgi.service.cm"/>)(!(version&gt;=2.0)))"</programlisting>

      <para>This requirement can be easily generated using the <xref
      linkend="org.osgi.service.cm.annotations.RequireConfigurationAdmin"
      xrefstyle="hyperlink"/> annotation.</para>
    </section>

    <section>
      <title>osgi.service Capability</title>

      <para>The bundle providing the Configuration Admin service must provide
      a capability in the <link
      linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
      namespace representing this service. This capability must also declare a
      uses constraint for the <code>org.osgi.service.cm</code> package:</para>

      <programlisting>Provide-Capability: osgi.service;
  objectClass:List&lt;String&gt;="org.osgi.service.cm.ConfigurationAdmin";
  uses:="org.osgi.service.cm"</programlisting>

      <para>This capability must follow the rules defined for the <xref
      linkend="service.namespaces-osgi.service.namespace"/>.</para>
    </section>
  </section>

  <section>
    <title>Security</title>

    <section xml:id="i1693439">
      <title>Configuration Permission</title>

      <para>Every bundle has the implicit right to receive and configure
      configurations with a location that exactly matches the Bundle's
      location or that is <code>null</code>. For all other situations the
      Configuration Admin must verify that the configuring and to be updated
      bundles have a Configuration Permission that matches the Configuration's
      location.</para>

      <para>The resource name of this permission maps to the location of the
      Configuration, the location can control the visibility of a
      Configuration for a bundle. The resource name is compared with the
      actual configuration location using the OSGi Filter sub-string matching.
      The question mark for multi-locations is part of the given resource
      name. The Configure Permission has the following actions:</para>

      <itemizedlist>
        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
          xrefstyle="hyperlink"/> - Can manage matching configurations</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationPermission.TARGET"
          xrefstyle="hyperlink"/> - Can be updated with a matching
          configuration</para>
        </listitem>

        <listitem>
          <para><xref
          linkend="org.osgi.service.cm.ConfigurationPermission.ATTRIBUTE"
          xrefstyle="hyperlink"/> - Can manage attributes for matching
          configuration</para>
        </listitem>
      </itemizedlist>

      <para>To be able to set the location to <code>null</code> requires a
      <code>ConfigurationPermission[*,</code> <xref
      linkend="org.osgi.service.cm.ConfigurationPermission.CONFIGURE"
      xrefstyle="hyperlink"/> <code>]</code>.</para>

      <para>It is possible to deny bundles the use of multi-locations by using
      Conditional Permission Admin's deny model.</para>
    </section>

    <section>
      <title>Permissions Summary</title>

      <para>Configuration Admin service security is implemented using Service
      Permission and Configuration Permission. The following table summarizes
      the permissions needed by the Configuration Admin bundle itself, as well
      as the typical permissions needed by the bundles with which it
      interacts.</para>

      <para>Configuration Admin:</para>

      <programlisting>ServicePermission[ ..ConfigurationAdmin, REGISTER]
ServicePermission[ ..ManagedService, GET ]
ServicePermission[ ..ManagedServiceFactory, GET ]
ServicePermission[ ..ConfigurationPlugin, GET ]
ConfigurationPermission[ *, CONFIGURE ]
AdminPermission[ *, METADATA ]</programlisting>

      <para>Managed Service:</para>

      <programlisting>ServicePermission[ ..ConfigurationAdmin, GET]
ServicePermission[ ..ManagedService, REGISTER ]
ConfigurationPermission[ ... , TARGET ]</programlisting>

      <para>Managed Service Factory:</para>

      <programlisting>ServicePermission[ ..ConfigurationAdmin, GET]
ServicePermission[ ..ManagedServiceFactory, REGISTER ]
ConfigurationPermission[ ... , TARGET ]</programlisting>

      <para>Configuration Plugin:</para>

      <programlisting>ServicePermission[ ..ConfigurationPlugin,REGISTER ]</programlisting>

      <para>Configuration Listener:</para>

      <programlisting>ServicePermission[ ..ConfigurationListener,REGISTER ]</programlisting>

      <para>The Configuration Admin service must have <code>ServicePermission[
      ConfigurationAdmin, REGISTER]</code>. It will also be the only bundle
      that needs the <code>ServicePermission[ManagedService |
      ManagedServiceFactory | ConfigurationPlugin, GET]</code>. No other
      bundle should be allowed to have <code>GET</code> permission for these
      interfaces. The Configuration Admin bundle must also hold
      <code>ConfigurationPermission[*,CONFIGURE]</code>.</para>

      <para>Bundles that can be configured must have the
      <code>ServicePermission[ManagedService | ManagedServiceFactory,
      REGISTER]</code>. Bundles registering <code>ConfigurationPlugin</code>
      objects must have <code>ServicePermission[ConfigurationPlugin,
      REGISTER]</code>. The Configuration Admin service must trust all
      services registered with the <code>ConfigurationPlugin</code> interface.
      Only the Configuration Admin service should have
      <code>ServicePermission[ ConfigurationPlugin, GET]</code>.</para>

      <para>If a Managed Service or Managed Service Factory is implemented by
      an object that is also registered under another interface, it is
      possible, although inappropriate, for a bundle other than the
      Configuration Admin service implementation to call the
      <code>updated</code> method. Security-aware bundles can avoid this
      problem by having their updated methods check that the caller has
      <code>ConfigurationPermission[*,CONFIGURE]</code>.</para>

      <para>Bundles that want to change their own configuration need
      <code>ServicePermission[ConfigurationAdmin, GET]</code>. A bundle with
      <code>ConfigurationPermission[*,CONFIGURE]</code> is allowed to access
      and modify any <code>Configuration</code> object.</para>

      <para>Pre-configuration of bundles requires
      <code>ConfigurationPermission[location,CONFIGURE]</code> (location can
      use the sub-string matching rules of the Filter) because the methods
      that specify a location require this permission.</para>
    </section>

    <section>
      <title>Configuration and Permission Administration</title>

      <para>Configuration information has a direct influence on the
      permissions needed by a bundle. For example, when the Configuration
      Admin Bundle orders a bundle to use port 2011 for a console, that bundle
      also needs permission for listening to incoming connections on that
      port.</para>

      <para>Both a simple and a complex solution exist for this
      situation.</para>

      <para>The simple solution for this situation provides the bundle with a
      set of permissions that do not define specific values but allow a range
      of values. For example, a bundle could listen to ports above 1024
      freely. All these ports could then be used for configuration.</para>

      <para>The other solution is more complicated. In an environment where
      there is very strong security, the bundle would only be allowed access
      to a specific port. This situation requires an atomic update of both the
      configuration data and the permissions. If this update was not atomic, a
      potential security hole would exist during the period of time that the
      set of permissions did not match the configuration.</para>

      <para>The following scenario can be used to update a configuration and
      the security permissions:</para>

      <orderedlist>
        <listitem>
          <para>Stop the bundle.</para>
        </listitem>

        <listitem>
          <para>Update the appropriate <code>Configuration</code> object via
          the Configuration Admin service.</para>
        </listitem>

        <listitem>
          <para>Update the permissions in the Framework.</para>
        </listitem>

        <listitem>
          <para>Start the bundle.</para>
        </listitem>
      </orderedlist>

      <para>This scenario would achieve atomicity from the point of view of
      the bundle.</para>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cm.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.cm.annotations.xml"/>
</chapter>
