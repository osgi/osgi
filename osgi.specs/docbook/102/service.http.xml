<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->

<chapter label="102"
         revision="$Id$"
         version="5.0" xml:id="service.http"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Http Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.http-version"
    linkend="org.osgi.service.http"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>An OSGi framework normally provides users with access to services on
    the Internet and other networks. This access allows users to remotely
    retrieve information from, and send control to, services in an OSGi
    framework using a standard web browser.</para>

    <para>Bundle developers typically need to develop communication and user
    interface solutions for standard technologies such as HTTP, HTML, XML, and
    servlets.</para>

    <para>The Http Service supports two standard techniques for this
    purpose:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Registering servlets</emphasis> - A servlet is a Java
        object which implements the Java Servlet API. Registering a servlet in
        the Framework gives it control over some part of the Http Service URI
        name-space.</para>
      </listitem>

      <listitem>
        <para><emphasis>Registering resources</emphasis> - Registering a
        resource allows HTML files, image files, and other static resources to
        be made visible in the Http Service URI name-space by the requesting
        bundle.</para>
      </listitem>
    </itemizedlist>

    <para>Implementations of the Http Service can be based on:</para>

    <itemizedlist>
      <listitem>
        <para><xref linkend="i1231452"/></para>
      </listitem>

      <listitem>
        <para><xref linkend="i1215926"/></para>
      </listitem>
    </itemizedlist>

    <para>Alternatively, implementations of this service can support other
    protocols if these protocols can conform to the semantics of the
    <code>javax.servlet</code> API. This additional support is necessary
    because the Http Service is closely related to <xref linkend="i1217577"/>.
    Http Service implementations must support at least version 2.1 of the Java
    Servlet API.</para>

    <section>
      <title>Entities</title>

      <para>This specification defines the following interfaces which a bundle
      developer can implement collectively as an Http Service or use
      individually:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis><xref linkend="org.osgi.service.http.HttpContext"
          xrefstyle="hyperlink"/></emphasis> - Allows bundles to provide
          information for a servlet or resource registration.</para>
        </listitem>

        <listitem>
          <para><emphasis><xref linkend="org.osgi.service.http.HttpService"
          xrefstyle="hyperlink"/></emphasis> - Allows other bundles in the
          Framework to dynamically register and unregister resources and
          servlets into the Http Service URI name-space.</para>
        </listitem>

        <listitem>
          <para><emphasis><xref
          linkend="org.osgi.service.http.NamespaceException"
          xrefstyle="hyperlink"/></emphasis> - Is thrown to indicate an error
          with the caller's request to register a servlet or resource into the
          Http Service URI name-space.</para>
        </listitem>
      </itemizedlist>

      <figure pgwide="1">
        <title>Http Service Overview Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="3.313in"
                       contentwidth="6.496in"
                       fileref="httpservice-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section xml:id="i1223311">
    <title>Registering Servlets</title>

    <para><code>javax.servlet.Servlet</code> objects can be registered with
    the Http Service by using the <code>HttpService</code> interface. For this
    purpose, the <code>HttpService</code> interface defines the method <xref
    linkend="org.osgi.service.http.HttpService.registerServlet-String-javax.servlet.Servlet-Dictionary-HttpContext-"
    xrefstyle="hyperlink"/>.</para>

    <para>For example, if the Http Service implementation is listening to port
    80 on the machine <code>www.acme.com</code> and the <code>Servlet</code>
    object is registered with the name <code>"/servlet"</code>, then the
    <code>Servlet</code> object's <code>service</code> method is called when
    the following URL is used from a web browser:</para>

    <programlisting>http://www.acme.com/servlet?name=bugs</programlisting>

    <para>All <code>Servlet</code> objects and resource registrations share
    the same name-space. If an attempt is made to register a resource or
    <code>Servlet</code> object under the same name as a currently registered
    resource or <code>Servlet</code> object, a <code>NamespaceException</code>
    is thrown. See <xref linkend="i1208280"/> for more information about the
    handling of the Http Service name-space.</para>

    <para>Each <code>Servlet</code> registration must be accompanied with an
    <code>HttpContext</code> object. This object provides the handling of
    resources, media typing, and a method to handle authentication of remote
    requests. See <xref linkend="service.http.authentication"/>.</para>

    <para>For convenience, a default <code>HttpContext</code> object is
    provided by the Http Service and can be obtained with <xref
    linkend="org.osgi.service.http.HttpService.createDefaultHttpContext--"
    xrefstyle="hyperlink"/>. Passing a <code>null</code> parameter to the
    registration method achieves the same effect.</para>

    <para><code>Servlet</code> objects require a <code>ServletContext</code>
    object. This object provides a number of functions to access the Http
    Service Java Servlet environment. It is created by the implementation of
    the Http Service for each unique <code>HttpContext</code> object with
    which a <code>Servlet</code> object is registered. Thus,
    <code>Servlet</code> objects registered with the same
    <code>HttpContext</code> object must also share the same
    <code>ServletContext</code> object.</para>

    <para><code>Servlet</code> objects are initialized by the Http Service
    when they are registered and bound to that specific Http Service. The
    initialization is done by calling the <code>Servlet</code> object's
    <code>Servlet.init(ServletConfig)</code> method. The
    <code>ServletConfig</code> parameter provides access to the initialization
    parameters specified when the <code>Servlet</code> object was
    registered.</para>

    <para>Therefore, the same <code>Servlet</code> instance must not be reused
    for registration with another Http Service, nor can it be registered under
    multiple names. Unique instances are required for each
    registration.</para>

    <para>The following example code demonstrates the use of the
    <code>registerServlet</code> method:</para>

    <programlisting xml:id="i1223332">Hashtable initparams = new Hashtable();
initparams.put( "name", "value" );

Servlet myServlet = new HttpServlet() {
    String name = "&lt;not set&gt;";

    public void init( ServletConfig config ) {
        this.name = (String)
            config.getInitParameter( "name" );
    }

    public void doGet( 
        HttpServletRequest req,
        HttpServletResponse rsp 
    ) throws IOException {
        rsp.setContentType( "text/plain" );
        req.getWriter().println( this.name );
    }
};

getHttpService().registerServlet(
    "/servletAlias", 
    myServlet, 
    initparams, 
    null // use default context
);
// myServlet has been registered 
// and its init method has been called. Remote
// requests are now handled and forwarded to 
// the servlet.
...
getHttpService().unregister("/servletAlias");
// myServlet has been unregistered and its 
// destroy method has been called
</programlisting>

    <para>This example registers the servlet, <code>myServlet</code>, at
    alias: <code>/servletAlias</code>. Future requests for
    <code>http://www.acme.com/servletAlias</code> maps to the servlet,
    <code>myServlet</code>, whose <code>service</code> method is called to
    process the request. (The <code>service</code> method is called in the
    <code>HttpServlet</code> base class and dispatched to a
    <code>doGet</code>, <code>doPut</code>, <code>doPost</code>,
    <code>doOptions</code>, <code>doTrace</code>, or <code>doDelete</code>
    call depending on the HTTP request method used.)</para>
  </section>

  <section>
    <title>Registering Resources</title>

    <para>A resource is a file containing images, static HTML pages, sounds,
    movies, applets, etc. Resources do not require any handling from the
    bundle. They are transferred directly from their source - usually the JAR
    file that contains the code for the bundle - to the requester using
    HTTP.</para>

    <para>Resources could be handled by Servlet objects as explained in <xref
    linkend="i1223311"/>. Transferring a resource over HTTP, however, would
    require very similar <code>Servlet</code> objects for each bundle. To
    prevent this redundancy, resources can be registered directly with the
    Http Service via the <xref linkend="org.osgi.service.http.HttpService"
    xrefstyle="hyperlink"/> interface. This <code>HttpService</code> interface
    defines the
    <code>registerResources(String,String,HttpContext)</code> method for
    registering a resource into the Http Service URI name-space.</para>

    <para>The first parameter is the external alias under which the resource
    is registered with the Http Service. The second parameter is an internal
    prefix to map this resource to the bundle's name-space. When a request is
    received, the <code>HttpService</code> object must remove the external
    alias from the URI, replace it with the internal prefix, and call the
    <code>getResource(String)</code> method with this new name on the
    associated <code>HttpContext</code> object. The <code>HttpContext</code>
    object is further used to get the MIME type of the resource and to
    authenticate the request.</para>

    <para>Resources are returned as a <code>java.net.URL</code> object. The
    Http Service must read from this <code>URL</code> object and transfer the
    content to the initiator of the HTTP request.</para>

    <para>This return type was chosen because it matches the return type of
    the <code>java.lang.Class.getResource(String resource)</code> method. This
    method can retrieve resources directly from the same place as the one from
    which the class was loaded - often a package directory in the JAR file of
    the bundle. This method makes it very convenient to retrieve resources
    from the bundle that are contained in the package.</para>

    <para>The following example code demonstrates the use of the
    <code>register Resources</code> method:</para>

    <programlisting>package com.acme;
...
HttpContext context = new HttpContext() {
    public boolean handleSecurity(
        HttpServletRequest request,
        HttpServletResponse response
    ) throws IOException {
        return true;
    }

    public URL getResource(String name) {
        return getClass().getResource(name);
    }

    public String getMimeType(String name) {
        return null;
    }
};

getHttpService().registerResources (
    "/files", 
    "www", 
    context
);
...
getHttpService().unregister("/files");
</programlisting>

    <para>This example registers the alias /files on the Http Service.
    Requests for resources below this name-space are transferred to the
    <code>HttpContext</code> object with an internal name of
    <code>www/&lt;name&gt;</code>. This example uses the <code>Class.get
    Resource(String)</code> method. Because the internal name does not start
    with a "/", it must map to a resource in the "<code>com/acme/www</code>"
    directory of the JAR file. If the internal name did start with a "/", the
    package name would not have to be prefixed and the JAR file would be
    searched from the root. Consult the
    <code>java.lang.Class.getResource(String)</code> method for more
    information.</para>

    <para>In the example, a request for
    <code>http://www.acme.com/files/myfile.html</code> must map to the name
    "<code>com/acme/www/myfile.html"</code> which is in the bundle's JAR
    file.</para>

    <para>More sophisticated implementations of the
    <code>getResource(String</code>) method could filter the input name,
    restricting the resources that may be returned or map the input name onto
    the file system (if the security implications of this action are
    acceptable).</para>

    <para>Alternatively, the resource registration could have used a default
    <code>HttpContext</code> object, as demonstrated in the following call to
    <code>registerResources</code>:</para>

    <programlisting>getHttpService().registerResources(
    "/files", 
    "/com/acme/www", 
    null
);</programlisting>

    <para>In this case, the Http Service implementation would call the <xref
    linkend="org.osgi.service.http.HttpService.createDefaultHttpContext--"
    xrefstyle="hyperlink"/> method and use its return value as the
    <code>HttpContext</code> argument for the <code>registerResources</code>
    method. The default implementation must map the resource request to the
    bundle's resource, using <code>Bundle.getResource(String)</code>. In the
    case of the previous example, however, the internal name must now specify
    the full path to the directory containing the resource files in the JAR
    file. No automatic prefixing of the package name is done.</para>

    <para>The <code>getMimeType(String)</code> implementation of the default
    <code>HttpContext</code> object should rely on the default mapping
    provided by the Http Service by returning <code>null</code>. Its
    <code>handleSecurity(HttpServletRequest,HttpServletResponse)</code> may
    implement an authentication mechanism that is
    implementation-dependent.</para>
  </section>

  <section xml:id="i1208280">
    <title>Mapping HTTP Requests to Servlet and Resource Registrations</title>

    <para>When an HTTP request comes in from a client, the Http Service checks
    to see if the requested URI matches any registered aliases. A URI matches
    only if the path part of the URI is exactly the same string. Matching is
    case sensitive.</para>

    <para>If it does match, a matching registration takes place, which is
    processed as follows:</para>

    <orderedlist>
      <listitem>
        <para>If the registration corresponds to a servlet, the authorization
        is verified by calling the <code>handleSecurity</code> method of the
        associated <code>HttpContext</code> object. See <xref
        linkend="service.http.authentication"/>. If the request is authorized,
        the servlet must be called by its <code>service</code> method to
        complete the HTTP request.</para>
      </listitem>

      <listitem>
        <para>If the registration corresponds to a resource, the authorization
        is verified by calling the <code>handleSecurity</code> method of the
        associated <code>HttpContext</code> object. See <xref
        linkend="service.http.authentication"/>. If the request is authorized,
        a target resource name is constructed from the requested URI by
        substituting the alias from the registration with the internal name
        from the registration if the alias is not "/". If the alias is "/",
        then the target resource name is constructed by prefixing the
        requested URI with the internal name. An internal name of "/" is
        considered to have the value of the empty string ("") during this
        process.</para>
      </listitem>

      <listitem>
        <para>The target resource name must be passed to the
        <code>getResource</code> method of the associated
        <code>HttpContext</code> object.</para>
      </listitem>

      <listitem>
        <para>If the returned <code>URL</code> object is not
        <code>null</code>, the Http Service must return the contents of the
        <code>URL</code> to the client completing the HTTP request. The
        translated target name, as opposed to the original requested URI, must
        also be used as the argument to
        <code>HttpContext.getMimeType</code>.</para>
      </listitem>

      <listitem>
        <para>If the returned <code>URL</code> object is <code>null</code>,
        the Http Service continues as if there was no match.</para>
      </listitem>

      <listitem>
        <para>If there is no match, the Http Service must attempt to match
        sub-strings of the requested URI to registered aliases. The
        sub-strings of the requested URI are selected by removing the last
        <code>"/"</code> and everything to the right of the last "/".</para>
      </listitem>
    </orderedlist>

    <para>The Http Service must repeat this process until either a match is
    found or the sub-string is an empty string. If the sub-string is empty and
    the alias <code>"/"</code> is registered, the request is considered to
    match the alias <code>"/"</code>. Otherwise, the Http Service must return
    <code>HttpServletResponse.SC_NOT_FOUND(404)</code> to the client.</para>

    <para>For example, an HTTP request comes in with a request URI of
    <code>"/fudd/bugs/foo.txt"</code>, and the only registered alias is
    <code>"/fudd"</code>. A search for <code>"/fudd/bugs/foo.txt"</code> will
    not match an alias. Therefore, the Http Service will search for the alias
    "<code>/fudd/bugs"</code> and the alias "<code>/fudd"</code>. The latter
    search will result in a match and the matched alias registration must be
    used.</para>

    <para>Registrations for identical aliases are not allowed. If a bundle
    registers the alias "<code>/fudd"</code>, and another bundle tries to
    register the exactly the same alias, the second caller must receive a
    <code>NamespaceException</code> and its resource or servlet must
    <emphasis>not</emphasis> be registered. It could, however, register a
    similar alias - for example, "<code>/fudd/bugs"</code>, as long as no
    other registration for this alias already exists.</para>

    <para>The following table shows some examples of the usage of the
    name-space.</para>

    <table>
      <title>Examples of Name-space Mapping</title>

      <tgroup cols="4">
        <thead>
          <row>
            <entry>Alias</entry>

            <entry>Internal Name</entry>

            <entry>URI</entry>

            <entry>getResource Parameter</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>/</code></entry>

            <entry><code>(empty string)</code></entry>

            <entry><code>/fudd/bugs</code></entry>

            <entry><code>/fudd/bugs</code></entry>
          </row>

          <row>
            <entry><code>/</code></entry>

            <entry><code>/</code></entry>

            <entry><code>/fudd/bugs</code></entry>

            <entry><code>/fudd/bugs</code></entry>
          </row>

          <row>
            <entry><code>/</code></entry>

            <entry><code>/tmp</code></entry>

            <entry><code>/fudd/bugs</code></entry>

            <entry><code>/tmp/fudd/bugs</code></entry>
          </row>

          <row>
            <entry><code>/fudd</code></entry>

            <entry><code>(empty string)</code></entry>

            <entry><code>/fudd/bugs</code></entry>

            <entry><code>/bugs</code></entry>
          </row>

          <row>
            <entry><code>/fudd</code></entry>

            <entry><code>/</code></entry>

            <entry><code>/fudd/bugs</code></entry>

            <entry><code>/bugs</code></entry>
          </row>

          <row>
            <entry><code>/fudd</code></entry>

            <entry><code>/tmp</code></entry>

            <entry><code>/fudd/bugs</code></entry>

            <entry><code>/tmp/bugs</code></entry>
          </row>

          <row>
            <entry><code>/fudd</code></entry>

            <entry><code>tmp</code></entry>

            <entry><code>/fudd/bugs/x.gif</code></entry>

            <entry><code>tmp/bugs/x.gif</code></entry>
          </row>

          <row>
            <entry><code>/fudd/bugs/x.gif</code></entry>

            <entry><code>tmp/y.gif</code></entry>

            <entry><code>/fudd/bugs/x.gif</code></entry>

            <entry><code>tmp/y.gif</code></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section>
    <title>The Default Http Context Object</title>

    <para>The <code>HttpContext</code> object in the first example
    demonstrates simple implementations of the <xref
    linkend="org.osgi.service.http.HttpContext" xrefstyle="hyperlink"/>
    interface methods. Alternatively, the example could have used a default
    <code>HttpContext</code> object, as demonstrated in the following call to
    <code>registerServlet</code>:</para>

    <programlisting>getHttpService().registerServlet(
    "/servletAlias", 
    myServlet,
    initparams, 
    null
); </programlisting>

    <para>In this case, the Http Service implementation must call
    <code>createDefault HttpContext</code> and use the return value as the
    <code>HttpContext</code> argument.</para>

    <para>If the default <code>HttpContext</code> object, and thus the
    <code>ServletContext</code> object, is to be shared by multiple servlet
    registrations, the previous servlet registration example code needs to be
    changed to use the same default <code>HttpContext</code> object. This
    change is demonstrated in the next example:</para>

    <programlisting>HttpContext defaultContext =
    getHttpService().createDefaultHttpContext();

getHttpService().registerServlet(   
    "/servletAlias", 
    myServlet, 
    initparams, 
    defaultContext
);

// defaultContext can be reused 
// for further servlet registrations</programlisting>
  </section>

  <section xml:id="i1243471">
    <title>Multipurpose Internet Mail Extension (MIME) Types</title>

    <para>MIME defines an extensive set of headers and procedures to encode
    binary messages in US-ASCII mails. For an overview of all the related
    RFCs, consult <xref linkend="i1219807"/>.</para>

    <para>An important aspect of this extension is the type (file format)
    mechanism of the binary messages. The type is defined by a string
    containing a general category (text, application, image, audio and video,
    multipart, and message) followed by a "/" and a specific media type, as in
    the example, <code>"text/html"</code> for HTML formatted text files. A
    MIME type string can be followed by additional specifiers by separating
    <code>key=value</code> pairs with a semicolon (<code>';' \u003B</code>).
    These specifiers can be used, for example, to define character sets as
    follows:</para>

    <programlisting>text/plain ; charset=iso-8859-1</programlisting>

    <para>The Internet Assigned Number Authority (IANA) maintains a set of
    defined MIME media types. This list can be found at <xref
    linkend="i1220020"/>. MIME media types are extendable, and when any part
    of the type starts with the prefix <code>"x-"</code>, it is assumed to be
    vendor-specific and can be used for testing. New types can be registered
    as described in <xref linkend="i1220024"/>.</para>

    <para>HTTP bases its media typing on the MIME RFCs. The "Content-Type"
    header should contain a MIME media type so that the browser can recognize
    the type and format the content correctly.</para>

    <para>The source of the data must define the MIME media type for each
    transfer. Most operating systems do not support types for files, but use
    conventions based on file names, such as the last part of the file name
    after the last ".". This extension is then mapped to a media type.</para>

    <para>Implementations of the Http Service should have a reasonable default
    of mapping common extensions to media types based on file
    extensions.</para>

    <table>
      <title>Sample Extension to MIME Media Mapping</title>

      <tgroup cols="3">
        <colspec colnum="1"/>

        <colspec colnum="2" colwidth="2*"/>

        <colspec colnum="3" colwidth="4*"/>

        <thead>
          <row>
            <entry>Extension</entry>

            <entry>MIME media type</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><para><code>.jpg .jpeg</code></para></entry>

            <entry><para><code>image/jpeg</code></para></entry>

            <entry><para>JPEG Files</para></entry>
          </row>

          <row>
            <entry><para><code>.gif</code></para></entry>

            <entry><para><code>image/gif</code></para></entry>

            <entry><para>GIF Files</para></entry>
          </row>

          <row>
            <entry><para><code>.css</code></para></entry>

            <entry><para><code>text/css</code></para></entry>

            <entry><para>Cascading Style Sheet Files</para></entry>
          </row>

          <row>
            <entry><para><code>.txt</code></para></entry>

            <entry><para><code>text/plain</code></para></entry>

            <entry><para>Text Files</para></entry>
          </row>

          <row>
            <entry><para><code>.wml</code></para></entry>

            <entry><para><code>text/vnd.wap.wml</code></para></entry>

            <entry><para>Wireless Access Protocol (WAP) Mark
            Language</para></entry>
          </row>

          <row>
            <entry><para><code>.htm .html</code></para></entry>

            <entry><para><code>text/html</code></para></entry>

            <entry><para>Hyper Text Markup Language</para></entry>
          </row>

          <row>
            <entry><para><code>.wbmp</code></para></entry>

            <entry><para><code>image/vnd.wap.wbmp</code></para></entry>

            <entry><para>Bitmaps for WAP</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Only the bundle developer, however, knows exactly which files have
    what media type. The <code>HttpContext</code> interface can therefore be
    used to map this knowledge to the media type. The <code>HttpContext</code>
    class has the following method for this:
    <code>getMimeType(String)</code>.</para>

    <para>The implementation of this method should inspect the file name and
    use its internal knowledge to map this name to a MIME media type.</para>

    <para>Simple implementations can extract the extension and look up this
    extension in a table.</para>

    <para>Returning <code>null</code> from this method allows the Http Service
    implementation to use its default mapping mechanism.</para>
  </section>

  <section xml:id="service.http.authentication">
    <title>Authentication</title>

    <para>The Http Service has separated the authentication and authorization
    of a request from the execution of the request. This separation allows
    bundles to use available <code>Servlet</code> sub-classes while still
    providing bundle specific authentication and authorization of the
    requests.</para>

    <para>Prior to servicing each incoming request, the Http Service calls the
    <xref
    linkend="org.osgi.service.http.HttpContext.handleSecurity-javax.servlet.http.HttpServletRequest-javax.servlet.http.HttpServletResponse-"
    xrefstyle="hyperlink"/> method on the <code>HttpContext</code> object that
    is associated with the request URI. This method controls whether the
    request is processed in the normal manner or an authentication error is
    returned.</para>

    <para>If an implementation wants to authenticate the request, it can use
    the authentication mechanisms of HTTP. See <xref linkend="i1220308"/>.
    These mechanisms normally interpret the headers and decide if the user
    identity is available, and if it is, whether that user has authenticated
    itself correctly.</para>

    <para>There are many different ways of authenticating users, and the
    <code>handleSecurity</code> method on the <code>HttpContext</code> object
    can use whatever method it requires. If the method returns
    <code>true</code>, the request must continue to be processed using the
    potentially modified <code>HttpServletRequest</code> and
    <code>HttpServletResponse</code> objects. If the method returns
    <code>false</code>, the request must <emphasis>not</emphasis> be
    processed.</para>

    <para>A common standard for HTTP is the basic authentication scheme that
    is not secure when used with HTTP. Basic authentication passes the
    password in base 64 encoded strings that are trivial to decode into clear
    text. Secure transport protocols like HTTPS use SSL to hide this
    information. With these protocols basic authentication is secure.</para>

    <para>Using basic authentication requires the following steps:</para>

    <orderedlist>
      <listitem>
        <para>If no <code>Authorization</code> header is set in the request,
        the method should set the <code>WWW-Authenticate</code> header in the
        response. This header indicates the desired authentication mechanism
        and the realm. For example, <code>WWW-Authenticate: Basic
        realm="ACME"</code>.</para>

        <para>The header should be set with the response object that is given
        as a parameter to the <code>handleSecurity</code> method. The
        <code>handleSecurity</code> method should set the status to
        <code>HttpServletResponse.SC_UNAUTHORIZED (401)</code> and return
        <code>false</code>.</para>
      </listitem>

      <listitem>
        <para>Secure connections can be verified with the
        <code>ServletRequest.getScheme()</code> method. This method returns,
        for example, "<code>https</code>" for an SSL connection; the
        <code>handleSecurity</code> method can use this and other information
        to decide if the connection's security level is acceptable. If not,
        the <code>handleSecurity</code> method should set the status to
        <code>HttpServletResponse.SC_FORBIDDEN</code> (403) and return
        <code>false</code>.</para>
      </listitem>

      <listitem>
        <para>Next, the request must be authenticated. When basic
        authentication is used, the <code>Authorization</code> header is
        available in the request and should be parsed to find the user and
        password. See <xref linkend="i1220308"/> for more information.</para>

        <para>If the user cannot be authenticated, the status of the response
        object should be set to <code>HttpServletResponse.SC_UNAUTHORIZED
        (401)</code> and return <code>false</code>.</para>
      </listitem>

      <listitem>
        <para>The authentication mechanism that is actually used and the
        identity of the authenticated user can be of interest to the
        <code>Servlet</code> object. Therefore, the implementation of the
        <code>handleSecurity</code> method should set this information in the
        request object using the <code>ServletRequest.setAttribute</code>
        method. This specification has defined a number of OSGi-specific
        attribute names for this purpose:</para>

        <itemizedlist>
          <listitem>
            <para><xref
            linkend="org.osgi.service.http.HttpContext.AUTHENTICATION_TYPE"
            xrefstyle="hyperlink"/> - Specifies the scheme used in
            authentication. A Servlet may retrieve the value of this attribute
            by calling the <code>HttpServletRequest.getAuthType</code> method.
            This attribute name is
            <code>org.osgi.service.http.authentication.type</code>.</para>
          </listitem>

          <listitem>
            <para><xref
            linkend="org.osgi.service.http.HttpContext.REMOTE_USER"
            xrefstyle="hyperlink"/> - Specifies the name of the authenticated
            user. A Servlet may retrieve the value of this attribute by
            calling the <code>HttpServletRequest.getRemoteUser</code> method.
            This attribute name is
            <code>org.osgi.service.http.authentication.remote.user</code>.</para>
          </listitem>

          <listitem>
            <para><xref
            linkend="org.osgi.service.http.HttpContext.AUTHORIZATION"
            xrefstyle="hyperlink"/> - If a User Admin service is available in
            the environment, then the <code>handleSecurity</code> method
            should set this attribute with the <code>Authorization</code>
            object obtained from the User Admin service. Such an object
            encapsulates the authentication of its remote user. A Servlet may
            retrieve the value of this attribute by calling
            <code>ServletRequest.getAttribute(HttpContext.AUTHORIZATION)</code>.
            This header name is
            <code>org.osgi.service.useradmin.authorization</code>.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Once the request is authenticated and any attributes are set,
        the <code>handleSecurity</code> method should return
        <code>true</code>. This return indicates to the Http Service that the
        request is authorized and processing may continue. If the request is
        for a Servlet, the Http Service must then call the
        <code>service</code> method on the <code>Servlet</code> object.</para>
      </listitem>
    </orderedlist>
  </section>

  <section>
    <title>Security</title>

    <para>This section only applies when executing in an OSGi environment
    which is enforcing Java permissions.</para>

    <section>
      <title>Accessing Resources with the Default Http Context</title>

      <para>The Http Service must be granted
      <code>AdminPermission[*,RESOURCE]</code> so that bundles may use a
      default <code>HttpContext</code> object. This is necessary because the
      implementation of the default <code>HttpContext</code> object must call
      <code>Bundle.getResource</code> to access the resources of a bundle and
      this method requires the caller to have
      <code>AdminPermission[bundle,RESOURCE]</code>.</para>

      <para>Any bundle may access resources in its own bundle by calling
      <code>Class.getResource</code>. This operation is privileged. The
      resulting <code>URL</code> object may then be passed to the Http Service
      as the result of a <code>HttpContext.getResource</code> call. No further
      permission checks are performed when accessing bundle resource
      <code>URL</code> objects, so the Http Service does not need to be
      granted any additional permissions.</para>
    </section>

    <section>
      <title>Accessing Other Types of Resources</title>

      <para>In order to access resources that were not registered using the
      default <code>HttpContext</code> object, the Http Service must be
      granted sufficient privileges to access these resources. For example, if
      the <code>getResource</code> method of the registered
      <code>HttpContext</code> object returns a file URL, the Http Service
      requires the corresponding <code>FilePermission</code> to read the file.
      Similarly, if the <code>getResource</code> method of the registered
      <code>HttpContext</code> object returns an HTTP URL, the Http Service
      requires the corresponding <code>SocketPermission</code> to connect to
      the resource.</para>

      <para>Therefore, in most cases, the Http Service should be a privileged
      service that is granted sufficient permission to serve any bundle's
      resources, no matter where these resources are located. Therefore, the
      Http Service must capture the <code>AccessControlContext</code> object
      of the bundle registering resources or a servlet, and then use the
      captured <code>AccessControlContext</code> object when accessing
      resources returned by the registered <code>HttpContext</code> object.
      This situation prevents a bundle from registering resources that it does
      not have permission to access.</para>

      <para>Therefore, the Http Service should follow a scheme like the
      following example. When a resource or servlet is registered, it should
      capture the context.</para>

      <programlisting>AccessControlContext acc = 
        AccessController.getContext();</programlisting>

      <para>When a URL returned by the <code>getResource</code> method of the
      associated <code>HttpContext</code> object is called, the Http Service
      must call the <code>getResource</code> method in a
      <code>doPrivileged</code> construct using the
      <code>AccessControlContext</code> object of the registering
      bundle:</para>

      <programlisting>AccessController.doPrivileged(
    new PrivilegedExceptionAction() {
        public Object run() throws Exception {
        ...
        }
    }, acc);</programlisting>

      <para>The Http Service must only use the captured
      <code>AccessControlContext</code> when accessing resource
      <code>URL</code> objects.</para>
    </section>

    <section>
      <title>Servlet and HttpContext objects</title>

      <para>This specification does not require that the Http Service is
      granted All Permission or wraps calls to the Servlet and Http Context
      objects in a <code>doPrivileged</code> block. Therefore, it is the
      responsibility of the Servlet and Http Context implementations to use a
      <code>doPrivileged</code> block when performing privileged
      operations.</para>
    </section>
  </section>

  <section>
    <title>Configuration Properties</title>

    <para>If the Http Service does not have its port values configured through
    some other means, the Http Service implementation should use the following
    properties to determine the port values upon which to listen.</para>

    <para>The following OSGi environment properties are used to specify
    default HTTP ports:</para>

    <itemizedlist>
      <listitem>
        <para><code>org.osgi.service.http.port</code> - This property
        specifies the port used for servlets and resources accessible via
        HTTP. The default value for this property is 80.</para>
      </listitem>

      <listitem>
        <para><code>org.osgi.service.http.port.secure</code> - This property
        specifies the port used for servlets and resources accessible via
        HTTPS. The default value for this property is 443.</para>
      </listitem>
    </itemizedlist>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.http.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i1231452"><title>HTTP 1.0 Specification
      RFC-1945</title><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc1945.txt"/>, May
      1996</biblioid></bibliomixed>

      <bibliomixed xml:id="i1215926"><title>HTTP 1.1 Specification
      RFC-2616</title><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc2616.txt"/>, June
      1999</biblioid></bibliomixed>

      <bibliomixed xml:id="i1217577"><title>Java Servlet
      Technology</title><biblioid class="uri"><link
      xlink:href="https://www.oracle.com/java/technologies/servlet-technology.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1219807"><title>MIME Multipurpose Internet Mail
      Extension</title><biblioid class="uri"><link
      xlink:href="https://www.mhonarc.org/~ehood/MIME/MIME.html"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1220020"><title>Assigned MIME Media
      Types</title><biblioid class="uri"><link
      xlink:href="https://www.iana.org/assignments/media-types/media-types.xhtml"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1220024"><title>Registration Procedures for new
      MIME media
      types</title><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc2048.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1220308"><title>RFC 2617: HTTP Authentication:
      Basic and Digest Access
      Authentication</title><biblioid class="uri"><link
      xlink:href="https://www.ietf.org/rfc/rfc2617.txt"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
