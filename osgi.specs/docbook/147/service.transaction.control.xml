<?xml version="1.0" encoding="utf-8"?>
<chapter label="147"
         revision="$Id$"
         version="5" xml:id="service.transaction.control"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Transaction Control Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.transaction.control-version"
    linkend="org.osgi.service.transaction.control"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>Software Transactions are an important aspect of most modern
    applications. The job of a Transaction is to ensure logical consistency
    for units of work within the application. Any time that the application
    accesses a persistent external resource then a Transaction ensures that
    the set of changes made to the resource(s) are Atomic, Consistent,
    Isolated, and Durable (ACID).</para>

    <para>There are a variety of techniques for managing the lifecycle of
    software Transactions used in an application. The most primitive
    mechanisms are for the application code to directly interact with the
    Transaction Manager, but higher level abstractions can automatically
    manage the lifecycle of Transactions through the use of Aspect Oriented
    Programming. Whatever techniques are used to manage the Transaction
    lifecycle it is also necessary for any resource access that occurs within
    the Transaction to be registered with the Transaction manager. As with
    managing the Transaction lifecycle, this work may be performed by the
    client, or by a an intermediate framework without direct action from the
    client.</para>

    <para>OSGi applications consist of a set of independent modules which
    interact via the OSGi service registry; as such there is no single
    container which can be relied upon to manage the range of tasks needed to
    successfully use a Transaction. This leaves OSGi clients with little
    choice but to depend on specific environments, sacrificing portability, or
    to directly use Transactions via the <xref linkend="service.jta"/>. The
    purpose of the Transaction Control Service is twofold:</para>

    <itemizedlist>
      <listitem>
        <para>To enable a portable, modular abstraction for Transaction
        lifecycle management</para>
      </listitem>

      <listitem>
        <para>To allow different resource types to be easily used within a
        Transaction</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Scoped Work</emphasis> - A function or code block
          with an associated execution context, known as a Scope. The Scope
          may be <emphasis>Transactional</emphasis>, that is, associated with
          a Transaction, or a <emphasis>No Transaction Scope</emphasis>, that
          is, with no associated Transaction.</para>
        </listitem>

        <listitem>
          <para><emphasis>Client</emphasis> - Application code that wishes to
          invoke one or more pieces of Scoped Work.</para>
        </listitem>

        <listitem>
          <para><emphasis>Transaction Control Service</emphasis> - The OSGi
          service representing the Transaction Control Service implementation.
          Used by the Client to execute pieces of Scoped Work.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resource</emphasis> - A local or remote software
          component which is stateful and can participate in a
          transaction.</para>
        </listitem>

        <listitem>
          <para><emphasis>Resource Provider</emphasis> - A service or object
          which provides managed access to a Scoped Resource, that is, a
          managed connection to the Resource which integrates with ongoing
          Transactions as necessary.</para>
        </listitem>

        <listitem>
          <para><emphasis>Transaction Context</emphasis> - A Java object
          representing the state of a Scope</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Class and Service overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.100in"
                       contentwidth="7.000in"
                       fileref="transaction-control-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Transaction Control Service</emphasis> - A service
          that can execute pieces of work within a Scope, and be queried to
          establish the current Scope.</para>
        </listitem>

        <listitem>
          <para><emphasis>Client</emphasis> - The code that requests for Work
          to be run in a particular Scope.</para>
        </listitem>

        <listitem>
          <para><emphasis>Work</emphasis> - A collection of instructions that
          interact with zero or more Resources within a Scope</para>
        </listitem>

        <listitem>
          <para><emphasis>Scoped Resource</emphasis> - A resource connection
          with a managed lifecycle. The connection will automatically
          participate in Transactions associated with Transactional Scopes,
          and its lifecycle is tied to the Scope within which it is
          used.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Usage</title>

    <para>This section is an introduction in the usage of the Transaction
    Control Service. It is not the formal specification, the normative part
    starts at <xref linkend="service.transaction.control-main.body"/>. This
    section leaves out some of the details for clarity.</para>

    <section>
      <title>Synopsis</title>

      <para>The Transaction Control Service provides a mechanism for a client
      to run work within a defined Scope. Typically a Scope is also associated
      with a Transaction. The purpose of a Scope is to simplify the lifecycle
      of resources, and to allow those resources to participate in any ongoing
      Transaction. Any Scoped Resources accessed during a Scope will remain
      available throughout the scope, and be automatically cleaned up when the
      Scope completes.</para>

      <para>Each Scope is started by the Client by passing piece of work to
      the Transaction Control Service. The transaction control service will
      then begin a scope if needed, execute the work, and then complete the
      scope if needed. The different methods on the Transaction Control
      Service provide different lifecycle semantics for the Scope. Some
      methods establish a Transactional Scope, others may suspend an active
      Transactional Scope replacing it with a No Transaction Scope.</para>

      <para>When a piece of Scoped Work is executing it may access one or more
      Scoped Resources. When a Scoped Resource is first accessed within a
      Scope it is bound to that Scope so that future accesses use the same
      physical resource. At the end of the Scope the resource is detached from
      the scope and the physical resource is released. If the Scope is
      Transactional then the Scoped Resource will also participate in the
      transaction.</para>

      <para>At the end of a piece of Scoped Work the Scope is finished. For a
      No Transaction Scope this simply involves calling any registered
      callbacks. For a Transactional Scope, however, the Transaction must be
      completed or rolled back. If the Scoped Work exits normally, and no call
      has been made to force the Transaction to roll back, then the
      Transaction will commit. If, however, the Work exits with an Exception
      or the Transaction has been marked for roll back, then the Transaction
      will roll back. The result of the Work then flows back to the caller in
      an appropriate way.</para>
    </section>

    <section xml:id="service.transaction.control-simple-usage">
      <title>Running Scoped Work</title>

      <para>The general pattern for a client is to obtain the Transaction
      Control Service and one or more Resource Provider instances. The
      Resource Provider(s) may come from the Service Registry, or from a
      Factory, and are used to create Scoped Resource instances. These
      instances can then be used in the scoped work. This is demonstrated in
      the following example:</para>

      <programlisting>
      
@Reference
TransactionControl control;

Connection connection;

@Reference
void setResourceProvider(JDBCConnectionProvider provider) {
    connection = provider.getResrouce(control)
}

public void addMessage(String message) {
    control.required(() -&gt; {
            PreparedStatement ps = connection.prepareStatement(
                            "Insert into TEST_TABLE values ( ? )");
                    ps.setString(1, message);
                    return ps.executeUpdate();
        });
}

public List&lt;String&gt; listMessages(String message) {
    control.notSupported(() -&gt; {
            List&lt;String&gt; results = new ArrayList&lt;String&gt;();
            ResultSet rs = connection.createStatement()
                    .executeQuery("Select * from TEST_TABLE");
            while(rs.next()) {
                results.add(rs.getString(1));
            }
            return results;
        });
}

      </programlisting>

      <para>This example demonstrates how simply clients can execute scoped
      work using the Transaction Control Service. In this case write
      operations always occur in a Transactional Scope, but read operations
      may occur in a Transactional Scope <emphasis>or</emphasis> a No
      Transaction Scope. In all cases the lifecycle of the underlying
      connection is automatically managed, and there is no need to close or
      commit the connection.</para>
    </section>

    <section>
      <title>Accessing Scoped Resources</title>

      <para>The Transaction Control Service can be used to manage the Scope of
      any piece of Work, but Scopes are primarily used to simplify resource
      lifecycle management when using Scoped Resources. A Scoped Resource is
      created using a Resource Provider, and the returned object can then be
      used in any scope to access the associated Resource.</para>

      <para>The example in <xref
      linkend="service.transaction.control-simple-usage"/> uses a
      <code>JDBCConnectionProvider</code>, which is a specialization of the
      generic <code>ResourceProvider</code> interface that returns JDBC
      <code>Connection</code> objects. Other specializations of the Resource
      Provider exist in this specification, and third party providers may
      provide their own specializations for proprietary resource types.</para>

      <para>Once a Resource Provider has been obtained, a Scoped Resource is
      created from it by passing the Transaction Control Service to the
      <code>getResource</code> method. This returns the Scoped Resource object
      that can then be used in Scoped Work.</para>
    </section>

    <section>
      <title>Exception Management</title>

      <para>One of the most significant sources of error in applications that
      use transactions is caused by incorrect Exception Handling. These errors
      are the primary reason for using a framework or container to manage
      transactions, rather than trying to manage them in the application
      code.</para>

      <para>Exceptions tend to be more common in code that makes use of
      transactions because the code is usually performing actions that may
      fail, for example making updates to a database. Also, many of these
      exceptions (such as <code>java.sql.SQLException</code>) are checked
      exceptions. As Scoped Work will typically raise both checked and
      unchecked exceptions it is defined as a <code>Callable</code>. As the
      callable interface <code>throws Exception</code> it is not necessary to
      catch or wrap any exception generated within Scoped Work.</para>

      <programlisting>
// An SQLException may be raised by the query, 
// but we don't need to catch it
control.required(() -&gt; connection.createStatement()
    .executeQuery("Insert into TEST_TABLE values ( 'Hello World!' )"));
      </programlisting>

      <para>An exception indicates that a problem has occurred in a piece of
      code therefore, by default, any exception thrown from inside a
      Transactional Scope will cause the Transaction to roll back. This means
      that the Scoped Work can safely ignore any updates that were made in the
      event of an exception.</para>

      <section>
        <title>Handling Exceptions</title>

        <para>Scoped Work is free to throw checked or unchecked exceptions,
        however these exceptions cannot be directly thrown on by the
        Transaction Control Service. The primary reason for this is that
        directly rethrowing the exception would force users of the Transaction
        Control Service to either:</para>

        <itemizedlist>
          <listitem>
            <para>Declare <code>throws Exception</code> on the calling
            method</para>
          </listitem>

          <listitem>
            <para>Add <code>try/catch Exception</code> blocks around the calls
            to the Transaction Control Service.</para>
          </listitem>
        </itemizedlist>

        <para>Both of these solutions are undesirable, as they force
        unnecessary boilerplate code, and potentially shadow real checked
        exceptions in the API. Exceptions generated as part of Scoped Work are
        therefore wrapped by the Transaction Control Service in a
        <code>ScopedWorkException</code>. <code>ScopedWorkException</code> is
        an unchecked exception and so can be ignored if no special handling is
        required.</para>

        <para>In the case where the callers API requires the unwrapped
        exception type to be thrown a <code>ScopedWorkException</code> can be
        easily unwrapped using the <code>as</code> method.</para>

        <programlisting>
        
try {
    control.required(() -&gt; connection.createStatement()
        .executeQuery("Insert into TEST_TABLE values ( 'Hello World!' )"));
} catch (ScopedWorkException swe) {
    // This line throws the cause of the ScopedWorkException as
    // an SQLException or as a RuntimeException if appropriate
    throw swe.as(SQLException.class);
}        
        
        </programlisting>

        <para>If there is more than one potential checked Exception type that
        should be rethrown then the <code>asOneOf</code> method can be
        used.</para>

        <programlisting>
        
try {
    control.required(() -&gt; connection.createStatement()
        .executeQuery("Insert into TEST_TABLE values ( 'Hello World!' )"));
} catch (ScopedWorkException swe) {
    // This line throws the cause of the ScopedWorkException as
    // an SQLException or as a RuntimeException if appropriate
    throw swe.asOneOf(SQLRecoverableException.class, SQLTransientException.class);
}        
        
        </programlisting>
      </section>

      <section>
        <title>Avoiding Transaction Rollback</title>

        <para>In general if a piece of Work running in a Transactional Scope
        exits with an exception the associated Transaction will roll back.
        Sometimes, however, certain exception types should not cause the
        Transaction to roll back. This can be indicated to the Transaction
        Control Service when the Scope is being declared.</para>

        <programlisting>
        
control.build()
    .noRollbackFor(URISyntaxException.class)
    .required(() -&gt; {
            ...
        });    
        
        </programlisting>

        <para>In this example the Transaction does not roll back for any
        <code>URISyntaxException</code>. Sometimes this is too coarse grained,
        and the Transaction should only avoid rolling back for one specific
        exception instance. In this case the instance can be passed to the
        Transaction Control Service <code>ignoreException</code>
        method.</para>

        <programlisting>
        
control.required(() -&gt; {
        try {    
            // A URISynaxException from here is safe
            ...
        } catch (URISyntaxException e) {
            control.ignoreException(e);
            throw e;
        }
        // A URISynaxException from here is *not* safe
        ...
    });    
        
        </programlisting>
      </section>
    </section>

    <section>
      <title>Multi Threading</title>

      <para>By its very definition a Scope is associated with a single piece
      of Work, and therefore a single thread. If a piece of Scoped Work starts
      new threads, or submits tasks to other threads, then any code executed
      on those threads will not occur within the Scope.</para>

      <para>Scoped Resources are always thread-safe, and can be used
      concurrently in different Scopes. This is true even if the underlying
      physical resources are not thread safe. It is the responsibility of the
      Scoped Resource implementation to ensure that the underlying physical
      resources are protected correctly.</para>
    </section>
  </section>

  <section xml:id="service.transaction.control-main.body">
    <title>Transaction Control Service</title>

    <para>The Transaction Control Service is the primary interaction point
    between a client and the Transaction Control Service implementation. A
    Transaction Control Service implementation must expose a service
    implementing the <xref
    linkend="org.osgi.service.transaction.control.TransactionControl"
    xrefstyle="hyperlink"/> interface.</para>

    <para>Clients obtain an instance of the Transaction Control Service using
    the normal OSGi service registry mechanisms, either directly using the
    OSGi framework API, or using dependency injection.</para>

    <para>The Transaction Control Service is used to:</para>

    <itemizedlist>
      <listitem>
        <para>Execute work within a defined scope</para>
      </listitem>

      <listitem>
        <para>Query the current execution scope</para>
      </listitem>

      <listitem>
        <para>Associate objects with the current execution scope</para>
      </listitem>

      <listitem>
        <para>Register for callbacks when the scope ends</para>
      </listitem>

      <listitem>
        <para>Enlist resource with the current transaction (if there is a
        Transaction Scope active)</para>
      </listitem>

      <listitem>
        <para>Mark the current scope for rollback (if there is a Transaction
        scope)</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Scope Lifecycle</title>

      <para>The lifecycle of a scope is tied to the execution of a piece of
      scoped work. Unless a scope is being inherited then a scope starts
      immediately before the scoped work executes and ends immediately after
      the scoped work completes, even if the scoped work throws an
      exception.</para>

      <para>The first action that a client wishing to execute scoped work must
      take is to identify the type of scope that they wish to use. The work
      should then be passed to the relevant method on the TransactionControl
      service:</para>

      <table>
        <title>Methods for executing scoped work</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1.2*"/>

          <colspec colnum="2" colwidth="1.5*"/>

          <colspec colnum="3" colwidth="3.3*"/>

          <thead>
            <row>
              <entry>Method Name</entry>

              <entry>Existing Scope</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>required()</code></entry>

              <entry>Unscoped</entry>

              <entry><para>Begins a new Transaction scope and executes the
              work inside it</para></entry>
            </row>

            <row>
              <entry><code>required()</code></entry>

              <entry>No Transaction scope</entry>

              <entry><para>Suspends the No Transaction Scope and begins a new
              Transaction scope, executing the work inside it. After the work
              completes the original scope is restored.</para></entry>
            </row>

            <row>
              <entry><code>required()</code></entry>

              <entry>Transaction scope</entry>

              <entry><para>Runs the work within the existing
              scope</para></entry>
            </row>

            <row>
              <entry><code>requiresNew()</code></entry>

              <entry>Unscoped</entry>

              <entry><para>Begins a new Transaction scope and executes the
              work inside it</para></entry>
            </row>

            <row>
              <entry><code>requiresNew()</code></entry>

              <entry>No Transaction scope</entry>

              <entry><para>Suspends the No Transaction Scope and begins a new
              Transaction scope, executing the work inside it. After the work
              completes the original scope is restored.</para></entry>
            </row>

            <row>
              <entry><code>requiresNew()</code></entry>

              <entry>Transaction scope</entry>

              <entry><para>Suspends the Transaction Scope and begins a new
              Transaction scope, executing the work inside it. After the work
              completes the original scope is restored.</para></entry>
            </row>

            <row>
              <entry><code>supports()</code></entry>

              <entry>Unscoped</entry>

              <entry><para>Begins a new No Transaction scope and executes the
              work inside it</para></entry>
            </row>

            <row>
              <entry><code>supports()</code></entry>

              <entry>No Transaction scope</entry>

              <entry><para>Runs the work within the existing
              scope</para></entry>
            </row>

            <row>
              <entry><code>supports()</code></entry>

              <entry>Transaction scope</entry>

              <entry><para>Runs the work within the existing
              scope</para></entry>
            </row>

            <row>
              <entry><code>notSupported()</code></entry>

              <entry>Unscoped</entry>

              <entry><para>Begins a new No Transaction scope and executes the
              work inside it</para></entry>
            </row>

            <row>
              <entry><code>notSupported()</code></entry>

              <entry>No Transaction scope</entry>

              <entry><para>Runs the work within the existing
              scope</para></entry>
            </row>

            <row>
              <entry><code>notSupported()</code></entry>

              <entry>Transaction scope</entry>

              <entry><para>Suspends the Transaction Scope and begins a new No
              Transaction scope, executing the work inside it. After the work
              completes the original transaction scope is
              restored.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Once the relevant method has been identified the client passes the
      scoped work to the Transaction Control Service. In the typical case the
      Transaction Control Service must then:</para>

      <orderedlist>
        <listitem>
          <para>Establish a new scope</para>
        </listitem>

        <listitem>
          <para>Execute the scoped work</para>
        </listitem>

        <listitem>
          <para>Finish the scope, calling any registered callbacks and
          committing the Transaction if the scope is a Transaction
          Scope</para>
        </listitem>

        <listitem>
          <para>Return the result of the scoped work to the client</para>
        </listitem>
      </orderedlist>

      <para>The Transaction Control Service must only finish a scope once,
      after the execution of the Scoped Work which originally started the
      scope. This means that callbacks registered by a piece of Scoped Work
      may not run immediately after the work finishes, but will be delayed
      until the parent task has finished if the scope was inherited.</para>
    </section>

    <section>
      <title>Scopes and Exception Management</title>

      <para>Resource access is intrinsically error-prone, and therefore there
      are many potential failure scenarios. Exceptions therefore form an
      important part of the scope lifecycle.</para>

      <section>
        <title>Client Exceptions</title>

        <para>The work provided by the client to the Transaction Control
        Service is passed as a <code>Callable</code>, meaning that the work
        may throw an Exception. An Exception thrown by the work is known as a
        <emphasis>Client Exception</emphasis>.</para>

        <para>If a client exception is thrown then it must be caught by the
        Transaction Control Service and handled appropriately by finishing the
        scope as required. Once the scope has completed the client exception
        must be wrapped in a <xref
        linkend="org.osgi.service.transaction.control.ScopedWorkException"
        xrefstyle="hyperlink"/> and rethrown by the Transaction Control
        service.</para>

        <para>If a number of scopes are nested then a ScopedWorkException may
        be received as a client Exception. A ScopedWorkException must not be
        re-wrapped by the Transaction Control Service using the normal
        Exception chaining mechanism, but instead a new ScopedWorkException
        must be created initialized with the original cause. The caught
        ScopedWorkException must then be added to the new ScopedWorkException
        as a suppressed Exception. This prevents clients from having to deeply
        introspect the exception cause chain to locate the original
        error.</para>
      </section>

      <section>
        <title>Rethrowing Client Exceptions</title>

        <para>In the general case clients will not need to catch a
        ScopedWorkException, and it can be left to report/handle at a higher
        level. Sometimes, however, the Exceptions thrown by a piece of work
        represent an important part of the API, and they need to be thrown on
        without being wrapped in a ScopedWorkException. The
        ScopedWorkException provides a simple mechanism to do this. The client
        simply calls one of the <xref
        linkend="org.osgi.service.transaction.control.ScopedWorkException.asOneOf-Class-Class-"
        xrefstyle="hyperlink"/> methods which will throw the cause of the
        Exception as one of the supplied checked Exception types, or directly
        as an unchecked Exception if the cause is unchecked.</para>

        <para>The <code>asOneOf()</code> methods always throw an Exception,
        but the method return value is declared as a RuntimeException. This
        can be used to simplify the act of rethrowing the cause when using
        this method.</para>

        <programlisting>

try {
    txControl.required(() -&gt; {
                // Do some work in here that may throw IOException
                // or ClassNotFoundException
                return result;
        });
} catch (ScopedWorkException swe) {
    throw swe.asOneOf(IOException.class, ClassNotFoundException.class);
}
          </programlisting>

        <para>If the cause of a ScopedWorkException is a checked exception,
        but that exception is not assignable to any of the types passed to the
        <code>asOneOf()</code> method then the cause of the
        ScopedWorkException will still be thrown, however there will be no
        compiler assistance for the user when writing their
        <code>throws</code> clause.</para>
      </section>

      <section>
        <title>Exceptions Generated by the Transaction Control Service</title>

        <para>Many operations performed by the Transaction Control Service,
        particularly when finishing a scope, may result in an Exception.
        Internal failures, for example a failure when attempting to commit a
        resource, must be wrapped in a <xref
        linkend="org.osgi.service.transaction.control.TransactionException"
        xrefstyle="hyperlink"/> and thrown to the client.</para>

        <para>A TransactionException must never override a
        ScopedWorkException. In the case where a ScopedWorkException should be
        thrown and a Transaction Control Service failure occurs then the
        TransactionException must be set as a suppressed exception in the
        ScopedWorkException.</para>
      </section>
    </section>

    <section>
      <title>Transaction Scope lifecycle</title>

      <para>In addition to callbacks and scoped variables Transaction scopes
      also provide an ongoing software transaction which shares the lifecycle
      of the scope. There are therefore additional lifecycle rules for
      Transaction Scopes</para>

      <section>
        <title>Triggering Rollback in Transaction Scopes</title>

        <para>By default a transaction will commit automatically when the
        piece of work completes normally. If this is not desired (for example
        if the work's business logic determines that the transaction should
        not complete) then the work may trigger a rollback in one of two
        ways.</para>

        <para>Calling <xref
        linkend="org.osgi.service.transaction.control.TransactionControl.setRollbackOnly--"
        xrefstyle="hyperlink"/> on the Transaction Control object will mark
        the transaction for rollback so that it will never commit, even if the
        method completes normally. This is a one-way operation, and the
        rollback state can be queried using <xref
        linkend="org.osgi.service.transaction.control.TransactionControl.getRollbackOnly--"
        xrefstyle="hyperlink"/></para>

        <programlisting>
txControl.required(() -&gt; {
            // Do some work in here
            ...
            // This work will not be committed!
            txControl.setRollbackOnly();
            return result;
    });      
        </programlisting>

        <para>Throwing an exception from the piece of work will, by default,
        cause the transaction to be rolled back. Note that this is different
        from Java EE behavior, where a checked exceptions <emphasis>does
        not</emphasis> trigger rollback. This is a deliberate difference as
        many applications get the wrong behavior based on this default. For
        example SQLException is a commonly thrown Exception in JDBC, but is
        rarely, if ever, a “safe return”. Forgetting to override this behavior
        means that production code will fail to enforce the correct
        transaction boundaries.</para>

        <programlisting>
txControl.required(() -&gt; {
            // Do some work in here
            ...
            // Uh oh – something went wrong!
            throw new IllegalStateException(“Kaboom!”);
    });  
        </programlisting>
      </section>

      <section>
        <title>Avoiding Rollback</title>

        <para>Sometimes it is preferable for a piece of work to throw an
        exception, but for that exception not to trigger a rollback of the
        transaction. For example some business exceptions may be considered
        “normal”, or it may be the case that the work performed so far must be
        persisted for audit reasons.</para>

        <para>There are two ways to prevent a transaction from rolling back
        when a particular exception occurs</para>

        <para>The Transaction Control service provides a <xref
        linkend="org.osgi.service.transaction.control.TransactionBuilder"
        xrefstyle="hyperlink"/>. The builder can be used to define sets of
        Exception types that should, or should not, trigger rollback. The most
        specific match will be used to determine whether the transaction
        should roll back or not.</para>

        <para>The Transaction Control service provides an <xref
        linkend="org.osgi.service.transaction.control.TransactionControl.ignoreException-Throwable-"
        xrefstyle="hyperlink"/> method. This can be used from within an Active
        Transaction to declare a specific Exception object that should not
        trigger rollback.</para>

        <para>If a transaction is marked for rollback using
        <code>setRollbackOnly()</code> then it must roll back, even if the
        work throws an exception which would not normally trigger a
        rollback.</para>
      </section>

      <section>
        <title>Rollback in inherited transactions</title>

        <para>If a piece of scoped work inherits a transaction scope then the
        transaction is not committed until the inherited scope completes.
        Therefore if the nested scoped work throws an exception then this must
        mark the transaction for rollback, unless the exception has been
        explicitly ignored or configured not to cause rollback.</para>

        <para>Any exception thrown by the nested scoped work must result in a
        <code>ScopedWorkException</code> in exactly the same way as it would
        when not nested.</para>

        <programlisting>
txControl.required(() -&gt; {
            // Do some work in here
            ...
            try {
                txControl.required(() -&gt; {
                            // The outer transaction is inherited
                            throw new RuntimeException();
                    });
            } catch (ScopedWorkException swe) {
                // The transaction is still active, but now marked for rollback
            }
    });  
        </programlisting>
      </section>

      <section>
        <title>Read Only transactions</title>

        <para>Resources accessed within a transaction are frequently used to
        update persistent data, however in some cases it is known in advance
        that no changes will be made to the data. In the case where no changes
        are going to be made then different, more optimal, algorithms can be
        used by the resource to improve performance. It is therefore useful
        for applications to be able to indicate when resources are going to be
        used in a read-only way.</para>

        <para>To indicate that a transaction is read-only the
        TransactionBuilder must be used.</para>

        <programlisting>
txControl.build()
    .readOnly()
    .required(() -&gt; {
            // Do some work in here
            ...
            return result;
        });
        </programlisting>

        <para>The readOnly method provides a hint to the TransactionControl
        service that the scoped work only uses read access to resources. The
        TransactionControl service is free to ignore this hint if it does not
        offer read-only optimizations. Also, read-only only applies to
        Transaction Scopes. No Transaction Scopes always ignore the call to
        readOnly.</para>

        <section>
          <title>Determining whether a Transaction is read only</title>

          <para>The TransactionContext provides access to whether the
          transaction is read only using the <xref
          linkend="org.osgi.service.transaction.control.TransactionContext.isReadOnly--"
          xrefstyle="hyperlink"/> method. This method will return true if the
          transaction was started using the read only flag, and the
          TransactionControl service supports read-only optimization.</para>

          <para>This method is primarily available so that resource providers
          can set their read-only status correctly when they first enlist with
          the transaction. Resource providers are free to ignore the read only
          status as it is provided for optimization only.</para>
        </section>

        <section>
          <title>Writing to resources using in a read only transaction</title>

          <para>When a client begins a transaction in read-only mode there is
          no API restriction that prevents them from writing to one or more
          resources. If the scoped work does write to the resource then the
          result is undefined. The write may succeed, or it may result in an
          exception, triggering a rollback.</para>

          <para>Clients should avoid declaring a transaction as read only
          unless they are certain that no resources are updated within the
          scope of the work. This includes any operations performed by
          external services which inherit the transaction.</para>
        </section>

        <section>
          <title>Changing the read state in nested transactions</title>

          <para>When a client begins a Transaction Scope using the required
          method then it inherits the existing Transaction Scope if it exists.
          It is not possible to change the writability of an inherited
          transaction.</para>

          <para>In the case where the inherited transaction is a writable
          transaction then the <code>readOnly()</code> state declared for the
          nested scope will be ignored. In the case where the inherited
          transaction is read only then an attempt to change the transaction
          to a writable transaction will fail with a
          TransactionException.</para>

          <para>If the nested transaction is declared using requiresNew then
          it will create a new transaction which may have a different
          writability from the outer scope.</para>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>The TransactionContext</title>

    <para>When a client uses the TransactionControl service to scope a piece
    of work, the scope gains an associated Transaction Context. The current
    transaction context is not normally needed by clients, but is an important
    integration point for ResourceProviders, and for clients that wish to
    register transaction completion callbacks.</para>

    <para>The Transaction Control Service provides methods that can be used to
    query the current transaction context.</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.service.transaction.control.TransactionControl.activeTransaction--"
        xrefstyle="hyperlink"/> - returns true if there is a Transaction scope
        associated with the currently executing work.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.transaction.control.TransactionControl.activeScope--"
        xrefstyle="hyperlink"/> - returns true if there is a Transaction Scope
        or a No Transaction Scope associated with the currently executing
        work.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.transaction.control.TransactionControl.getCurrentContext--"
        xrefstyle="hyperlink"/> - returns the current <xref
        linkend="org.osgi.service.transaction.control.TransactionContext"
        xrefstyle="hyperlink"/>, or <code>null</code> if the currently
        executing code is unscoped. If the current work has a No Transaction
        scope then the returned Transaction Context will report its status as
        <xref
        linkend="org.osgi.service.transaction.control.TransactionStatus.NO_TRANSACTION"
        xrefstyle="hyperlink"/></para>
      </listitem>
    </itemizedlist>

    <para>If a Transaction scope is active then it may either be backed by a
    Local Transaction, or by an XA Transaction, which affects the types of
    resource that can be used with the Transaction Context. The transaction
    support can be queried using the <xref
    linkend="org.osgi.service.transaction.control.TransactionContext.supportsLocal--"
    xrefstyle="hyperlink"/> and <xref
    linkend="org.osgi.service.transaction.control.TransactionContext.supportsXA--"
    xrefstyle="hyperlink"/> methods on the transaction context object. Some
    implementations may support both XA and Local resources in the same
    transaction, but these are still considered to be XA Transactions.</para>

    <section>
      <title>Transaction Lifecycle callbacks</title>

      <para>In addition to registering Resources with the Transaction Context
      clients or resources may register callback functions. Callback functions
      can run either before or after the transaction finishes, depending as to
      whether they are registered using <xref
      linkend="org.osgi.service.transaction.control.TransactionContext.preCompletion-Runnable-"
      xrefstyle="hyperlink"/> or <xref
      linkend="org.osgi.service.transaction.control.TransactionContext.postCompletion-Consumer-"
      xrefstyle="hyperlink"/> to register their callbacks.</para>

      <para>Lifecycle callbacks may be registered at any point during the
      execution of scoped work. Once the scoped work has finished it is no
      longer possible to register a pre-completion callback (for example
      inside another lifecycle callback). Attempts to register a
      pre-completion callback outside the execution of the scoped work must
      fail with an <code>IllegalStateException</code>. Post-completion
      callbacks may be also be registered with the Transaction Context after
      the scoped work completes, up to the point where the first
      post-completion callback is called. Specifically a pre-completion
      callback, or a resource participating in the transaction may register a
      post-completion callback. Attempts to register a post-completion
      callback after this must fail with an
      <code>IllegalStateException</code>.</para>

      <section>
        <title>Pre-completion Callbacks</title>

        <para>Pre-completion callbacks run immediately after the end of the
        scoped work, and before any associated transaction finishes. Because
        pre-completion callbacks run before the end of the transaction they
        are able to prevent it from committing, either by calling
        <code>setRollbackOnly()</code> or potentially by throwing a
        <code>RuntimeException</code>. If the scope is a No Transaction scope
        then there is no commit to prevent.</para>

        <para>If scoped work completes with an exception that triggers
        rollback, then the Transaction Context must be marked for rollback
        before calling any pre-completion callbacks.</para>

        <para>Exceptions generated by pre-completion callbacks are gathered,
        If any of the generated Exceptions would trigger rollback then the
        transaction is treated as having failed with the first of those
        exceptions. Any other exceptions are added as suppressed exceptions.
        Assuming that no Client Exception occurred then the failure must be
        reported by throwing a <code>TransactionRolledBackException</code>, or
        in the case of a No Transaction scope, a
        <code>TransactionException</code>.</para>
      </section>

      <section>
        <title>Post-completion Callbacks</title>

        <para>Post-completion callbacks are run after any associated
        transaction finishes. As the transaction has completed,
        post-completion callbacks receive the completion state of the
        transaction as a method parameter. In the case of a No Transaction
        context there is no transaction, so the post-completion callbacks
        immediately follow the pre-completion callbacks, and are passed a
        status of NO_TRANSACTION.</para>

        <para>Exceptions generated by post-completion callbacks are unable to
        affect the outcome of any transaction, and must therefore be logged,
        but not acted on further by the Transaction Control service.</para>

        <para>Although Post-completion callbacks run after the transaction,
        the Transaction Context must still be valid when they execute. In
        particular post-completion callbacks must have access to any scoped
        variables registered with the Transaction Context</para>
      </section>
    </section>

    <section>
      <title>Scoped variables</title>

      <para>A Transaction context may be used to store scoped variables. These
      variables are attached to the TransactionContext, and will be released
      after the Context finishes. Scoped resources are guaranteed to be
      accessible in lifecycle callbacks.</para>

      <para>Variables may be added to the scope using <xref
      linkend="org.osgi.service.transaction.control.TransactionContext.putScopedValue-Object-Object-"
      xrefstyle="hyperlink"/> and retrieved using <xref
      linkend="org.osgi.service.transaction.control.TransactionContext.getScopedValue-Object-"
      xrefstyle="hyperlink"/>. These methods are valid both for Active
      Transactions and the No Transaction scope.</para>
    </section>

    <section>
      <title>Transaction Key</title>

      <para>Every Active Transaction has an associated key, which will be
      unique within the lifetime of the TransactionControl service's
      registration. That is, a registered Transaction Control instance will
      never reuse a key. The key object is opaque, but is guaranteed to be
      suitable for use as a key in a <code>HashMap</code>. Note that the
      Transaction Key is not globally unique, but only unique to the
      registered TransactionControl service. In particular, two concurrently
      registered TransactionControl services may simultaneously use the same
      key, and/or a Transaction Control implementation may reuse keys if it
      unregisters and then re-registers its service with a different service
      id.</para>

      <para>TransactionContexts for the No Transaction scope have a null
      key.</para>
    </section>

    <section>
      <title>The Transaction Status</title>

      <para>The current state of a Transaction Context is represented by a
      Java enum, and can be queried by calling <xref
      linkend="org.osgi.service.transaction.control.TransactionContext.getTransactionStatus--"
      xrefstyle="hyperlink"/>. The status of a Transaction Context will change
      over time until it reaches a terminal state. Once a terminal state has
      been reached the status of the Transaction Context will not change
      again.</para>

      <para>The status of a Transaction Context will always move forward
      through the enum values, that is, the status can never move from one
      state to another state with a lower sort order. Note that a Transaction
      Context will not necessarily enter all of the intermediate states
      between two values.</para>

      <table>
        <title>Transaction Status Values</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1.5*"/>

          <colspec colnum="2" colwidth="0.7*"/>

          <colspec colnum="3" colwidth="3.0*"/>

          <thead>
            <row>
              <entry>Status</entry>

              <entry>Terminal</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.NO_TRANSACTION"
              xrefstyle="hyperlink"/></entry>

              <entry>yes</entry>

              <entry><para>This Transaction Context is for a No Transaction
              Scope</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.ACTIVE"
              xrefstyle="hyperlink"/></entry>

              <entry>no</entry>

              <entry><para>This Transaction Scope is executing and not marked
              for rollback</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.MARKED_ROLLBACK"
              xrefstyle="hyperlink"/></entry>

              <entry>no</entry>

              <entry><para>This Transaction Scope is executing and has been
              marked for rollback</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.PREPARING"
              xrefstyle="hyperlink"/></entry>

              <entry>no</entry>

              <entry><para>A two phase commit is occurring and the transaction
              is being prepared. This state is visible during the
              <code>prepare</code> calls on XA resources</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.PREPARED"
              xrefstyle="hyperlink"/></entry>

              <entry>no</entry>

              <entry><para>A two phase commit is occurring and the transaction
              has been prepared. This state is visible immediately prior to
              committing or rolling back XA resources</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.COMMITTING"
              xrefstyle="hyperlink"/></entry>

              <entry>no</entry>

              <entry><para>The transaction is being committed. This state is
              visible during the <code>commit</code> calls on
              resources</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.COMMITTED"
              xrefstyle="hyperlink"/></entry>

              <entry>yes</entry>

              <entry><para>The transaction was successfully
              committed.</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.ROLLING_BACK"
              xrefstyle="hyperlink"/></entry>

              <entry>no</entry>

              <entry><para>The transaction is being rolled back. This state is
              visible during the <code>rollback</code> calls on
              resources</para></entry>
            </row>

            <row>
              <entry><xref
              linkend="org.osgi.service.transaction.control.TransactionStatus.ROLLED_BACK"
              xrefstyle="hyperlink"/></entry>

              <entry>yes</entry>

              <entry><para>The transaction was successfully rolled
              back.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Local Transaction scopes</title>

      <para>A Local Transaction is not persistent, and therefore not
      recoverable. It also may not be atomic or consistent if multiple
      resources are involved. Local transactions do, however, provide
      isolation and durability, even when multiple resources are
      involved.</para>

      <para>A Local Transaction is therefore a very good choice when a single
      resource is involved as it is extremely lightweight and provides ACID
      behavior. Local Transactions do provide benefits when multiple resources
      are involved, however it is important to realize that Local Transactions
      may end up in a state where some commits have succeeded and others
      failed.</para>

      <section>
        <title>The Local Transaction Lifecycle</title>

        <para>The transaction context for a local transaction begins in the
        ACTIVE state, and may enter the MARKED_ROLLBACK state if the client
        calls setRollbackOnly().</para>

        <para>A local transaction must always return true from the
        <code>supportsLocal()</code> method, indicating that LocalResource
        participants may be registered using the
        <code>registerLocalResource(LocalResource)</code> method.</para>

        <para>Once the transactional work has completed and the pre-completion
        callbacks have run the transaction will be proceed as follows:</para>

        <table>
          <title>Lifecycle rules for Local Transactions</title>

          <tgroup cols="2">
            <colspec colnum="1" colwidth="3*"/>

            <colspec colnum="2" colwidth="3*"/>

            <thead>
              <row>
                <entry>Active</entry>

                <entry>Marked for Rollback</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><orderedlist>
                    <listitem>
                      <para>Set the Transaction Status to COMMITTING</para>
                    </listitem>

                    <listitem>
                      <para>Call commit on the first LocalResource</para>
                    </listitem>

                    <listitem>
                      <para>If the first commit fails set the status
                      Transaction Status to ROLLING_BACK and initialize a
                      TransactionRolledBackException with its cause set to the
                      failure.</para>
                    </listitem>

                    <listitem>
                      <para>Continue committing or rolling-back resources
                      based on the Transaction Status. If a failure occurs
                      then add it as a suppressed exception of an existing
                      TransactionException, creating a new
                      TransactionException if this is the first
                      failure.</para>
                    </listitem>

                    <listitem>
                      <para>Set the Transaction Status to COMMITTED or
                      ROLLED_BACK as appropriate</para>
                    </listitem>

                    <listitem>
                      <para>Call the post-completion callbacks, passing the
                      Transaction Status</para>
                    </listitem>
                  </orderedlist></entry>

                <entry><orderedlist>
                    <listitem>
                      <para>Set the Transaction Status to ROLLING_BACK</para>
                    </listitem>

                    <listitem>
                      <para>Call rollback on each of the LocalResources</para>
                    </listitem>

                    <listitem>
                      <para>If a failure occurs then add it as a suppressed
                      exception of an existing TransactionException, creating
                      a new TransactionException if this is the first
                      failure.</para>
                    </listitem>

                    <listitem>
                      <para>Set the Transaction Status to ROLLED_BACK</para>
                    </listitem>

                    <listitem>
                      <para>Call the post-completion callbacks, passing the
                      Transaction Status</para>
                    </listitem>
                  </orderedlist></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Local Transaction Support Service Properties</title>

        <para>A TransactionControl Service which supports local transactions
        may be identified using the <code>osgi.local.enabled</code> property
        which will be set to <code>Boolean.TRUE</code>.</para>
      </section>
    </section>

    <section>
      <title>XA Transaction scopes</title>

      <para>An XA transaction is persistent, and therefore can be recoverable.
      It is also atomic and consistent even if multiple resources are
      involved.</para>

      <para>An XA Transaction is therefore a very good choice when a multiple
      resource are involved as it provides ACID behavior. XA transactions are,
      however, more heavyweight than local transactions, and should only be
      used where they are needed.</para>

      <section>
        <title>The XA Transaction Lifecycle</title>

        <para>The transaction context for an XA transaction begins in the
        ACTIVE state, and may enter the MARKED_ROLLBACK state if the client
        calls setRollbackOnly().</para>

        <para>An XA transaction must always return true from the
        <code>supportsXA()</code> method, indicating that XA participants may
        be registered using the <code>registerXAResource</code> method. XA
        transactions may also support one or more LocalResource participants.
        In this case the Transaction Context should also return
        <code>true</code> from the <code>supportsLocal()</code> method,
        indicating that LocalResource participants may be registered using the
        <code>registerLocalResource</code> method.</para>

        <para>Once the transactional work has completed and the pre-completion
        callbacks have run the transaction should be completed using the
        normal XA algorithm. If the transaction fails during a commit attempt,
        resulting in a rollback, then the Transaction Control Service must
        generate a <code>TransactionRolledBackException</code>. If the
        transaction fails in any other way then the Transaction Control
        service must generate a <code>TransactionException</code>. Exceptions
        from the commit should be added to an existing ScopedWorkException if
        it exists.</para>
      </section>

      <section>
        <title>XA Transaction Support Service Properties</title>

        <para>A Transaction Control Service which supports XA transactions may
        be identified using the <code>osgi.xa.enabled</code> property which
        will be set to <code>Boolean.TRUE</code>.</para>

        <para>If the Transaction Control Service also supports Local
        transactions then it must also set the <code>osgi.local.enabled</code>
        property to <code>Boolean.TRUE</code>.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Resource Providers</title>

    <para>It is important that clients can easily control the transaction
    boundaries within their application, but it is equally important that the
    resources that the clients use participate in these transactions. In a
    Java EE Application server this is achieved by having the central
    application container create and manage all of the resources. In the
    Spring framework the Application context is responsible for ensuring that
    the resources are linked to a Transaction Manager.</para>

    <para>There is no central container in OSGi, and so a modular solution is
    required. This specification defines the concept of a Resource Provider. A
    Resource Provider is a generic service which can provide a resource of
    some kind to the client. The Resource Provider exists to ensure that the
    resource being used will always be enlisted with the correct transaction
    context.</para>

    <section>
      <title>Generic Resource Providers</title>

      <para>The purpose of a ResourceProvider is to provide the client with a
      configured resource which will automatically integrate with the correct
      transaction context at runtime.</para>

      <para>Resources are created from a Resource Provider using the following
      method:</para>

      <programlisting>
public &lt;T&gt; T getResource(TransactionControl txControl);
      </programlisting>

      <para>Typically clients will not use a plain Resource Provider, but will
      search for a specific subclass instead, which reifies the type parameter
      <code>T</code>. This allows for type safe access to resources, and
      ensures that the correct ResourceProvider implementation has been
      found.</para>

      <section>
        <title>The Basic Resource Lifecycle</title>

        <para>Resources returned by a Resource Provider are proxies to an
        underlying factory for physical resources. Whenever the proxy is
        accessed then it should check the current transaction scope. If this
        is the first time the proxy has been accessed in the scope then the
        proxy should associate a new physical resource with the scope. If the
        scope is a Transaction scope then the resource must also be enlisted
        into the transaction at this point. Subsequent uses of the proxy
        within the same scope must use the same backing physical
        resource.</para>

        <para>When a scope finishes any resources associated with the scope
        must be cleaned up without action required by the client. This rule
        applies to both the Transaction scope and the No Transaction scope,
        meaning that a client can safely write code using
        <code>TransactionControl#supports</code> without being concerned about
        resource leaks.</para>
      </section>

      <section>
        <title>Unscoped Resource Access</title>

        <para>If a resource is accessed by unscoped code then it must throw a
        TransactionException to indicate that it cannot be used without an
        active scope.</para>
      </section>

      <section>
        <title>Closing, Flushing and Committing Resources</title>

        <para>Most resources offer programmatic APIs for transaction and
        lifecycle management. For example <code>java.sql.Connection</code> has
        methods called <code>commit</code> and <code>close</code>.</para>

        <para>If a client attempts to close a scoped resource then this
        operation should be silently ignored. The resource will be
        automatically cleaned up when the current scope completes and so there
        is no need to manually close the resource. Furthermore, if the
        resource were prematurely closed then it may prevent other services
        from accessing the resource within this scope.</para>

        <para>If the resource is being used in a Transaction Scope then any
        transaction lifecycle methods, such as <code>commit</code> or
        <code>rollback</code>, must not delegate to the real resource and must
        throw a TransactionException instead.</para>
      </section>

      <section>
        <title>Releasing Resource Providers</title>

        <para>Resource Provider instances typically hold references to one or
        more physical resources, often in a pool. When a Resource Provider is
        no longer needed then it is important that these physical resources
        can be released to avoid resource leaks. The way in which a Resource
        Provider can determine it is no longer needed depends upon how the
        Resource Provider is created.</para>

        <para>If the Resource Provider is registered directly as a service
        then it may release its physical resources when it is no longer used
        by any bundles. One way to achieve this is through the use of an OSGi
        Service Factory.</para>

        <para>In some cases a Resource Provider is created by the client using
        a service from the service registry. In this case the lifecycle of the
        Resource Provider must be bounded by the lifecycle of the service that
        created it. In particular if the client bundle releases the service
        which created the Resource Provider then the Resource Provider must
        also be released. This mechanism ensures that Resource Providers do
        not need to be explicitly released by a client bundle when it stops.
        In addition services which create Resource Provider instances should
        provide a method which can be used to immediately release a particular
        Resource Provider instance without releasing service which created it.
        This allows client bundles to independently manage the lifecycle of
        multiple Resource Providers, and also to dynamically replace a
        Resource Provider instance.</para>

        <para>Once a Resource Provider has been released then all proxy
        instances associated with it must be invalidated, and all methods on
        the proxies throw <code>TransactionException</code>.</para>
      </section>
    </section>

    <section>
      <title>JDBC Resource Providers</title>

      <para>One of the most common resources to use in a transaction is a JDBC
      Connection. This specification therefore defines a specialized resource
      provider for obtaining JDBC Connections called a
      <code>JDBCConnectionProvider</code>. The purpose of this type is simply
      to reify the generic type of the ResourceProvider interface.</para>

      <para>The scoped resource for a JDBC Connection Provider is a JDBC
      connection. The scoped resource allows for JDBC connections to be
      transparently pooled, enlisted in Transaction Scopes, and automatically
      closed.</para>

      <section>
        <title>JDBC and Transaction Scopes</title>

        <para>When enlisted in an Active Transaction a JDBC connection will
        have autocommit set to false. Also the following methods must not be
        called by the client and must trigger a
        <code>TransactionException</code> if called.</para>

        <itemizedlist>
          <listitem>
            <para><code>commit()</code></para>
          </listitem>

          <listitem>
            <para><code>setAutoCommit()</code></para>
          </listitem>

          <listitem>
            <para><code>setSavepoint()</code></para>
          </listitem>

          <listitem>
            <para><code>setSavepoint(String)</code></para>
          </listitem>

          <listitem>
            <para><code>releaseSavepoint()</code></para>
          </listitem>

          <listitem>
            <para><code>rollback()</code></para>
          </listitem>

          <listitem>
            <para><code>rollback(Savepoint)</code></para>
          </listitem>
        </itemizedlist>

        <para>If the Active Transaction commits the JDBC Connection must
        commit any work performed in the transaction. Similarly if the Active
        Transaction rolls back then the JDBC Connection must roll back any
        work performed in the transaction. After the transaction completes the
        JDBC connection must be cleaned up in an appropriate way, for example
        by closing it or returning it to a connection pool. There is no need
        for the client to close the connection, and any attempt to do so must
        be ignored by the resource provider.</para>
      </section>

      <section>
        <title>JDBC and No Transaction Scopes</title>

        <para>When accessed with from the No Transaction scope the JDBC
        connection may have autocommit set to true or false depending on the
        underlying configuration of the resource provider. This value may be
        changed by the client by using <code>setAutoCommit</code> within the
        scope, but the value will be reset after the end of the scope.</para>

        <para>In the No Transaction context the JDBC connection will not be
        committed or rolled back by the Transaction Control Service or the
        Resource Provider. It is therefore the client's responsibility to call
        <code>commit</code> or <code>rollback</code> if appropriate.
        Savepoints may be used for partial rollback if desired.</para>

        <para>After the end of the scope the JDBC connection must be
        automatically cleaned up by the Resource Provider in an appropriate
        way, for example by closing it or returning it to a connection pool.
        There is no need for the client to close the connection, and any
        attempt to do so must be ignored by the resource provider.</para>
      </section>

      <section>
        <title>Closing the JDBC connection</title>

        <para>As for all resource providers, calls to close() the connection
        must be ignored. JDBC connections also have an abort() method. Abort
        is effectively an asynchronous close operation for a JDBC connection,
        and so must also be ignored for any scoped connection.</para>
      </section>

      <section>
        <title>The JDBCConnectionProviderFactory</title>

        <para>The JDBCConnectionProvider may be provided as a service directly
        in the OSGi service registry, however this may not be acceptable in
        all use cases. JDBC Connections are often authenticated using a
        username and password. If the username and password relate to a
        specific bundle then it may not be appropriate to have the fully
        configured connections available in the Service Registry. In this case
        the JDBCConnectionProviderFactory offers several factory methods that
        can programmatically create a JDBCConnectionProvider.</para>

        <section>
          <title>JDBCConnectionProvider Configuration</title>

          <para>Each factory method on the JDBCConnectionProviderFactory
          supplies set of properties which are used to configure the
          JDBCConnectionProvider, including the connection pooling behavior,
          and whether the ResourceProvider can be enlisted with XA and/or
          Local transactions.</para>

          <para>By default the JDBCConnectionProvider will have a pool of 10
          connections with a connection timeout of 30 seconds, an idle timeout
          of 10 minutes and a maximum connection lifetime of 3 hours. The
          JDBCConnectionProvider will also, by default, work all transaction
          types supported by the resource provider.</para>

          <para>If the JDBCConnectionProvider is configured to enable XA then
          the DataSourceFactory being used must support XADataSource creation.
          If a pre-configured DataSource is supplied then it must be able to
          be unwrapped to an XADataSource.</para>
        </section>

        <section>
          <title>Creating a JDBCConnectionProvider Using a
          DataSourceFactory</title>

          <para>In this case the client provides the DataSourceFactory that
          should be used, along with the properties that should be used to
          create the DataSource/XADataSource. If XA transactions are enabled
          then the factory must create an XADataSource, otherwise the
          “osgi.use.driver” property can be used to force the creation of a
          Driver instance rather than a DataSource.</para>
        </section>

        <section>
          <title>Creating a JDBCConnectionProvider Using a DataSource</title>

          <para>In this case the client provides a pre-configured DataSource
          that should be used. If XA transactions are enabled then the
          DataSource must be able to be unwrapped to an XADataSource using the
          <code>unwrap</code> method.</para>
        </section>

        <section>
          <title>Creating a JDBCConnectionProvider Using an
          XADataSource</title>

          <para>In this case the client provides a preconfigured XADataSource
          that should be used by the resource provider.</para>
        </section>

        <section>
          <title>Creating a JDBCConnectionProvider Using a Driver</title>

          <para>In this case the client provides an instantiated driver class
          that should be used, along with the properties that should be used
          to create the JDBC connection. The JDBC properties must include a
          JDBC url to use when connecting to the database. XA transactions may
          not be enabled when using a Driver instance.</para>
        </section>

        <section>
          <title>Releasing a JDBCConnectionProvider</title>

          <para>In some cases a client of the JDBCConnectionProviderFactory
          may wish to release a created JDBCConnectionProvider without
          releasing the JDBCConnectionProviderFactory service. In this case
          the JDBCConnectionProvider instance should be passed to the
          <code>releaseProvider</code> method, which will immediately release
          the Resource Provider.</para>
        </section>
      </section>

      <section>
        <title>JDBCResourceProvider Examples</title>

        <para>Setting up data Access with Declarative Services:</para>

        <programlisting>
@Reference
TransactionControl txControl;

@Reference
JDBCConnectionProviderFactory resourceProviderFactory;

@Reference
DataSourceFactory dsf;

Connection connection;

@Activate
public void setUp(Config config) {
    Properties jdbc = new Properties();
    jdbc.setProperty(JDBC_URL, config.getURL());
        
    connection = resourceProviderFactory.getProviderFor(dsf, jdbc, null)
                    .getResource(txControl);
}
         </programlisting>

        <para>Reading data from a table:</para>

        <programlisting>
txControl.supports(() -&gt; {
        ResultSet rs = connection.createStatement()
                .executeQuery("Select message from TEST_TABLE");

        rs.next();
        return rs.getString(1);
    });
         </programlisting>

        <para>Updating a table:</para>

        <programlisting>
txControl.required(() -&gt; 
        connection.createStatement()
           .execute("Insert into TEST_TABLE values ( 'Hello World!' )")
    );
         </programlisting>
      </section>
    </section>

    <section>
      <title>JPA</title>

      <para>JPA is a popular Object Relational Mapping (ORM) framework used to
      abstract away the low-level database access from business code. As an
      alternative means of accessing a database it is just as important for
      JPA resources to participate in transactions as it is for JDBC
      resources. This RFC therefore defines the
      <code>JPAEntityManagerProvider</code> interface as a specialized
      resource provider for JPA.</para>

      <section>
        <title>JPA and Transaction Scopes</title>

        <para>When enlisted in a Transaction a JPA EntityManager will
        automatically track the state of persisted entity types and update the
        database as necessary. When participating in a transaction it is
        forbidden to call the <code>getTransaction</code> 
        method on the EntityManager as manual transaction management is disabled.
        The <code>joinTransaction</code> method, however must be a no-op, and
        the <code>isJoinedToTransaction</code> must always return <code>true</code>.</para>

        <para>If the Transaction commits the JPA EntityManager must commit any
        work performed in the transaction. Similarly if the Transaction rolls
        back then the JPA EntityManager must roll back any work performed in
        the transaction. After the transaction completes the JPA EntityManager
        must be cleaned up in an appropriate way, for example by closing it or
        returning it to a pool. There is no need for the client to close the
        entity manager, and any attempt to do so must be ignored by the
        resource provider.</para>
      </section>

      <section>
        <title>JPA and No Transaction Scopes</title>

        <para>When accessed with from the No Transaction scope the JPA
        EntityManager will not be participating in a Transaction or rolled
        back, it is therefore the client's responsibility to set up an
        EntityTransaction and to call <code>commit</code> or
        <code>rollback</code> as appropriate.</para>
        
        <para>The <code>joinTransaction</code> method must throw a <code>TransactionException</code>, and
        the <code>isJoinedToTransaction</code> must always return <code>false</code>.</para>

        <para>After the end of the scope the EntityManager must be
        automatically cleaned up in an appropriate way, for example by closing
        it or returning it to a pool.</para>
      </section>

      <section>
        <title>RESOURCE_LOCAL and JTA EntityManagerFactory instances</title>

        <para>When defining a JPA Persistence Unit the author must declare
        whether the EntityManagerFactory integrates with JTA transactions, or
        is suitable for resource local usage. The JPAEntityManagerProvider
        must take this into account when creating the transactional
        resource.</para>

        <para>JTA scoped EntityManager instances may not manage their own
        transactions and must throw a JPA TransactionRequiredException if the
        client attempts to use the EntityTransaction interface. In effect the
        EntityManager behaves as a Synchronized, Transaction-Scoped, Managed
        Persistence Context as per the JPA 2.1 Specification. It is important
        to ensure that the Database connections used in a JTA Persistence Unit
        are integrated with the ongoing transaction.</para>

        <para>RESOURCE_LOCAL scoped EntityManager instances may not
        participate in XA transactions, but otherwise behave in much the same
        way as JTA EntityManager instances. The one significant difference is
        that RESOURCE_LOCAL EntityManager instances may obtain an
        EntityTransaction when running in the No Transaction context.</para>
      </section>

      <section>
        <title>The JPAEntityManagerProvider Factory</title>

        <para>The JPAEntityManagerProvider may be provided directly in the
        OSGi service registry, however this may not be acceptable in all use
        cases. Database Connections are often authenticated using a username
        and password. If the username and password relate to a specific bundle
        then it may not be appropriate to have the configured connections
        available in the Service Registry. In this case the
        JPAEntityManagerProviderFactory offers several factory methods that
        can programmatically create a JPAEntityManagerProvider.</para>

        <section>
          <title>Creating a JPAEntityManagerProvider Using an
          EntityManagerFactoryBuilder</title>

          <para>In this case the client provides the
          EntityManagerFactoryBuilder that should be used, along with the
          properties that should be used to create the
          EntityManagerFactory.</para>

          <para>The typical reason for using an EntityManagerFactoryBuilder is
          to allow for the late binding of configuration, such as the database
          location. To support this usage pattern it is best to specify as few
          properties as possible inside the persistence descriptor. For
          example:</para>

          <programlisting>
&lt;persistence-unit name="test-unit"&gt;
  &lt;description&gt;My application's persistence unit&lt;/description&gt;
&lt;/persistence-unit&gt;
          </programlisting>

          <para>Passing String class names and expecting the JPA provider to
          load the Database driver reflectively should be avoided, however a
          configured DataSource can be passed using the
          <code>javax.persistence.jtaDataSource</code> property. If the JPA
          resource provider supports XA transactions then this property may
          be used to pass a configured <code>XADataSource</code> to be
          enlisted by the provider.</para>

          <para>The <code>osgi.jdbc.provider</code> property can be passed to
          the resource provider defining a JDBCConnectionProvider that should
          be converted into a DataSource and passed to the
          EntityManageFactoryBuilder using the javax.persistence.jtaDataSource
          property. This allows the same physical database connection to be
          used by JPA and by JDBC within the same scope. Note that when using
          the <code>osgi.jdbc.provider</code> property to provide a connection
          to the database the JPA Resource Provider implementation should ignore 
          configuration properties that cannot be acted upon, for example 
          connection pool configuration, or setting an XA recovery identifier.</para>

          <para>When configured to use JTA transactions most JPA
          implementations require integration with the transaction lifecycle.
          The JPA resource provider is required introspect the Entity Manager
          Factory Builder and to provide sufficient configuration to integrate
          the JPA provider with the supplied Transaction Control service. If
          the JPA resource provider is unable to supply the necessary
          configuration for the JPA implementation being used then it must log
          a warning.</para>
        </section>

        <section>
          <title>Creating a JPAEntityManagerProvider Using an
          EntityManagerFactory</title>

          <para>In this case the client provides the configured
          EntityManagerFactory that should be used, along with the properties
          that should be used to create the EntityManager.</para>

          <para>When using an EntityManagerFactory to create the JPA resource
          provider there is no possibility for the resource provider
          implementation to customize the configuration of the
          EntityManagerFactory. This means that the client is responsible for
          fully configuring the EntityManagerFactory in this case. For Local
          Transactions this is reasonably simple, however for XA transactions
          this configuration process may be very involved. For example JPA
          providers typically require custom plugins to integrate with
          external Transaction lifecycle management. It is recommended that
          clients use the Entity Manager Factory Builder when XA transactions
          are needed.</para>
        </section>

        <section>
          <title>Releasing a JPAEntityManagerProvider</title>

          <para>In some cases a client of the JPAEntityManagerProviderFactory
          may wish to release a created JPAEntityManagerProvider without
          releasing the JPAEntityManagerProviderFactory service. In this case
          the JPAEntityManagerProvider instance should be passed to the
          <code>releaseProvider</code> method, which will immediately release
          the Resource Provider.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Connection Pooling</title>

      <para>Database connections are usually heavyweight objects that require
      significant time to create. They may also consume physical resources
      such as memory or network ports. Creating a new database connection for
      every request is therefore wasteful, and adds unnecessary load to both
      the application and the database. Caching of database connections is
      therefore a useful way of improving performance. On the other hand
      applications must be careful not to create too many database
      connections. If one thousand requests arrive simultaneously then
      creating one thousand database connections is likely to crash the
      database server. These two requirements make database connections an
      excellent candidate for pooling. A small number of connections are made
      available and recycled after use. This saves the cost of recreating the
      connection and limits the overall load on the database.</para>

      <para>In fact pooling is an excellent solution for many transactional
      resources, including JMS and EIS access.</para>

      <section>
        <title>Pooling in OSGi</title>

        <para>Pooling has traditionally been difficult in OSGi because most
        connection pooling libraries use reflective access to load the
        underlying resource connector. This obviously fails unless the pooling
        library creates a static wiring to the connector, or has dynamic
        package imports. Both of these solutions are bad practices which
        create brittle dependencies.</para>

        <para>The correct way to obtain Database connections in OSGi is to use
        a DataSourceFactory, however this offers no Connection Pooling. There
        is no real equivalent of a DataSourceFactory for JMS ConnectionFactory
        instances, but they also require manual decoration to enable
        connection pooling.</para>

        <para>As pooling is such a core requirement for transactional resource
        access it is required for JDBCConnectionProviderFactory and
        JPAEntityManagerProviderFactory instances to offer connection pooling.
        The resource provider properties can be used to override the
        connection pooling configuration defaults (or to disable connection
        pooling entirely).</para>

        <para>Third party resource providers should offer connection pooling
        using the same configuration properties and defaults wherever
        possible.</para>

        <table>
          <title>Pooling configuration properties</title>

          <tgroup cols="3">
            <colspec colnum="1" colwidth="2.3*"/>

            <colspec colnum="2" colwidth="1*"/>

            <colspec colnum="3" colwidth="2.3*"/>

            <thead>
              <row>
                <entry>Property Name</entry>

                <entry>Default</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>osgi.connection.pooling.enabled</code></entry>

                <entry><code>true</code></entry>

                <entry><para>Whether connection pooling is enabled for this
                ResourceProvider</para></entry>
              </row>

              <row>
                <entry><code>osgi.connection.timeout</code></entry>

                <entry><code>30000</code></entry>

                <entry><para>The maximum time that a client will wait for a
                connection (in ms)</para></entry>
              </row>

              <row>
                <entry><code>osgi.idle.timeout</code></entry>

                <entry><code>180000</code></entry>

                <entry><para>The time that a connection will remain idle
                before being closed (in ms)</para></entry>
              </row>

              <row>
                <entry><code>osgi.connection.lifetime</code></entry>

                <entry><code>10800000</code></entry>

                <entry><para>The maximum time that a connection will remain
                open (in ms)</para></entry>
              </row>

              <row>
                <entry><code>osgi.connection.min</code></entry>

                <entry><code>10</code></entry>

                <entry><para>The minimum number of connections that will be
                kept alive</para></entry>
              </row>

              <row>
                <entry><code>osgi.connection.max</code></entry>

                <entry><code>10</code></entry>

                <entry><para>The maximum number of connections that will exist
                in the pool</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
  </section>

  <section>
    <title>Transaction Recovery</title>

    <para>The XA transaction protocol defines a recovery mechanism which can
    be used to resolve in-doubt transactions. This is based upon the
    interaction of an XA Transaction Manager with an XAResource. In an OSGi
    environment resources may come and go at any time, as may Transaction
    Manager instances. Transaction recovery in OSGi is therefore a continuous,
    rather than a one-time process.</para>

    <para>There are two main recovery scenarios that must be resolved by a
    Transaction Manager:</para>

    <itemizedlist>
      <listitem>
        <para>Failure of one or more remote resources before the end of the
        transaction. In this case the Transaction Manager remains running and
        can roll-back or commit the other resources as appropriate. When the
        failed resource(s) eventually become available again the Transaction
        Manager can complete the in-doubt Transaction branch by committing it
        or rolling it back as appropriate.</para>
      </listitem>

      <listitem>
        <para>Failure of the Transaction Manager before the end of the
        transaction. In this case the Transaction Manager must use its
        recovery log to discover any in-doubt transaction branches. When the
        resources associated with the in-doubt transaction branches become
        available the Transaction Manager can resolve the in-doubt branch by
        committing or rolling it back as appropriate.</para>
      </listitem>
    </itemizedlist>

    <para>In both of these cases it is crucial that the Transaction Manager
    can uniquely identify the resource that is being recovered. The
    Transaction Manager must be able to tell that a returning resource is
    suitable for recovering an in-doubt transaction branch.</para>

    <para>The transaction branch itself has an Xid, which could theoretically
    be used to identify the resource. The problem with this, however, is that
    if the resource has already completed the transaction branch (for example
    if the failure occurred after sending a commit operation) then the
    resource may have discarded the Xid. We therefore require another
    identifier for a resource. The identifier must be unique to the
    Transaction Manager, but need not be Globally Unique. The identifier must
    also be persistent, that is, the same resource must have the same
    identifier after a restart of the OSGi framework. This ensures that
    transaction recovery can occur after a system crash.</para>

    <section>
      <title>Enlisting a Recoverable Resource in a Transaction</title>

      <para>When a recoverable XA resource is associated with a
      TransactionContext using the <code>registerXAResource</code> method the
      resource identifier String is passed as a second argument. This is the
      identifier that will be used to locate the resource during recovery. If
      the XAResource is not recoverable then it may simply pass null as the
      second argument when registering.</para>
    </section>

    <section>
      <title>Providing an XAResource for Recovery</title>

      <para>When recovery is required the Transaction Manager may or may not
      be actively processing transactions involving the required recoverable
      resource. Therefore the Transaction Control service must be able to
      locate and obtain an XAResource instance for a named
      ResourceProvider.</para>

      <para>To enable this the ResourceProvider must provide a whiteboard
      service which implements the <code>RecoverableXAResource</code>
      interface. This interface provides the resource identifier, and acts as
      a factory for XAResources that can be used to recover Transaction
      Branches.</para>

      <para>The Transaction Control service can use this whiteboard to locate
      the correct XAResource to use. It may be, however, that when recovery is
      attempted it is not possible to provide a valid XAResource. In this case
      the RecoverableXAResource service may throw an exception. For example if
      the ResourceProvider is providing pooling and the pool is currently
      fully used then this may result in an exception.</para>

      <para>Once the Transaction Control service has finished attempting to
      recover a Transaction branch then it must release the XAResource it
      obtained from the RecoverableXAResource using the
      <code>releaseXAResource</code> method.</para>
    </section>

    <section>
      <title>Identifying implementations which support recovery</title>

      <para>Transaction Control implementations which support recovery must
      register the Transaction Control service with the
      <code>osgi.recovery.enabled</code> service property with a value of
      <code>true</code> if recovery is enabled. Recovery may only be enabled
      if the implementation is configured for recovery, for example by
      configuring a transaction log.</para>

      <para>Resource Provider factory services which support creating
      recoverable scoped resources must also register the
      <code>osgi.recovery.enabled</code> service property with a value of
      <code>true</code>. The recovery identifier of a scoped resource created
      by the factory is specified using the
      <code>osgi.recovery.identifier</code> property. It is an error to
      attempt to create a recoverable scoped resource from a factory which
      does not support recovery, and a <code>TransactionException</code> will
      be thrown to the caller if they attempt to set a recovery identifier
      when using a factory that does not support recovery.</para>
    </section>
  </section>

  <section xml:id="service.transaction.control-capabilities">
    <title>Capabilities</title>

    <para>Implementations of the Transaction Control Service specification
    must provide a capability in the <link
    linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
    namespace representing the <xref
    linkend="org.osgi.service.transaction.control.TransactionControl"
    xrefstyle="hyperlink"/> service. This capability must also declare a uses
    constraint for the <code>org.osgi.service.transaction.control</code>
    package, and attributes indicating whether the service supports local
    transactions, XA transactions, and recovery. For example, an XA capable,
    recoverable Transaction Control implementation which also supports
    recovery would offer the following capability.</para>

    <programlisting>Provide-Capability: osgi.service;objectClass:List&lt;String&gt;=
    "org.osgi.service.transaction.control.TransactionControl";
    uses:="org.osgi.service.transaction.control";osgi.local.enabled="true";
    osgi.xa.enabled="true";osgi.recovery.enabled="true"</programlisting>

    <para>Resource Provider Implementations must provide capabilities in the
    <link
    linkend="service.namespaces-osgi.service.namespace"><code>osgi.service</code></link>
    namespace representing the <xref
    linkend="org.osgi.service.transaction.control.ResourceProvider"
    xrefstyle="hyperlink"/> services and any factory services that they
    provide. These capabilities must also declare uses constraints for
    the<code>org.osgi.service.transaction.control</code> package and any other
    packages that they provide. In the case where a more specific type is
    registered (for example JDBCConnectionProvider) then that type should be
    used instead. The service properties that indicate whether the resource
    provider supports local transactions, XA transactions, and recovery must
    be advertised as attributes. For example:</para>

    <programlisting>Provide-Capability: osgi.service;objectClass:List&lt;String&gt;=
    "org.osgi.service.transaction.control.jdbc.JDBCConnectionProvider";
    uses:="org.osgi.service.transaction.control,org.osgi.service.transaction.
    control.jdbc";osgi.local.enabled="true";osgi.xa.enabled="true";
    osgi.recovery.enabled="true", 
    osgi.service;objectClass:List&lt;String&gt;=
    "org.osgi.service.transaction.control.jdbc.JDBCConnectionProviderFactory";
    uses:="org.osgi.service.transaction.control,org.osgi.service.transaction.
    control.jdbc";osgi.local.enabled="true";osgi.xa.enabled="true";
    osgi.recovery.enabled="true"</programlisting>

    <para>These capabilities must follow the rules defined for the <xref
    linkend="service.namespaces-osgi.service.namespace"/>.</para>
  </section>

  <section xml:id="service.transaction.control-security">
    <title>Security</title>

    <para>Access to the Transaction Control service and to Resource Provider
    services can be secured through the standard OSGi service permission
    model.</para>

    <para>Clients should be aware that when they run scoped work there will be
    code from the Transaction Control service on the stack. Client operations
    that require specific privileges will therefore have to be performed
    inside a doPrivileged block.</para>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.transaction.control.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.transaction.control.jdbc.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.transaction.control.jpa.xml"/>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.transaction.control.recovery.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed><title><xref linkend="intro.core.release"
      xrefstyle="template:%t"/></title>https://www.osgi.org/developer/specifications/</bibliomixed>
    </bibliolist>
  </section>
</chapter>
